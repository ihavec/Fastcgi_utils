// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: protobuf/tvWall.proto

#ifndef PROTOBUF_protobuf_2ftvWall_2eproto__INCLUDED
#define PROTOBUF_protobuf_2ftvWall_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace TvWall {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_protobuf_2ftvWall_2eproto();
void protobuf_AssignDesc_protobuf_2ftvWall_2eproto();
void protobuf_ShutdownFile_protobuf_2ftvWall_2eproto();

class Rect;
class Point;
class Guid;
class NetInterface;
class Network;
class NVR;
class FMP;
class Packet;
class Packet_Session;
class Packet_Session_Login;
class Packet_Session_LoginAck;
class Packet_Session_LoginMasterAck;
class Packet_Session_LoginMasterAck_Server;
class Packet_Session_Logout;
class Packet_Session_LogoutAck;
class Packet_Session_Ping;
class Packet_Session_PingAck;
class Packet_ElementDat;
class Packet_ElementDat_Screen;
class Packet_ElementDat_Camera;
class Packet_ElementDat_Camera_CameraInfo;
class Packet_ElementDat_Camera_RecordInfo;
class Packet_ElementDat_CameraGrp;
class Packet_ElementDat_LocalMovie;
class Packet_ElementDat_Flash;
class Packet_ElementDat_View;
class Packet_ElementDat_FocusPoint;
class Packet_ElementDat_HotPoint;
class Packet_ElementDat_ServerLayout;
class Packet_ElementDat_ServerLayoutLoop;
class Packet_ElementDat_Map;
class Packet_ElementDat_GroupLoop;
class Packet_ElementMaster;
class Packet_ElementMaster_MasterLayout;
class Packet_ElementMaster_MasterLayout_ServerPos;
class Packet_ElementMaster_MasterLayout_MasLayout;
class Packet_Ctrl;
class Packet_Ctrl_ScreenSplitCtrl;
class Packet_Ctrl_ViewCtrl;
class Packet_Ctrl_ViewCtrl_ViewGeomotryCtrl;
class Packet_Ctrl_ViewCtrl_VideoCtrl;
class Packet_Ctrl_ViewCtrl_RecordCtrl;
class Packet_Ctrl_ViewCtrl_FlashCtrl;
class Packet_Ctrl_ViewCtrl_HTMLCtrl;
class Packet_Ctrl_ViewCtrl_LocalMovieCtrl;
class Packet_Ctrl_ViewCtrl_TextCtrl;
class Packet_Ctrl_ViewCtrl_MapCtrl;
class Packet_Ctrl_ViewCtrl_OthersCtrl;
class Packet_Ctrl_CameraCtrl;
class Packet_Ctrl_HotPointCtrl;
class Packet_Ctrl_LayoutCtrl;
class Packet_Ctrl_LayoutLoopCtrl;
class Packet_Ctrl_CtrlMaster;
class Packet_Ctrl_CtrlMaster_CtrlMasterLyout;
class Packet_Ctrl_MachineCtrl;
class Packet_Ctrl_KeyCtrl;
class Packet_Ctrl_KeyCmdCtrl;
class Packet_Ctrl_AlarmCtrl;
class Packet_Ctrl_SyncClockCtrl;
class Packet_Ctrl_TextContextCtrl;
class Packet_Ctrl_GroupLoopCtrl;
class Packet_RequireSession;
class Packet_RequireSession_ClientRequire;
class Packet_RequireSession_ClientRequireAck;
class Packet_RequireSession_LocalMovieSession;
class Packet_RequireSession_LocalMovieSessionAck;
class Packet_RequireSession_RecordRequire;
class Packet_RequireSession_RecordRequireAck;
class Packet_RequireSession_NetRequire;
class Packet_RequireSession_NetRequireAck;
class Packet_Notice;
class Packet_Notice_Stat;
class Packet_Notice_Stat_ScreenSpliStat;
class Packet_Notice_Stat_ViewStat;
class Packet_Notice_Stat_ViewStat_ViewGeomotryStat;
class Packet_Notice_Stat_ViewStat_VideoStat;
class Packet_Notice_Stat_ViewStat_RecordStat;
class Packet_Notice_Stat_ViewStat_LocalMovieStat;
class Packet_Notice_Stat_ViewStat_FlashStat;
class Packet_Notice_Stat_ViewStat_HTMLStat;
class Packet_Notice_Stat_ViewStat_TextStat;
class Packet_Notice_Stat_ViewStat_MapStat;
class Packet_Notice_Stat_ViewStat_OthersStat;
class Packet_Notice_Stat_CameraStat;
class Packet_Notice_Stat_HotPointStat;
class Packet_Notice_Stat_LayoutStat;
class Packet_Notice_Stat_LayoutLoopStat;
class Packet_Notice_Stat_MapGrpStat;
class Packet_Notice_Stat_ErrorStat;
class Packet_Notice_Stat_KeyboardSelectedStat;
class Packet_Notice_Stat_AlarmStat;
class Packet_Notice_Stat_GroupLoopStat;
class Packet_Notice_NoticeMaster;
class Packet_Notice_NoticeMaster_NoticeMasterLyout;

enum Packet_Session_LogoutReasonType {
  Packet_Session_LogoutReasonType_USER_LOGOUT = 0
};
bool Packet_Session_LogoutReasonType_IsValid(int value);
const Packet_Session_LogoutReasonType Packet_Session_LogoutReasonType_LogoutReasonType_MIN = Packet_Session_LogoutReasonType_USER_LOGOUT;
const Packet_Session_LogoutReasonType Packet_Session_LogoutReasonType_LogoutReasonType_MAX = Packet_Session_LogoutReasonType_USER_LOGOUT;
const int Packet_Session_LogoutReasonType_LogoutReasonType_ARRAYSIZE = Packet_Session_LogoutReasonType_LogoutReasonType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Packet_Session_LogoutReasonType_descriptor();
inline const ::std::string& Packet_Session_LogoutReasonType_Name(Packet_Session_LogoutReasonType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Packet_Session_LogoutReasonType_descriptor(), value);
}
inline bool Packet_Session_LogoutReasonType_Parse(
    const ::std::string& name, Packet_Session_LogoutReasonType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Packet_Session_LogoutReasonType>(
    Packet_Session_LogoutReasonType_descriptor(), name, value);
}
enum Packet_ElementDat_View_ViewType {
  Packet_ElementDat_View_ViewType_VIDEO = 0,
  Packet_ElementDat_View_ViewType_FLASH = 1,
  Packet_ElementDat_View_ViewType_HTML = 2,
  Packet_ElementDat_View_ViewType_TEXT = 3,
  Packet_ElementDat_View_ViewType_LOCAL_MOVIE = 4,
  Packet_ElementDat_View_ViewType_MAP = 5,
  Packet_ElementDat_View_ViewType_OTHERS = 6,
  Packet_ElementDat_View_ViewType_RECORDFILE = 7,
  Packet_ElementDat_View_ViewType_ALARM = 8
};
bool Packet_ElementDat_View_ViewType_IsValid(int value);
const Packet_ElementDat_View_ViewType Packet_ElementDat_View_ViewType_ViewType_MIN = Packet_ElementDat_View_ViewType_VIDEO;
const Packet_ElementDat_View_ViewType Packet_ElementDat_View_ViewType_ViewType_MAX = Packet_ElementDat_View_ViewType_ALARM;
const int Packet_ElementDat_View_ViewType_ViewType_ARRAYSIZE = Packet_ElementDat_View_ViewType_ViewType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Packet_ElementDat_View_ViewType_descriptor();
inline const ::std::string& Packet_ElementDat_View_ViewType_Name(Packet_ElementDat_View_ViewType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Packet_ElementDat_View_ViewType_descriptor(), value);
}
inline bool Packet_ElementDat_View_ViewType_Parse(
    const ::std::string& name, Packet_ElementDat_View_ViewType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Packet_ElementDat_View_ViewType>(
    Packet_ElementDat_View_ViewType_descriptor(), name, value);
}
enum Packet_Ctrl_ViewCtrl_ViewGeomotryCtrl_ViewGeomotryCtrlType {
  Packet_Ctrl_ViewCtrl_ViewGeomotryCtrl_ViewGeomotryCtrlType_CREATE = 0,
  Packet_Ctrl_ViewCtrl_ViewGeomotryCtrl_ViewGeomotryCtrlType_WINDOW_CTRL = 1,
  Packet_Ctrl_ViewCtrl_ViewGeomotryCtrl_ViewGeomotryCtrlType_REMOVE = 2,
  Packet_Ctrl_ViewCtrl_ViewGeomotryCtrl_ViewGeomotryCtrlType_SET_BORDER_WIDTH = 3,
  Packet_Ctrl_ViewCtrl_ViewGeomotryCtrl_ViewGeomotryCtrlType_SHOW_TITLE = 4
};
bool Packet_Ctrl_ViewCtrl_ViewGeomotryCtrl_ViewGeomotryCtrlType_IsValid(int value);
const Packet_Ctrl_ViewCtrl_ViewGeomotryCtrl_ViewGeomotryCtrlType Packet_Ctrl_ViewCtrl_ViewGeomotryCtrl_ViewGeomotryCtrlType_ViewGeomotryCtrlType_MIN = Packet_Ctrl_ViewCtrl_ViewGeomotryCtrl_ViewGeomotryCtrlType_CREATE;
const Packet_Ctrl_ViewCtrl_ViewGeomotryCtrl_ViewGeomotryCtrlType Packet_Ctrl_ViewCtrl_ViewGeomotryCtrl_ViewGeomotryCtrlType_ViewGeomotryCtrlType_MAX = Packet_Ctrl_ViewCtrl_ViewGeomotryCtrl_ViewGeomotryCtrlType_SHOW_TITLE;
const int Packet_Ctrl_ViewCtrl_ViewGeomotryCtrl_ViewGeomotryCtrlType_ViewGeomotryCtrlType_ARRAYSIZE = Packet_Ctrl_ViewCtrl_ViewGeomotryCtrl_ViewGeomotryCtrlType_ViewGeomotryCtrlType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Packet_Ctrl_ViewCtrl_ViewGeomotryCtrl_ViewGeomotryCtrlType_descriptor();
inline const ::std::string& Packet_Ctrl_ViewCtrl_ViewGeomotryCtrl_ViewGeomotryCtrlType_Name(Packet_Ctrl_ViewCtrl_ViewGeomotryCtrl_ViewGeomotryCtrlType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Packet_Ctrl_ViewCtrl_ViewGeomotryCtrl_ViewGeomotryCtrlType_descriptor(), value);
}
inline bool Packet_Ctrl_ViewCtrl_ViewGeomotryCtrl_ViewGeomotryCtrlType_Parse(
    const ::std::string& name, Packet_Ctrl_ViewCtrl_ViewGeomotryCtrl_ViewGeomotryCtrlType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Packet_Ctrl_ViewCtrl_ViewGeomotryCtrl_ViewGeomotryCtrlType>(
    Packet_Ctrl_ViewCtrl_ViewGeomotryCtrl_ViewGeomotryCtrlType_descriptor(), name, value);
}
enum Packet_Ctrl_ViewCtrl_VideoCtrl_VideoCtrlType {
  Packet_Ctrl_ViewCtrl_VideoCtrl_VideoCtrlType_CAMERA_ADD = 0,
  Packet_Ctrl_ViewCtrl_VideoCtrl_VideoCtrlType_CAMERA_REMOVE = 1,
  Packet_Ctrl_ViewCtrl_VideoCtrl_VideoCtrlType_POLL_INTERVAL = 2,
  Packet_Ctrl_ViewCtrl_VideoCtrl_VideoCtrlType_KEEP_STRETCH = 3
};
bool Packet_Ctrl_ViewCtrl_VideoCtrl_VideoCtrlType_IsValid(int value);
const Packet_Ctrl_ViewCtrl_VideoCtrl_VideoCtrlType Packet_Ctrl_ViewCtrl_VideoCtrl_VideoCtrlType_VideoCtrlType_MIN = Packet_Ctrl_ViewCtrl_VideoCtrl_VideoCtrlType_CAMERA_ADD;
const Packet_Ctrl_ViewCtrl_VideoCtrl_VideoCtrlType Packet_Ctrl_ViewCtrl_VideoCtrl_VideoCtrlType_VideoCtrlType_MAX = Packet_Ctrl_ViewCtrl_VideoCtrl_VideoCtrlType_KEEP_STRETCH;
const int Packet_Ctrl_ViewCtrl_VideoCtrl_VideoCtrlType_VideoCtrlType_ARRAYSIZE = Packet_Ctrl_ViewCtrl_VideoCtrl_VideoCtrlType_VideoCtrlType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Packet_Ctrl_ViewCtrl_VideoCtrl_VideoCtrlType_descriptor();
inline const ::std::string& Packet_Ctrl_ViewCtrl_VideoCtrl_VideoCtrlType_Name(Packet_Ctrl_ViewCtrl_VideoCtrl_VideoCtrlType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Packet_Ctrl_ViewCtrl_VideoCtrl_VideoCtrlType_descriptor(), value);
}
inline bool Packet_Ctrl_ViewCtrl_VideoCtrl_VideoCtrlType_Parse(
    const ::std::string& name, Packet_Ctrl_ViewCtrl_VideoCtrl_VideoCtrlType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Packet_Ctrl_ViewCtrl_VideoCtrl_VideoCtrlType>(
    Packet_Ctrl_ViewCtrl_VideoCtrl_VideoCtrlType_descriptor(), name, value);
}
enum Packet_Ctrl_ViewCtrl_RecordCtrl_RecordCtrlType {
  Packet_Ctrl_ViewCtrl_RecordCtrl_RecordCtrlType_RESET_START_TIME = 0,
  Packet_Ctrl_ViewCtrl_RecordCtrl_RecordCtrlType_KEEP_STRETCH = 1,
  Packet_Ctrl_ViewCtrl_RecordCtrl_RecordCtrlType_SET_RATE = 2,
  Packet_Ctrl_ViewCtrl_RecordCtrl_RecordCtrlType_PAUSE = 3,
  Packet_Ctrl_ViewCtrl_RecordCtrl_RecordCtrlType_SLOW = 4,
  Packet_Ctrl_ViewCtrl_RecordCtrl_RecordCtrlType_FAST = 5,
  Packet_Ctrl_ViewCtrl_RecordCtrl_RecordCtrlType_BACK = 6,
  Packet_Ctrl_ViewCtrl_RecordCtrl_RecordCtrlType_FORWARD = 7
};
bool Packet_Ctrl_ViewCtrl_RecordCtrl_RecordCtrlType_IsValid(int value);
const Packet_Ctrl_ViewCtrl_RecordCtrl_RecordCtrlType Packet_Ctrl_ViewCtrl_RecordCtrl_RecordCtrlType_RecordCtrlType_MIN = Packet_Ctrl_ViewCtrl_RecordCtrl_RecordCtrlType_RESET_START_TIME;
const Packet_Ctrl_ViewCtrl_RecordCtrl_RecordCtrlType Packet_Ctrl_ViewCtrl_RecordCtrl_RecordCtrlType_RecordCtrlType_MAX = Packet_Ctrl_ViewCtrl_RecordCtrl_RecordCtrlType_FORWARD;
const int Packet_Ctrl_ViewCtrl_RecordCtrl_RecordCtrlType_RecordCtrlType_ARRAYSIZE = Packet_Ctrl_ViewCtrl_RecordCtrl_RecordCtrlType_RecordCtrlType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Packet_Ctrl_ViewCtrl_RecordCtrl_RecordCtrlType_descriptor();
inline const ::std::string& Packet_Ctrl_ViewCtrl_RecordCtrl_RecordCtrlType_Name(Packet_Ctrl_ViewCtrl_RecordCtrl_RecordCtrlType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Packet_Ctrl_ViewCtrl_RecordCtrl_RecordCtrlType_descriptor(), value);
}
inline bool Packet_Ctrl_ViewCtrl_RecordCtrl_RecordCtrlType_Parse(
    const ::std::string& name, Packet_Ctrl_ViewCtrl_RecordCtrl_RecordCtrlType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Packet_Ctrl_ViewCtrl_RecordCtrl_RecordCtrlType>(
    Packet_Ctrl_ViewCtrl_RecordCtrl_RecordCtrlType_descriptor(), name, value);
}
enum Packet_Ctrl_ViewCtrl_FlashCtrl_FlashCtrlType {
  Packet_Ctrl_ViewCtrl_FlashCtrl_FlashCtrlType_SET_FLASH = 0
};
bool Packet_Ctrl_ViewCtrl_FlashCtrl_FlashCtrlType_IsValid(int value);
const Packet_Ctrl_ViewCtrl_FlashCtrl_FlashCtrlType Packet_Ctrl_ViewCtrl_FlashCtrl_FlashCtrlType_FlashCtrlType_MIN = Packet_Ctrl_ViewCtrl_FlashCtrl_FlashCtrlType_SET_FLASH;
const Packet_Ctrl_ViewCtrl_FlashCtrl_FlashCtrlType Packet_Ctrl_ViewCtrl_FlashCtrl_FlashCtrlType_FlashCtrlType_MAX = Packet_Ctrl_ViewCtrl_FlashCtrl_FlashCtrlType_SET_FLASH;
const int Packet_Ctrl_ViewCtrl_FlashCtrl_FlashCtrlType_FlashCtrlType_ARRAYSIZE = Packet_Ctrl_ViewCtrl_FlashCtrl_FlashCtrlType_FlashCtrlType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Packet_Ctrl_ViewCtrl_FlashCtrl_FlashCtrlType_descriptor();
inline const ::std::string& Packet_Ctrl_ViewCtrl_FlashCtrl_FlashCtrlType_Name(Packet_Ctrl_ViewCtrl_FlashCtrl_FlashCtrlType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Packet_Ctrl_ViewCtrl_FlashCtrl_FlashCtrlType_descriptor(), value);
}
inline bool Packet_Ctrl_ViewCtrl_FlashCtrl_FlashCtrlType_Parse(
    const ::std::string& name, Packet_Ctrl_ViewCtrl_FlashCtrl_FlashCtrlType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Packet_Ctrl_ViewCtrl_FlashCtrl_FlashCtrlType>(
    Packet_Ctrl_ViewCtrl_FlashCtrl_FlashCtrlType_descriptor(), name, value);
}
enum Packet_Ctrl_ViewCtrl_HTMLCtrl_HTMLCtrlType {
  Packet_Ctrl_ViewCtrl_HTMLCtrl_HTMLCtrlType_SET_HTML = 0
};
bool Packet_Ctrl_ViewCtrl_HTMLCtrl_HTMLCtrlType_IsValid(int value);
const Packet_Ctrl_ViewCtrl_HTMLCtrl_HTMLCtrlType Packet_Ctrl_ViewCtrl_HTMLCtrl_HTMLCtrlType_HTMLCtrlType_MIN = Packet_Ctrl_ViewCtrl_HTMLCtrl_HTMLCtrlType_SET_HTML;
const Packet_Ctrl_ViewCtrl_HTMLCtrl_HTMLCtrlType Packet_Ctrl_ViewCtrl_HTMLCtrl_HTMLCtrlType_HTMLCtrlType_MAX = Packet_Ctrl_ViewCtrl_HTMLCtrl_HTMLCtrlType_SET_HTML;
const int Packet_Ctrl_ViewCtrl_HTMLCtrl_HTMLCtrlType_HTMLCtrlType_ARRAYSIZE = Packet_Ctrl_ViewCtrl_HTMLCtrl_HTMLCtrlType_HTMLCtrlType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Packet_Ctrl_ViewCtrl_HTMLCtrl_HTMLCtrlType_descriptor();
inline const ::std::string& Packet_Ctrl_ViewCtrl_HTMLCtrl_HTMLCtrlType_Name(Packet_Ctrl_ViewCtrl_HTMLCtrl_HTMLCtrlType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Packet_Ctrl_ViewCtrl_HTMLCtrl_HTMLCtrlType_descriptor(), value);
}
inline bool Packet_Ctrl_ViewCtrl_HTMLCtrl_HTMLCtrlType_Parse(
    const ::std::string& name, Packet_Ctrl_ViewCtrl_HTMLCtrl_HTMLCtrlType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Packet_Ctrl_ViewCtrl_HTMLCtrl_HTMLCtrlType>(
    Packet_Ctrl_ViewCtrl_HTMLCtrl_HTMLCtrlType_descriptor(), name, value);
}
enum Packet_Ctrl_ViewCtrl_LocalMovieCtrl_LocalMovieType {
  Packet_Ctrl_ViewCtrl_LocalMovieCtrl_LocalMovieType_SET_FILE = 0,
  Packet_Ctrl_ViewCtrl_LocalMovieCtrl_LocalMovieType_SET_VOLUME = 1,
  Packet_Ctrl_ViewCtrl_LocalMovieCtrl_LocalMovieType_SET_SLIDER = 2,
  Packet_Ctrl_ViewCtrl_LocalMovieCtrl_LocalMovieType_PAUSE = 3,
  Packet_Ctrl_ViewCtrl_LocalMovieCtrl_LocalMovieType_STOP = 4
};
bool Packet_Ctrl_ViewCtrl_LocalMovieCtrl_LocalMovieType_IsValid(int value);
const Packet_Ctrl_ViewCtrl_LocalMovieCtrl_LocalMovieType Packet_Ctrl_ViewCtrl_LocalMovieCtrl_LocalMovieType_LocalMovieType_MIN = Packet_Ctrl_ViewCtrl_LocalMovieCtrl_LocalMovieType_SET_FILE;
const Packet_Ctrl_ViewCtrl_LocalMovieCtrl_LocalMovieType Packet_Ctrl_ViewCtrl_LocalMovieCtrl_LocalMovieType_LocalMovieType_MAX = Packet_Ctrl_ViewCtrl_LocalMovieCtrl_LocalMovieType_STOP;
const int Packet_Ctrl_ViewCtrl_LocalMovieCtrl_LocalMovieType_LocalMovieType_ARRAYSIZE = Packet_Ctrl_ViewCtrl_LocalMovieCtrl_LocalMovieType_LocalMovieType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Packet_Ctrl_ViewCtrl_LocalMovieCtrl_LocalMovieType_descriptor();
inline const ::std::string& Packet_Ctrl_ViewCtrl_LocalMovieCtrl_LocalMovieType_Name(Packet_Ctrl_ViewCtrl_LocalMovieCtrl_LocalMovieType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Packet_Ctrl_ViewCtrl_LocalMovieCtrl_LocalMovieType_descriptor(), value);
}
inline bool Packet_Ctrl_ViewCtrl_LocalMovieCtrl_LocalMovieType_Parse(
    const ::std::string& name, Packet_Ctrl_ViewCtrl_LocalMovieCtrl_LocalMovieType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Packet_Ctrl_ViewCtrl_LocalMovieCtrl_LocalMovieType>(
    Packet_Ctrl_ViewCtrl_LocalMovieCtrl_LocalMovieType_descriptor(), name, value);
}
enum Packet_Ctrl_ViewCtrl_TextCtrl_TextCtrlType {
  Packet_Ctrl_ViewCtrl_TextCtrl_TextCtrlType_SET_TEXT = 0
};
bool Packet_Ctrl_ViewCtrl_TextCtrl_TextCtrlType_IsValid(int value);
const Packet_Ctrl_ViewCtrl_TextCtrl_TextCtrlType Packet_Ctrl_ViewCtrl_TextCtrl_TextCtrlType_TextCtrlType_MIN = Packet_Ctrl_ViewCtrl_TextCtrl_TextCtrlType_SET_TEXT;
const Packet_Ctrl_ViewCtrl_TextCtrl_TextCtrlType Packet_Ctrl_ViewCtrl_TextCtrl_TextCtrlType_TextCtrlType_MAX = Packet_Ctrl_ViewCtrl_TextCtrl_TextCtrlType_SET_TEXT;
const int Packet_Ctrl_ViewCtrl_TextCtrl_TextCtrlType_TextCtrlType_ARRAYSIZE = Packet_Ctrl_ViewCtrl_TextCtrl_TextCtrlType_TextCtrlType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Packet_Ctrl_ViewCtrl_TextCtrl_TextCtrlType_descriptor();
inline const ::std::string& Packet_Ctrl_ViewCtrl_TextCtrl_TextCtrlType_Name(Packet_Ctrl_ViewCtrl_TextCtrl_TextCtrlType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Packet_Ctrl_ViewCtrl_TextCtrl_TextCtrlType_descriptor(), value);
}
inline bool Packet_Ctrl_ViewCtrl_TextCtrl_TextCtrlType_Parse(
    const ::std::string& name, Packet_Ctrl_ViewCtrl_TextCtrl_TextCtrlType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Packet_Ctrl_ViewCtrl_TextCtrl_TextCtrlType>(
    Packet_Ctrl_ViewCtrl_TextCtrl_TextCtrlType_descriptor(), name, value);
}
enum Packet_Ctrl_ViewCtrl_MapCtrl_MapCtrlType {
  Packet_Ctrl_ViewCtrl_MapCtrl_MapCtrlType_SET_MAP = 0
};
bool Packet_Ctrl_ViewCtrl_MapCtrl_MapCtrlType_IsValid(int value);
const Packet_Ctrl_ViewCtrl_MapCtrl_MapCtrlType Packet_Ctrl_ViewCtrl_MapCtrl_MapCtrlType_MapCtrlType_MIN = Packet_Ctrl_ViewCtrl_MapCtrl_MapCtrlType_SET_MAP;
const Packet_Ctrl_ViewCtrl_MapCtrl_MapCtrlType Packet_Ctrl_ViewCtrl_MapCtrl_MapCtrlType_MapCtrlType_MAX = Packet_Ctrl_ViewCtrl_MapCtrl_MapCtrlType_SET_MAP;
const int Packet_Ctrl_ViewCtrl_MapCtrl_MapCtrlType_MapCtrlType_ARRAYSIZE = Packet_Ctrl_ViewCtrl_MapCtrl_MapCtrlType_MapCtrlType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Packet_Ctrl_ViewCtrl_MapCtrl_MapCtrlType_descriptor();
inline const ::std::string& Packet_Ctrl_ViewCtrl_MapCtrl_MapCtrlType_Name(Packet_Ctrl_ViewCtrl_MapCtrl_MapCtrlType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Packet_Ctrl_ViewCtrl_MapCtrl_MapCtrlType_descriptor(), value);
}
inline bool Packet_Ctrl_ViewCtrl_MapCtrl_MapCtrlType_Parse(
    const ::std::string& name, Packet_Ctrl_ViewCtrl_MapCtrl_MapCtrlType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Packet_Ctrl_ViewCtrl_MapCtrl_MapCtrlType>(
    Packet_Ctrl_ViewCtrl_MapCtrl_MapCtrlType_descriptor(), name, value);
}
enum Packet_Ctrl_ViewCtrl_OthersCtrl_OthersCtrlType {
  Packet_Ctrl_ViewCtrl_OthersCtrl_OthersCtrlType_OTHER_ADD = 0
};
bool Packet_Ctrl_ViewCtrl_OthersCtrl_OthersCtrlType_IsValid(int value);
const Packet_Ctrl_ViewCtrl_OthersCtrl_OthersCtrlType Packet_Ctrl_ViewCtrl_OthersCtrl_OthersCtrlType_OthersCtrlType_MIN = Packet_Ctrl_ViewCtrl_OthersCtrl_OthersCtrlType_OTHER_ADD;
const Packet_Ctrl_ViewCtrl_OthersCtrl_OthersCtrlType Packet_Ctrl_ViewCtrl_OthersCtrl_OthersCtrlType_OthersCtrlType_MAX = Packet_Ctrl_ViewCtrl_OthersCtrl_OthersCtrlType_OTHER_ADD;
const int Packet_Ctrl_ViewCtrl_OthersCtrl_OthersCtrlType_OthersCtrlType_ARRAYSIZE = Packet_Ctrl_ViewCtrl_OthersCtrl_OthersCtrlType_OthersCtrlType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Packet_Ctrl_ViewCtrl_OthersCtrl_OthersCtrlType_descriptor();
inline const ::std::string& Packet_Ctrl_ViewCtrl_OthersCtrl_OthersCtrlType_Name(Packet_Ctrl_ViewCtrl_OthersCtrl_OthersCtrlType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Packet_Ctrl_ViewCtrl_OthersCtrl_OthersCtrlType_descriptor(), value);
}
inline bool Packet_Ctrl_ViewCtrl_OthersCtrl_OthersCtrlType_Parse(
    const ::std::string& name, Packet_Ctrl_ViewCtrl_OthersCtrl_OthersCtrlType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Packet_Ctrl_ViewCtrl_OthersCtrl_OthersCtrlType>(
    Packet_Ctrl_ViewCtrl_OthersCtrl_OthersCtrlType_descriptor(), name, value);
}
enum Packet_Ctrl_CameraCtrl_PTZ_TYPE {
  Packet_Ctrl_CameraCtrl_PTZ_TYPE_LEFT = 0,
  Packet_Ctrl_CameraCtrl_PTZ_TYPE_RIGHT = 1,
  Packet_Ctrl_CameraCtrl_PTZ_TYPE_UP = 2,
  Packet_Ctrl_CameraCtrl_PTZ_TYPE_DOWN = 3
};
bool Packet_Ctrl_CameraCtrl_PTZ_TYPE_IsValid(int value);
const Packet_Ctrl_CameraCtrl_PTZ_TYPE Packet_Ctrl_CameraCtrl_PTZ_TYPE_PTZ_TYPE_MIN = Packet_Ctrl_CameraCtrl_PTZ_TYPE_LEFT;
const Packet_Ctrl_CameraCtrl_PTZ_TYPE Packet_Ctrl_CameraCtrl_PTZ_TYPE_PTZ_TYPE_MAX = Packet_Ctrl_CameraCtrl_PTZ_TYPE_DOWN;
const int Packet_Ctrl_CameraCtrl_PTZ_TYPE_PTZ_TYPE_ARRAYSIZE = Packet_Ctrl_CameraCtrl_PTZ_TYPE_PTZ_TYPE_MAX + 1;

const ::google::protobuf::EnumDescriptor* Packet_Ctrl_CameraCtrl_PTZ_TYPE_descriptor();
inline const ::std::string& Packet_Ctrl_CameraCtrl_PTZ_TYPE_Name(Packet_Ctrl_CameraCtrl_PTZ_TYPE value) {
  return ::google::protobuf::internal::NameOfEnum(
    Packet_Ctrl_CameraCtrl_PTZ_TYPE_descriptor(), value);
}
inline bool Packet_Ctrl_CameraCtrl_PTZ_TYPE_Parse(
    const ::std::string& name, Packet_Ctrl_CameraCtrl_PTZ_TYPE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Packet_Ctrl_CameraCtrl_PTZ_TYPE>(
    Packet_Ctrl_CameraCtrl_PTZ_TYPE_descriptor(), name, value);
}
enum Packet_Ctrl_HotPointCtrl_HotPointCtrlType {
  Packet_Ctrl_HotPointCtrl_HotPointCtrlType_CREATE = 0,
  Packet_Ctrl_HotPointCtrl_HotPointCtrlType_REMOVE = 1,
  Packet_Ctrl_HotPointCtrl_HotPointCtrlType_RESET = 2,
  Packet_Ctrl_HotPointCtrl_HotPointCtrlType_RESET_SCREEN = 3
};
bool Packet_Ctrl_HotPointCtrl_HotPointCtrlType_IsValid(int value);
const Packet_Ctrl_HotPointCtrl_HotPointCtrlType Packet_Ctrl_HotPointCtrl_HotPointCtrlType_HotPointCtrlType_MIN = Packet_Ctrl_HotPointCtrl_HotPointCtrlType_CREATE;
const Packet_Ctrl_HotPointCtrl_HotPointCtrlType Packet_Ctrl_HotPointCtrl_HotPointCtrlType_HotPointCtrlType_MAX = Packet_Ctrl_HotPointCtrl_HotPointCtrlType_RESET_SCREEN;
const int Packet_Ctrl_HotPointCtrl_HotPointCtrlType_HotPointCtrlType_ARRAYSIZE = Packet_Ctrl_HotPointCtrl_HotPointCtrlType_HotPointCtrlType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Packet_Ctrl_HotPointCtrl_HotPointCtrlType_descriptor();
inline const ::std::string& Packet_Ctrl_HotPointCtrl_HotPointCtrlType_Name(Packet_Ctrl_HotPointCtrl_HotPointCtrlType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Packet_Ctrl_HotPointCtrl_HotPointCtrlType_descriptor(), value);
}
inline bool Packet_Ctrl_HotPointCtrl_HotPointCtrlType_Parse(
    const ::std::string& name, Packet_Ctrl_HotPointCtrl_HotPointCtrlType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Packet_Ctrl_HotPointCtrl_HotPointCtrlType>(
    Packet_Ctrl_HotPointCtrl_HotPointCtrlType_descriptor(), name, value);
}
enum Packet_Ctrl_LayoutCtrl_LayoutCtrlType {
  Packet_Ctrl_LayoutCtrl_LayoutCtrlType_SAVE_CURRENT = 0,
  Packet_Ctrl_LayoutCtrl_LayoutCtrlType_DEL = 1,
  Packet_Ctrl_LayoutCtrl_LayoutCtrlType_USE = 2
};
bool Packet_Ctrl_LayoutCtrl_LayoutCtrlType_IsValid(int value);
const Packet_Ctrl_LayoutCtrl_LayoutCtrlType Packet_Ctrl_LayoutCtrl_LayoutCtrlType_LayoutCtrlType_MIN = Packet_Ctrl_LayoutCtrl_LayoutCtrlType_SAVE_CURRENT;
const Packet_Ctrl_LayoutCtrl_LayoutCtrlType Packet_Ctrl_LayoutCtrl_LayoutCtrlType_LayoutCtrlType_MAX = Packet_Ctrl_LayoutCtrl_LayoutCtrlType_USE;
const int Packet_Ctrl_LayoutCtrl_LayoutCtrlType_LayoutCtrlType_ARRAYSIZE = Packet_Ctrl_LayoutCtrl_LayoutCtrlType_LayoutCtrlType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Packet_Ctrl_LayoutCtrl_LayoutCtrlType_descriptor();
inline const ::std::string& Packet_Ctrl_LayoutCtrl_LayoutCtrlType_Name(Packet_Ctrl_LayoutCtrl_LayoutCtrlType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Packet_Ctrl_LayoutCtrl_LayoutCtrlType_descriptor(), value);
}
inline bool Packet_Ctrl_LayoutCtrl_LayoutCtrlType_Parse(
    const ::std::string& name, Packet_Ctrl_LayoutCtrl_LayoutCtrlType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Packet_Ctrl_LayoutCtrl_LayoutCtrlType>(
    Packet_Ctrl_LayoutCtrl_LayoutCtrlType_descriptor(), name, value);
}
enum Packet_Ctrl_LayoutLoopCtrl_LayoutLoopCtrlType {
  Packet_Ctrl_LayoutLoopCtrl_LayoutLoopCtrlType_ADD = 0,
  Packet_Ctrl_LayoutLoopCtrl_LayoutLoopCtrlType_REMOVE = 1,
  Packet_Ctrl_LayoutLoopCtrl_LayoutLoopCtrlType_ADD_LAYOUT = 2,
  Packet_Ctrl_LayoutLoopCtrl_LayoutLoopCtrlType_USE = 3,
  Packet_Ctrl_LayoutLoopCtrl_LayoutLoopCtrlType_SET_LOOP = 4,
  Packet_Ctrl_LayoutLoopCtrl_LayoutLoopCtrlType_STOP = 5
};
bool Packet_Ctrl_LayoutLoopCtrl_LayoutLoopCtrlType_IsValid(int value);
const Packet_Ctrl_LayoutLoopCtrl_LayoutLoopCtrlType Packet_Ctrl_LayoutLoopCtrl_LayoutLoopCtrlType_LayoutLoopCtrlType_MIN = Packet_Ctrl_LayoutLoopCtrl_LayoutLoopCtrlType_ADD;
const Packet_Ctrl_LayoutLoopCtrl_LayoutLoopCtrlType Packet_Ctrl_LayoutLoopCtrl_LayoutLoopCtrlType_LayoutLoopCtrlType_MAX = Packet_Ctrl_LayoutLoopCtrl_LayoutLoopCtrlType_STOP;
const int Packet_Ctrl_LayoutLoopCtrl_LayoutLoopCtrlType_LayoutLoopCtrlType_ARRAYSIZE = Packet_Ctrl_LayoutLoopCtrl_LayoutLoopCtrlType_LayoutLoopCtrlType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Packet_Ctrl_LayoutLoopCtrl_LayoutLoopCtrlType_descriptor();
inline const ::std::string& Packet_Ctrl_LayoutLoopCtrl_LayoutLoopCtrlType_Name(Packet_Ctrl_LayoutLoopCtrl_LayoutLoopCtrlType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Packet_Ctrl_LayoutLoopCtrl_LayoutLoopCtrlType_descriptor(), value);
}
inline bool Packet_Ctrl_LayoutLoopCtrl_LayoutLoopCtrlType_Parse(
    const ::std::string& name, Packet_Ctrl_LayoutLoopCtrl_LayoutLoopCtrlType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Packet_Ctrl_LayoutLoopCtrl_LayoutLoopCtrlType>(
    Packet_Ctrl_LayoutLoopCtrl_LayoutLoopCtrlType_descriptor(), name, value);
}
enum Packet_Ctrl_CtrlMaster_CtrlMasterLyout_CMLType {
  Packet_Ctrl_CtrlMaster_CtrlMasterLyout_CMLType_SAVE = 0,
  Packet_Ctrl_CtrlMaster_CtrlMasterLyout_CMLType_DEL = 1
};
bool Packet_Ctrl_CtrlMaster_CtrlMasterLyout_CMLType_IsValid(int value);
const Packet_Ctrl_CtrlMaster_CtrlMasterLyout_CMLType Packet_Ctrl_CtrlMaster_CtrlMasterLyout_CMLType_CMLType_MIN = Packet_Ctrl_CtrlMaster_CtrlMasterLyout_CMLType_SAVE;
const Packet_Ctrl_CtrlMaster_CtrlMasterLyout_CMLType Packet_Ctrl_CtrlMaster_CtrlMasterLyout_CMLType_CMLType_MAX = Packet_Ctrl_CtrlMaster_CtrlMasterLyout_CMLType_DEL;
const int Packet_Ctrl_CtrlMaster_CtrlMasterLyout_CMLType_CMLType_ARRAYSIZE = Packet_Ctrl_CtrlMaster_CtrlMasterLyout_CMLType_CMLType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Packet_Ctrl_CtrlMaster_CtrlMasterLyout_CMLType_descriptor();
inline const ::std::string& Packet_Ctrl_CtrlMaster_CtrlMasterLyout_CMLType_Name(Packet_Ctrl_CtrlMaster_CtrlMasterLyout_CMLType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Packet_Ctrl_CtrlMaster_CtrlMasterLyout_CMLType_descriptor(), value);
}
inline bool Packet_Ctrl_CtrlMaster_CtrlMasterLyout_CMLType_Parse(
    const ::std::string& name, Packet_Ctrl_CtrlMaster_CtrlMasterLyout_CMLType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Packet_Ctrl_CtrlMaster_CtrlMasterLyout_CMLType>(
    Packet_Ctrl_CtrlMaster_CtrlMasterLyout_CMLType_descriptor(), name, value);
}
enum Packet_Ctrl_MachineCtrl_MachineCtrlType {
  Packet_Ctrl_MachineCtrl_MachineCtrlType_REBOOT = 0,
  Packet_Ctrl_MachineCtrl_MachineCtrlType_SOFT_REBOOT = 1,
  Packet_Ctrl_MachineCtrl_MachineCtrlType_SET_SCREEN = 2,
  Packet_Ctrl_MachineCtrl_MachineCtrlType_POWEROFF = 3,
  Packet_Ctrl_MachineCtrl_MachineCtrlType_NET_HOST = 4,
  Packet_Ctrl_MachineCtrl_MachineCtrlType_NET_GATEWAY = 5,
  Packet_Ctrl_MachineCtrl_MachineCtrlType_NET_INTERFACE = 6,
  Packet_Ctrl_MachineCtrl_MachineCtrlType_NVR_ADD = 7,
  Packet_Ctrl_MachineCtrl_MachineCtrlType_NVR_DEL = 8,
  Packet_Ctrl_MachineCtrl_MachineCtrlType_FMP = 9,
  Packet_Ctrl_MachineCtrl_MachineCtrlType_TVWALL_INDEX = 10
};
bool Packet_Ctrl_MachineCtrl_MachineCtrlType_IsValid(int value);
const Packet_Ctrl_MachineCtrl_MachineCtrlType Packet_Ctrl_MachineCtrl_MachineCtrlType_MachineCtrlType_MIN = Packet_Ctrl_MachineCtrl_MachineCtrlType_REBOOT;
const Packet_Ctrl_MachineCtrl_MachineCtrlType Packet_Ctrl_MachineCtrl_MachineCtrlType_MachineCtrlType_MAX = Packet_Ctrl_MachineCtrl_MachineCtrlType_TVWALL_INDEX;
const int Packet_Ctrl_MachineCtrl_MachineCtrlType_MachineCtrlType_ARRAYSIZE = Packet_Ctrl_MachineCtrl_MachineCtrlType_MachineCtrlType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Packet_Ctrl_MachineCtrl_MachineCtrlType_descriptor();
inline const ::std::string& Packet_Ctrl_MachineCtrl_MachineCtrlType_Name(Packet_Ctrl_MachineCtrl_MachineCtrlType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Packet_Ctrl_MachineCtrl_MachineCtrlType_descriptor(), value);
}
inline bool Packet_Ctrl_MachineCtrl_MachineCtrlType_Parse(
    const ::std::string& name, Packet_Ctrl_MachineCtrl_MachineCtrlType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Packet_Ctrl_MachineCtrl_MachineCtrlType>(
    Packet_Ctrl_MachineCtrl_MachineCtrlType_descriptor(), name, value);
}
enum Packet_Ctrl_KeyCtrl_KeyType {
  Packet_Ctrl_KeyCtrl_KeyType_KeyPress = 0,
  Packet_Ctrl_KeyCtrl_KeyType_KeyRelease = 1,
  Packet_Ctrl_KeyCtrl_KeyType_ShortcutOverride = 2
};
bool Packet_Ctrl_KeyCtrl_KeyType_IsValid(int value);
const Packet_Ctrl_KeyCtrl_KeyType Packet_Ctrl_KeyCtrl_KeyType_KeyType_MIN = Packet_Ctrl_KeyCtrl_KeyType_KeyPress;
const Packet_Ctrl_KeyCtrl_KeyType Packet_Ctrl_KeyCtrl_KeyType_KeyType_MAX = Packet_Ctrl_KeyCtrl_KeyType_ShortcutOverride;
const int Packet_Ctrl_KeyCtrl_KeyType_KeyType_ARRAYSIZE = Packet_Ctrl_KeyCtrl_KeyType_KeyType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Packet_Ctrl_KeyCtrl_KeyType_descriptor();
inline const ::std::string& Packet_Ctrl_KeyCtrl_KeyType_Name(Packet_Ctrl_KeyCtrl_KeyType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Packet_Ctrl_KeyCtrl_KeyType_descriptor(), value);
}
inline bool Packet_Ctrl_KeyCtrl_KeyType_Parse(
    const ::std::string& name, Packet_Ctrl_KeyCtrl_KeyType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Packet_Ctrl_KeyCtrl_KeyType>(
    Packet_Ctrl_KeyCtrl_KeyType_descriptor(), name, value);
}
enum Packet_Ctrl_KeyCmdCtrl_KeyCmdType {
  Packet_Ctrl_KeyCmdCtrl_KeyCmdType_Media = 0,
  Packet_Ctrl_KeyCmdCtrl_KeyCmdType_Ptz = 1,
  Packet_Ctrl_KeyCmdCtrl_KeyCmdType_Preset = 2,
  Packet_Ctrl_KeyCmdCtrl_KeyCmdType_tour = 3
};
bool Packet_Ctrl_KeyCmdCtrl_KeyCmdType_IsValid(int value);
const Packet_Ctrl_KeyCmdCtrl_KeyCmdType Packet_Ctrl_KeyCmdCtrl_KeyCmdType_KeyCmdType_MIN = Packet_Ctrl_KeyCmdCtrl_KeyCmdType_Media;
const Packet_Ctrl_KeyCmdCtrl_KeyCmdType Packet_Ctrl_KeyCmdCtrl_KeyCmdType_KeyCmdType_MAX = Packet_Ctrl_KeyCmdCtrl_KeyCmdType_tour;
const int Packet_Ctrl_KeyCmdCtrl_KeyCmdType_KeyCmdType_ARRAYSIZE = Packet_Ctrl_KeyCmdCtrl_KeyCmdType_KeyCmdType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Packet_Ctrl_KeyCmdCtrl_KeyCmdType_descriptor();
inline const ::std::string& Packet_Ctrl_KeyCmdCtrl_KeyCmdType_Name(Packet_Ctrl_KeyCmdCtrl_KeyCmdType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Packet_Ctrl_KeyCmdCtrl_KeyCmdType_descriptor(), value);
}
inline bool Packet_Ctrl_KeyCmdCtrl_KeyCmdType_Parse(
    const ::std::string& name, Packet_Ctrl_KeyCmdCtrl_KeyCmdType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Packet_Ctrl_KeyCmdCtrl_KeyCmdType>(
    Packet_Ctrl_KeyCmdCtrl_KeyCmdType_descriptor(), name, value);
}
enum Packet_Ctrl_KeyCmdCtrl_KeyType {
  Packet_Ctrl_KeyCmdCtrl_KeyType_KeyPress = 0,
  Packet_Ctrl_KeyCmdCtrl_KeyType_KeyRelease = 1
};
bool Packet_Ctrl_KeyCmdCtrl_KeyType_IsValid(int value);
const Packet_Ctrl_KeyCmdCtrl_KeyType Packet_Ctrl_KeyCmdCtrl_KeyType_KeyType_MIN = Packet_Ctrl_KeyCmdCtrl_KeyType_KeyPress;
const Packet_Ctrl_KeyCmdCtrl_KeyType Packet_Ctrl_KeyCmdCtrl_KeyType_KeyType_MAX = Packet_Ctrl_KeyCmdCtrl_KeyType_KeyRelease;
const int Packet_Ctrl_KeyCmdCtrl_KeyType_KeyType_ARRAYSIZE = Packet_Ctrl_KeyCmdCtrl_KeyType_KeyType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Packet_Ctrl_KeyCmdCtrl_KeyType_descriptor();
inline const ::std::string& Packet_Ctrl_KeyCmdCtrl_KeyType_Name(Packet_Ctrl_KeyCmdCtrl_KeyType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Packet_Ctrl_KeyCmdCtrl_KeyType_descriptor(), value);
}
inline bool Packet_Ctrl_KeyCmdCtrl_KeyType_Parse(
    const ::std::string& name, Packet_Ctrl_KeyCmdCtrl_KeyType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Packet_Ctrl_KeyCmdCtrl_KeyType>(
    Packet_Ctrl_KeyCmdCtrl_KeyType_descriptor(), name, value);
}
enum Packet_Ctrl_SyncClockCtrl_SyncType {
  Packet_Ctrl_SyncClockCtrl_SyncType_SyncClock = 0,
  Packet_Ctrl_SyncClockCtrl_SyncType_SyncFirstCam = 1
};
bool Packet_Ctrl_SyncClockCtrl_SyncType_IsValid(int value);
const Packet_Ctrl_SyncClockCtrl_SyncType Packet_Ctrl_SyncClockCtrl_SyncType_SyncType_MIN = Packet_Ctrl_SyncClockCtrl_SyncType_SyncClock;
const Packet_Ctrl_SyncClockCtrl_SyncType Packet_Ctrl_SyncClockCtrl_SyncType_SyncType_MAX = Packet_Ctrl_SyncClockCtrl_SyncType_SyncFirstCam;
const int Packet_Ctrl_SyncClockCtrl_SyncType_SyncType_ARRAYSIZE = Packet_Ctrl_SyncClockCtrl_SyncType_SyncType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Packet_Ctrl_SyncClockCtrl_SyncType_descriptor();
inline const ::std::string& Packet_Ctrl_SyncClockCtrl_SyncType_Name(Packet_Ctrl_SyncClockCtrl_SyncType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Packet_Ctrl_SyncClockCtrl_SyncType_descriptor(), value);
}
inline bool Packet_Ctrl_SyncClockCtrl_SyncType_Parse(
    const ::std::string& name, Packet_Ctrl_SyncClockCtrl_SyncType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Packet_Ctrl_SyncClockCtrl_SyncType>(
    Packet_Ctrl_SyncClockCtrl_SyncType_descriptor(), name, value);
}
enum Packet_Ctrl_TextContextCtrl_TextContextType {
  Packet_Ctrl_TextContextCtrl_TextContextType_TextChanged = 0
};
bool Packet_Ctrl_TextContextCtrl_TextContextType_IsValid(int value);
const Packet_Ctrl_TextContextCtrl_TextContextType Packet_Ctrl_TextContextCtrl_TextContextType_TextContextType_MIN = Packet_Ctrl_TextContextCtrl_TextContextType_TextChanged;
const Packet_Ctrl_TextContextCtrl_TextContextType Packet_Ctrl_TextContextCtrl_TextContextType_TextContextType_MAX = Packet_Ctrl_TextContextCtrl_TextContextType_TextChanged;
const int Packet_Ctrl_TextContextCtrl_TextContextType_TextContextType_ARRAYSIZE = Packet_Ctrl_TextContextCtrl_TextContextType_TextContextType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Packet_Ctrl_TextContextCtrl_TextContextType_descriptor();
inline const ::std::string& Packet_Ctrl_TextContextCtrl_TextContextType_Name(Packet_Ctrl_TextContextCtrl_TextContextType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Packet_Ctrl_TextContextCtrl_TextContextType_descriptor(), value);
}
inline bool Packet_Ctrl_TextContextCtrl_TextContextType_Parse(
    const ::std::string& name, Packet_Ctrl_TextContextCtrl_TextContextType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Packet_Ctrl_TextContextCtrl_TextContextType>(
    Packet_Ctrl_TextContextCtrl_TextContextType_descriptor(), name, value);
}
enum Packet_Ctrl_GroupLoopCtrl_GroupLoopCtrlType {
  Packet_Ctrl_GroupLoopCtrl_GroupLoopCtrlType_ALL = 0,
  Packet_Ctrl_GroupLoopCtrl_GroupLoopCtrlType_FOCUS_AREA = 1,
  Packet_Ctrl_GroupLoopCtrl_GroupLoopCtrlType_RESET_VIEWS = 2,
  Packet_Ctrl_GroupLoopCtrl_GroupLoopCtrlType_LOOP_TIME = 4,
  Packet_Ctrl_GroupLoopCtrl_GroupLoopCtrlType_ACTIVED = 8
};
bool Packet_Ctrl_GroupLoopCtrl_GroupLoopCtrlType_IsValid(int value);
const Packet_Ctrl_GroupLoopCtrl_GroupLoopCtrlType Packet_Ctrl_GroupLoopCtrl_GroupLoopCtrlType_GroupLoopCtrlType_MIN = Packet_Ctrl_GroupLoopCtrl_GroupLoopCtrlType_ALL;
const Packet_Ctrl_GroupLoopCtrl_GroupLoopCtrlType Packet_Ctrl_GroupLoopCtrl_GroupLoopCtrlType_GroupLoopCtrlType_MAX = Packet_Ctrl_GroupLoopCtrl_GroupLoopCtrlType_ACTIVED;
const int Packet_Ctrl_GroupLoopCtrl_GroupLoopCtrlType_GroupLoopCtrlType_ARRAYSIZE = Packet_Ctrl_GroupLoopCtrl_GroupLoopCtrlType_GroupLoopCtrlType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Packet_Ctrl_GroupLoopCtrl_GroupLoopCtrlType_descriptor();
inline const ::std::string& Packet_Ctrl_GroupLoopCtrl_GroupLoopCtrlType_Name(Packet_Ctrl_GroupLoopCtrl_GroupLoopCtrlType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Packet_Ctrl_GroupLoopCtrl_GroupLoopCtrlType_descriptor(), value);
}
inline bool Packet_Ctrl_GroupLoopCtrl_GroupLoopCtrlType_Parse(
    const ::std::string& name, Packet_Ctrl_GroupLoopCtrl_GroupLoopCtrlType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Packet_Ctrl_GroupLoopCtrl_GroupLoopCtrlType>(
    Packet_Ctrl_GroupLoopCtrl_GroupLoopCtrlType_descriptor(), name, value);
}
enum Packet_RequireSession_LocalMovieSessionAck_MovieStat {
  Packet_RequireSession_LocalMovieSessionAck_MovieStat_STOP = 0,
  Packet_RequireSession_LocalMovieSessionAck_MovieStat_PLAY = 1,
  Packet_RequireSession_LocalMovieSessionAck_MovieStat_PAUSE = 2
};
bool Packet_RequireSession_LocalMovieSessionAck_MovieStat_IsValid(int value);
const Packet_RequireSession_LocalMovieSessionAck_MovieStat Packet_RequireSession_LocalMovieSessionAck_MovieStat_MovieStat_MIN = Packet_RequireSession_LocalMovieSessionAck_MovieStat_STOP;
const Packet_RequireSession_LocalMovieSessionAck_MovieStat Packet_RequireSession_LocalMovieSessionAck_MovieStat_MovieStat_MAX = Packet_RequireSession_LocalMovieSessionAck_MovieStat_PAUSE;
const int Packet_RequireSession_LocalMovieSessionAck_MovieStat_MovieStat_ARRAYSIZE = Packet_RequireSession_LocalMovieSessionAck_MovieStat_MovieStat_MAX + 1;

const ::google::protobuf::EnumDescriptor* Packet_RequireSession_LocalMovieSessionAck_MovieStat_descriptor();
inline const ::std::string& Packet_RequireSession_LocalMovieSessionAck_MovieStat_Name(Packet_RequireSession_LocalMovieSessionAck_MovieStat value) {
  return ::google::protobuf::internal::NameOfEnum(
    Packet_RequireSession_LocalMovieSessionAck_MovieStat_descriptor(), value);
}
inline bool Packet_RequireSession_LocalMovieSessionAck_MovieStat_Parse(
    const ::std::string& name, Packet_RequireSession_LocalMovieSessionAck_MovieStat* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Packet_RequireSession_LocalMovieSessionAck_MovieStat>(
    Packet_RequireSession_LocalMovieSessionAck_MovieStat_descriptor(), name, value);
}
enum Packet_RequireSession_RecordRequire_RecordRequireType {
  Packet_RequireSession_RecordRequire_RecordRequireType_CURRENT_TIME = 0
};
bool Packet_RequireSession_RecordRequire_RecordRequireType_IsValid(int value);
const Packet_RequireSession_RecordRequire_RecordRequireType Packet_RequireSession_RecordRequire_RecordRequireType_RecordRequireType_MIN = Packet_RequireSession_RecordRequire_RecordRequireType_CURRENT_TIME;
const Packet_RequireSession_RecordRequire_RecordRequireType Packet_RequireSession_RecordRequire_RecordRequireType_RecordRequireType_MAX = Packet_RequireSession_RecordRequire_RecordRequireType_CURRENT_TIME;
const int Packet_RequireSession_RecordRequire_RecordRequireType_RecordRequireType_ARRAYSIZE = Packet_RequireSession_RecordRequire_RecordRequireType_RecordRequireType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Packet_RequireSession_RecordRequire_RecordRequireType_descriptor();
inline const ::std::string& Packet_RequireSession_RecordRequire_RecordRequireType_Name(Packet_RequireSession_RecordRequire_RecordRequireType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Packet_RequireSession_RecordRequire_RecordRequireType_descriptor(), value);
}
inline bool Packet_RequireSession_RecordRequire_RecordRequireType_Parse(
    const ::std::string& name, Packet_RequireSession_RecordRequire_RecordRequireType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Packet_RequireSession_RecordRequire_RecordRequireType>(
    Packet_RequireSession_RecordRequire_RecordRequireType_descriptor(), name, value);
}
enum Packet_RequireSession_ClientRequireType {
  Packet_RequireSession_ClientRequireType_SCREEN = 1,
  Packet_RequireSession_ClientRequireType_VIEW = 2,
  Packet_RequireSession_ClientRequireType_CAMERA = 4,
  Packet_RequireSession_ClientRequireType_HOT_POINT = 8,
  Packet_RequireSession_ClientRequireType_FOCUS_POINT = 16,
  Packet_RequireSession_ClientRequireType_LOCAL_MOVIE = 32,
  Packet_RequireSession_ClientRequireType_FLASH = 64,
  Packet_RequireSession_ClientRequireType_LAYOUT = 128,
  Packet_RequireSession_ClientRequireType_RECORDINFO = 256,
  Packet_RequireSession_ClientRequireType_MAPINFO = 512,
  Packet_RequireSession_ClientRequireType_LAYOUTLOOP = 1024,
  Packet_RequireSession_ClientRequireType_NVR_LIST = 2048,
  Packet_RequireSession_ClientRequireType_FMP = 4096,
  Packet_RequireSession_ClientRequireType_ALL = 65535
};
bool Packet_RequireSession_ClientRequireType_IsValid(int value);
const Packet_RequireSession_ClientRequireType Packet_RequireSession_ClientRequireType_ClientRequireType_MIN = Packet_RequireSession_ClientRequireType_SCREEN;
const Packet_RequireSession_ClientRequireType Packet_RequireSession_ClientRequireType_ClientRequireType_MAX = Packet_RequireSession_ClientRequireType_ALL;
const int Packet_RequireSession_ClientRequireType_ClientRequireType_ARRAYSIZE = Packet_RequireSession_ClientRequireType_ClientRequireType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Packet_RequireSession_ClientRequireType_descriptor();
inline const ::std::string& Packet_RequireSession_ClientRequireType_Name(Packet_RequireSession_ClientRequireType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Packet_RequireSession_ClientRequireType_descriptor(), value);
}
inline bool Packet_RequireSession_ClientRequireType_Parse(
    const ::std::string& name, Packet_RequireSession_ClientRequireType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Packet_RequireSession_ClientRequireType>(
    Packet_RequireSession_ClientRequireType_descriptor(), name, value);
}
enum Packet_Notice_Stat_ViewStat_ViewGeomotryStat_ViewGeomotryStatType {
  Packet_Notice_Stat_ViewStat_ViewGeomotryStat_ViewGeomotryStatType_CREATE = 0,
  Packet_Notice_Stat_ViewStat_ViewGeomotryStat_ViewGeomotryStatType_WINDOW_CTRL = 1,
  Packet_Notice_Stat_ViewStat_ViewGeomotryStat_ViewGeomotryStatType_REMOVE = 2,
  Packet_Notice_Stat_ViewStat_ViewGeomotryStat_ViewGeomotryStatType_SET_BORDER_WIDTH = 3,
  Packet_Notice_Stat_ViewStat_ViewGeomotryStat_ViewGeomotryStatType_SHOW_TITLE = 4
};
bool Packet_Notice_Stat_ViewStat_ViewGeomotryStat_ViewGeomotryStatType_IsValid(int value);
const Packet_Notice_Stat_ViewStat_ViewGeomotryStat_ViewGeomotryStatType Packet_Notice_Stat_ViewStat_ViewGeomotryStat_ViewGeomotryStatType_ViewGeomotryStatType_MIN = Packet_Notice_Stat_ViewStat_ViewGeomotryStat_ViewGeomotryStatType_CREATE;
const Packet_Notice_Stat_ViewStat_ViewGeomotryStat_ViewGeomotryStatType Packet_Notice_Stat_ViewStat_ViewGeomotryStat_ViewGeomotryStatType_ViewGeomotryStatType_MAX = Packet_Notice_Stat_ViewStat_ViewGeomotryStat_ViewGeomotryStatType_SHOW_TITLE;
const int Packet_Notice_Stat_ViewStat_ViewGeomotryStat_ViewGeomotryStatType_ViewGeomotryStatType_ARRAYSIZE = Packet_Notice_Stat_ViewStat_ViewGeomotryStat_ViewGeomotryStatType_ViewGeomotryStatType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Packet_Notice_Stat_ViewStat_ViewGeomotryStat_ViewGeomotryStatType_descriptor();
inline const ::std::string& Packet_Notice_Stat_ViewStat_ViewGeomotryStat_ViewGeomotryStatType_Name(Packet_Notice_Stat_ViewStat_ViewGeomotryStat_ViewGeomotryStatType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Packet_Notice_Stat_ViewStat_ViewGeomotryStat_ViewGeomotryStatType_descriptor(), value);
}
inline bool Packet_Notice_Stat_ViewStat_ViewGeomotryStat_ViewGeomotryStatType_Parse(
    const ::std::string& name, Packet_Notice_Stat_ViewStat_ViewGeomotryStat_ViewGeomotryStatType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Packet_Notice_Stat_ViewStat_ViewGeomotryStat_ViewGeomotryStatType>(
    Packet_Notice_Stat_ViewStat_ViewGeomotryStat_ViewGeomotryStatType_descriptor(), name, value);
}
enum Packet_Notice_Stat_ViewStat_VideoStat_VideoStatType {
  Packet_Notice_Stat_ViewStat_VideoStat_VideoStatType_CAMERA_ADD = 0,
  Packet_Notice_Stat_ViewStat_VideoStat_VideoStatType_CAMERA_REMOVE = 1,
  Packet_Notice_Stat_ViewStat_VideoStat_VideoStatType_POLL_INTERVAL = 2,
  Packet_Notice_Stat_ViewStat_VideoStat_VideoStatType_KEEP_STRETCH = 3
};
bool Packet_Notice_Stat_ViewStat_VideoStat_VideoStatType_IsValid(int value);
const Packet_Notice_Stat_ViewStat_VideoStat_VideoStatType Packet_Notice_Stat_ViewStat_VideoStat_VideoStatType_VideoStatType_MIN = Packet_Notice_Stat_ViewStat_VideoStat_VideoStatType_CAMERA_ADD;
const Packet_Notice_Stat_ViewStat_VideoStat_VideoStatType Packet_Notice_Stat_ViewStat_VideoStat_VideoStatType_VideoStatType_MAX = Packet_Notice_Stat_ViewStat_VideoStat_VideoStatType_KEEP_STRETCH;
const int Packet_Notice_Stat_ViewStat_VideoStat_VideoStatType_VideoStatType_ARRAYSIZE = Packet_Notice_Stat_ViewStat_VideoStat_VideoStatType_VideoStatType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Packet_Notice_Stat_ViewStat_VideoStat_VideoStatType_descriptor();
inline const ::std::string& Packet_Notice_Stat_ViewStat_VideoStat_VideoStatType_Name(Packet_Notice_Stat_ViewStat_VideoStat_VideoStatType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Packet_Notice_Stat_ViewStat_VideoStat_VideoStatType_descriptor(), value);
}
inline bool Packet_Notice_Stat_ViewStat_VideoStat_VideoStatType_Parse(
    const ::std::string& name, Packet_Notice_Stat_ViewStat_VideoStat_VideoStatType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Packet_Notice_Stat_ViewStat_VideoStat_VideoStatType>(
    Packet_Notice_Stat_ViewStat_VideoStat_VideoStatType_descriptor(), name, value);
}
enum Packet_Notice_Stat_ViewStat_RecordStat_RecordStatType {
  Packet_Notice_Stat_ViewStat_RecordStat_RecordStatType_RESET_START_TIME = 0,
  Packet_Notice_Stat_ViewStat_RecordStat_RecordStatType_KEEP_STRETCH = 1,
  Packet_Notice_Stat_ViewStat_RecordStat_RecordStatType_SET_RATE = 2,
  Packet_Notice_Stat_ViewStat_RecordStat_RecordStatType_PAUSE = 3,
  Packet_Notice_Stat_ViewStat_RecordStat_RecordStatType_SLOW = 4,
  Packet_Notice_Stat_ViewStat_RecordStat_RecordStatType_FAST = 5,
  Packet_Notice_Stat_ViewStat_RecordStat_RecordStatType_BACK = 6,
  Packet_Notice_Stat_ViewStat_RecordStat_RecordStatType_FORWARD = 7
};
bool Packet_Notice_Stat_ViewStat_RecordStat_RecordStatType_IsValid(int value);
const Packet_Notice_Stat_ViewStat_RecordStat_RecordStatType Packet_Notice_Stat_ViewStat_RecordStat_RecordStatType_RecordStatType_MIN = Packet_Notice_Stat_ViewStat_RecordStat_RecordStatType_RESET_START_TIME;
const Packet_Notice_Stat_ViewStat_RecordStat_RecordStatType Packet_Notice_Stat_ViewStat_RecordStat_RecordStatType_RecordStatType_MAX = Packet_Notice_Stat_ViewStat_RecordStat_RecordStatType_FORWARD;
const int Packet_Notice_Stat_ViewStat_RecordStat_RecordStatType_RecordStatType_ARRAYSIZE = Packet_Notice_Stat_ViewStat_RecordStat_RecordStatType_RecordStatType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Packet_Notice_Stat_ViewStat_RecordStat_RecordStatType_descriptor();
inline const ::std::string& Packet_Notice_Stat_ViewStat_RecordStat_RecordStatType_Name(Packet_Notice_Stat_ViewStat_RecordStat_RecordStatType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Packet_Notice_Stat_ViewStat_RecordStat_RecordStatType_descriptor(), value);
}
inline bool Packet_Notice_Stat_ViewStat_RecordStat_RecordStatType_Parse(
    const ::std::string& name, Packet_Notice_Stat_ViewStat_RecordStat_RecordStatType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Packet_Notice_Stat_ViewStat_RecordStat_RecordStatType>(
    Packet_Notice_Stat_ViewStat_RecordStat_RecordStatType_descriptor(), name, value);
}
enum Packet_Notice_Stat_ViewStat_LocalMovieStat_LocalMovieType {
  Packet_Notice_Stat_ViewStat_LocalMovieStat_LocalMovieType_SET_FILE = 0,
  Packet_Notice_Stat_ViewStat_LocalMovieStat_LocalMovieType_SET_VOLUME = 1,
  Packet_Notice_Stat_ViewStat_LocalMovieStat_LocalMovieType_SET_SLIDER = 2,
  Packet_Notice_Stat_ViewStat_LocalMovieStat_LocalMovieType_PAUSE = 3,
  Packet_Notice_Stat_ViewStat_LocalMovieStat_LocalMovieType_STOP = 4
};
bool Packet_Notice_Stat_ViewStat_LocalMovieStat_LocalMovieType_IsValid(int value);
const Packet_Notice_Stat_ViewStat_LocalMovieStat_LocalMovieType Packet_Notice_Stat_ViewStat_LocalMovieStat_LocalMovieType_LocalMovieType_MIN = Packet_Notice_Stat_ViewStat_LocalMovieStat_LocalMovieType_SET_FILE;
const Packet_Notice_Stat_ViewStat_LocalMovieStat_LocalMovieType Packet_Notice_Stat_ViewStat_LocalMovieStat_LocalMovieType_LocalMovieType_MAX = Packet_Notice_Stat_ViewStat_LocalMovieStat_LocalMovieType_STOP;
const int Packet_Notice_Stat_ViewStat_LocalMovieStat_LocalMovieType_LocalMovieType_ARRAYSIZE = Packet_Notice_Stat_ViewStat_LocalMovieStat_LocalMovieType_LocalMovieType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Packet_Notice_Stat_ViewStat_LocalMovieStat_LocalMovieType_descriptor();
inline const ::std::string& Packet_Notice_Stat_ViewStat_LocalMovieStat_LocalMovieType_Name(Packet_Notice_Stat_ViewStat_LocalMovieStat_LocalMovieType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Packet_Notice_Stat_ViewStat_LocalMovieStat_LocalMovieType_descriptor(), value);
}
inline bool Packet_Notice_Stat_ViewStat_LocalMovieStat_LocalMovieType_Parse(
    const ::std::string& name, Packet_Notice_Stat_ViewStat_LocalMovieStat_LocalMovieType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Packet_Notice_Stat_ViewStat_LocalMovieStat_LocalMovieType>(
    Packet_Notice_Stat_ViewStat_LocalMovieStat_LocalMovieType_descriptor(), name, value);
}
enum Packet_Notice_Stat_ViewStat_FlashStat_FlashStatType {
  Packet_Notice_Stat_ViewStat_FlashStat_FlashStatType_SET_FLASH = 0
};
bool Packet_Notice_Stat_ViewStat_FlashStat_FlashStatType_IsValid(int value);
const Packet_Notice_Stat_ViewStat_FlashStat_FlashStatType Packet_Notice_Stat_ViewStat_FlashStat_FlashStatType_FlashStatType_MIN = Packet_Notice_Stat_ViewStat_FlashStat_FlashStatType_SET_FLASH;
const Packet_Notice_Stat_ViewStat_FlashStat_FlashStatType Packet_Notice_Stat_ViewStat_FlashStat_FlashStatType_FlashStatType_MAX = Packet_Notice_Stat_ViewStat_FlashStat_FlashStatType_SET_FLASH;
const int Packet_Notice_Stat_ViewStat_FlashStat_FlashStatType_FlashStatType_ARRAYSIZE = Packet_Notice_Stat_ViewStat_FlashStat_FlashStatType_FlashStatType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Packet_Notice_Stat_ViewStat_FlashStat_FlashStatType_descriptor();
inline const ::std::string& Packet_Notice_Stat_ViewStat_FlashStat_FlashStatType_Name(Packet_Notice_Stat_ViewStat_FlashStat_FlashStatType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Packet_Notice_Stat_ViewStat_FlashStat_FlashStatType_descriptor(), value);
}
inline bool Packet_Notice_Stat_ViewStat_FlashStat_FlashStatType_Parse(
    const ::std::string& name, Packet_Notice_Stat_ViewStat_FlashStat_FlashStatType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Packet_Notice_Stat_ViewStat_FlashStat_FlashStatType>(
    Packet_Notice_Stat_ViewStat_FlashStat_FlashStatType_descriptor(), name, value);
}
enum Packet_Notice_Stat_ViewStat_HTMLStat_HTMLStatType {
  Packet_Notice_Stat_ViewStat_HTMLStat_HTMLStatType_SET_HTML = 0
};
bool Packet_Notice_Stat_ViewStat_HTMLStat_HTMLStatType_IsValid(int value);
const Packet_Notice_Stat_ViewStat_HTMLStat_HTMLStatType Packet_Notice_Stat_ViewStat_HTMLStat_HTMLStatType_HTMLStatType_MIN = Packet_Notice_Stat_ViewStat_HTMLStat_HTMLStatType_SET_HTML;
const Packet_Notice_Stat_ViewStat_HTMLStat_HTMLStatType Packet_Notice_Stat_ViewStat_HTMLStat_HTMLStatType_HTMLStatType_MAX = Packet_Notice_Stat_ViewStat_HTMLStat_HTMLStatType_SET_HTML;
const int Packet_Notice_Stat_ViewStat_HTMLStat_HTMLStatType_HTMLStatType_ARRAYSIZE = Packet_Notice_Stat_ViewStat_HTMLStat_HTMLStatType_HTMLStatType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Packet_Notice_Stat_ViewStat_HTMLStat_HTMLStatType_descriptor();
inline const ::std::string& Packet_Notice_Stat_ViewStat_HTMLStat_HTMLStatType_Name(Packet_Notice_Stat_ViewStat_HTMLStat_HTMLStatType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Packet_Notice_Stat_ViewStat_HTMLStat_HTMLStatType_descriptor(), value);
}
inline bool Packet_Notice_Stat_ViewStat_HTMLStat_HTMLStatType_Parse(
    const ::std::string& name, Packet_Notice_Stat_ViewStat_HTMLStat_HTMLStatType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Packet_Notice_Stat_ViewStat_HTMLStat_HTMLStatType>(
    Packet_Notice_Stat_ViewStat_HTMLStat_HTMLStatType_descriptor(), name, value);
}
enum Packet_Notice_Stat_ViewStat_TextStat_TextStatType {
  Packet_Notice_Stat_ViewStat_TextStat_TextStatType_SET_TEXT = 0
};
bool Packet_Notice_Stat_ViewStat_TextStat_TextStatType_IsValid(int value);
const Packet_Notice_Stat_ViewStat_TextStat_TextStatType Packet_Notice_Stat_ViewStat_TextStat_TextStatType_TextStatType_MIN = Packet_Notice_Stat_ViewStat_TextStat_TextStatType_SET_TEXT;
const Packet_Notice_Stat_ViewStat_TextStat_TextStatType Packet_Notice_Stat_ViewStat_TextStat_TextStatType_TextStatType_MAX = Packet_Notice_Stat_ViewStat_TextStat_TextStatType_SET_TEXT;
const int Packet_Notice_Stat_ViewStat_TextStat_TextStatType_TextStatType_ARRAYSIZE = Packet_Notice_Stat_ViewStat_TextStat_TextStatType_TextStatType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Packet_Notice_Stat_ViewStat_TextStat_TextStatType_descriptor();
inline const ::std::string& Packet_Notice_Stat_ViewStat_TextStat_TextStatType_Name(Packet_Notice_Stat_ViewStat_TextStat_TextStatType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Packet_Notice_Stat_ViewStat_TextStat_TextStatType_descriptor(), value);
}
inline bool Packet_Notice_Stat_ViewStat_TextStat_TextStatType_Parse(
    const ::std::string& name, Packet_Notice_Stat_ViewStat_TextStat_TextStatType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Packet_Notice_Stat_ViewStat_TextStat_TextStatType>(
    Packet_Notice_Stat_ViewStat_TextStat_TextStatType_descriptor(), name, value);
}
enum Packet_Notice_Stat_ViewStat_MapStat_MapCtrlType {
  Packet_Notice_Stat_ViewStat_MapStat_MapCtrlType_SET_MAP = 0
};
bool Packet_Notice_Stat_ViewStat_MapStat_MapCtrlType_IsValid(int value);
const Packet_Notice_Stat_ViewStat_MapStat_MapCtrlType Packet_Notice_Stat_ViewStat_MapStat_MapCtrlType_MapCtrlType_MIN = Packet_Notice_Stat_ViewStat_MapStat_MapCtrlType_SET_MAP;
const Packet_Notice_Stat_ViewStat_MapStat_MapCtrlType Packet_Notice_Stat_ViewStat_MapStat_MapCtrlType_MapCtrlType_MAX = Packet_Notice_Stat_ViewStat_MapStat_MapCtrlType_SET_MAP;
const int Packet_Notice_Stat_ViewStat_MapStat_MapCtrlType_MapCtrlType_ARRAYSIZE = Packet_Notice_Stat_ViewStat_MapStat_MapCtrlType_MapCtrlType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Packet_Notice_Stat_ViewStat_MapStat_MapCtrlType_descriptor();
inline const ::std::string& Packet_Notice_Stat_ViewStat_MapStat_MapCtrlType_Name(Packet_Notice_Stat_ViewStat_MapStat_MapCtrlType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Packet_Notice_Stat_ViewStat_MapStat_MapCtrlType_descriptor(), value);
}
inline bool Packet_Notice_Stat_ViewStat_MapStat_MapCtrlType_Parse(
    const ::std::string& name, Packet_Notice_Stat_ViewStat_MapStat_MapCtrlType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Packet_Notice_Stat_ViewStat_MapStat_MapCtrlType>(
    Packet_Notice_Stat_ViewStat_MapStat_MapCtrlType_descriptor(), name, value);
}
enum Packet_Notice_Stat_ViewStat_OthersStat_OthersStatType {
  Packet_Notice_Stat_ViewStat_OthersStat_OthersStatType_OTHER_ADD = 0,
  Packet_Notice_Stat_ViewStat_OthersStat_OthersStatType_SERVER_NAME = 1
};
bool Packet_Notice_Stat_ViewStat_OthersStat_OthersStatType_IsValid(int value);
const Packet_Notice_Stat_ViewStat_OthersStat_OthersStatType Packet_Notice_Stat_ViewStat_OthersStat_OthersStatType_OthersStatType_MIN = Packet_Notice_Stat_ViewStat_OthersStat_OthersStatType_OTHER_ADD;
const Packet_Notice_Stat_ViewStat_OthersStat_OthersStatType Packet_Notice_Stat_ViewStat_OthersStat_OthersStatType_OthersStatType_MAX = Packet_Notice_Stat_ViewStat_OthersStat_OthersStatType_SERVER_NAME;
const int Packet_Notice_Stat_ViewStat_OthersStat_OthersStatType_OthersStatType_ARRAYSIZE = Packet_Notice_Stat_ViewStat_OthersStat_OthersStatType_OthersStatType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Packet_Notice_Stat_ViewStat_OthersStat_OthersStatType_descriptor();
inline const ::std::string& Packet_Notice_Stat_ViewStat_OthersStat_OthersStatType_Name(Packet_Notice_Stat_ViewStat_OthersStat_OthersStatType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Packet_Notice_Stat_ViewStat_OthersStat_OthersStatType_descriptor(), value);
}
inline bool Packet_Notice_Stat_ViewStat_OthersStat_OthersStatType_Parse(
    const ::std::string& name, Packet_Notice_Stat_ViewStat_OthersStat_OthersStatType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Packet_Notice_Stat_ViewStat_OthersStat_OthersStatType>(
    Packet_Notice_Stat_ViewStat_OthersStat_OthersStatType_descriptor(), name, value);
}
enum Packet_Notice_Stat_CameraStat_PTZ_TYPE {
  Packet_Notice_Stat_CameraStat_PTZ_TYPE_LEFT = 0,
  Packet_Notice_Stat_CameraStat_PTZ_TYPE_RIGHT = 1,
  Packet_Notice_Stat_CameraStat_PTZ_TYPE_UP = 2,
  Packet_Notice_Stat_CameraStat_PTZ_TYPE_DOWN = 3,
  Packet_Notice_Stat_CameraStat_PTZ_TYPE_ADD_CAMERA = 4,
  Packet_Notice_Stat_CameraStat_PTZ_TYPE_REMOVE_CAMERA = 5,
  Packet_Notice_Stat_CameraStat_PTZ_TYPE_NETSTAT = 6,
  Packet_Notice_Stat_CameraStat_PTZ_TYPE_PLAYING_STAT = 7,
  Packet_Notice_Stat_CameraStat_PTZ_TYPE_PLAYBACK_STAT = 8,
  Packet_Notice_Stat_CameraStat_PTZ_TYPE_UPDATE = 9,
  Packet_Notice_Stat_CameraStat_PTZ_TYPE_ADD = 10,
  Packet_Notice_Stat_CameraStat_PTZ_TYPE_REMOVE = 11,
  Packet_Notice_Stat_CameraStat_PTZ_TYPE_ADD_GRP = 12,
  Packet_Notice_Stat_CameraStat_PTZ_TYPE_REMOVE_GRP = 13,
  Packet_Notice_Stat_CameraStat_PTZ_TYPE_UPDATE_GRP = 14
};
bool Packet_Notice_Stat_CameraStat_PTZ_TYPE_IsValid(int value);
const Packet_Notice_Stat_CameraStat_PTZ_TYPE Packet_Notice_Stat_CameraStat_PTZ_TYPE_PTZ_TYPE_MIN = Packet_Notice_Stat_CameraStat_PTZ_TYPE_LEFT;
const Packet_Notice_Stat_CameraStat_PTZ_TYPE Packet_Notice_Stat_CameraStat_PTZ_TYPE_PTZ_TYPE_MAX = Packet_Notice_Stat_CameraStat_PTZ_TYPE_UPDATE_GRP;
const int Packet_Notice_Stat_CameraStat_PTZ_TYPE_PTZ_TYPE_ARRAYSIZE = Packet_Notice_Stat_CameraStat_PTZ_TYPE_PTZ_TYPE_MAX + 1;

const ::google::protobuf::EnumDescriptor* Packet_Notice_Stat_CameraStat_PTZ_TYPE_descriptor();
inline const ::std::string& Packet_Notice_Stat_CameraStat_PTZ_TYPE_Name(Packet_Notice_Stat_CameraStat_PTZ_TYPE value) {
  return ::google::protobuf::internal::NameOfEnum(
    Packet_Notice_Stat_CameraStat_PTZ_TYPE_descriptor(), value);
}
inline bool Packet_Notice_Stat_CameraStat_PTZ_TYPE_Parse(
    const ::std::string& name, Packet_Notice_Stat_CameraStat_PTZ_TYPE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Packet_Notice_Stat_CameraStat_PTZ_TYPE>(
    Packet_Notice_Stat_CameraStat_PTZ_TYPE_descriptor(), name, value);
}
enum Packet_Notice_Stat_HotPointStat_HotPointStatType {
  Packet_Notice_Stat_HotPointStat_HotPointStatType_CREATE = 0,
  Packet_Notice_Stat_HotPointStat_HotPointStatType_REMOVE = 1,
  Packet_Notice_Stat_HotPointStat_HotPointStatType_RESET = 2,
  Packet_Notice_Stat_HotPointStat_HotPointStatType_RESET_SCREEN = 3
};
bool Packet_Notice_Stat_HotPointStat_HotPointStatType_IsValid(int value);
const Packet_Notice_Stat_HotPointStat_HotPointStatType Packet_Notice_Stat_HotPointStat_HotPointStatType_HotPointStatType_MIN = Packet_Notice_Stat_HotPointStat_HotPointStatType_CREATE;
const Packet_Notice_Stat_HotPointStat_HotPointStatType Packet_Notice_Stat_HotPointStat_HotPointStatType_HotPointStatType_MAX = Packet_Notice_Stat_HotPointStat_HotPointStatType_RESET_SCREEN;
const int Packet_Notice_Stat_HotPointStat_HotPointStatType_HotPointStatType_ARRAYSIZE = Packet_Notice_Stat_HotPointStat_HotPointStatType_HotPointStatType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Packet_Notice_Stat_HotPointStat_HotPointStatType_descriptor();
inline const ::std::string& Packet_Notice_Stat_HotPointStat_HotPointStatType_Name(Packet_Notice_Stat_HotPointStat_HotPointStatType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Packet_Notice_Stat_HotPointStat_HotPointStatType_descriptor(), value);
}
inline bool Packet_Notice_Stat_HotPointStat_HotPointStatType_Parse(
    const ::std::string& name, Packet_Notice_Stat_HotPointStat_HotPointStatType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Packet_Notice_Stat_HotPointStat_HotPointStatType>(
    Packet_Notice_Stat_HotPointStat_HotPointStatType_descriptor(), name, value);
}
enum Packet_Notice_Stat_LayoutStat_LayoutStatType {
  Packet_Notice_Stat_LayoutStat_LayoutStatType_ADD = 0,
  Packet_Notice_Stat_LayoutStat_LayoutStatType_REMOVE = 1,
  Packet_Notice_Stat_LayoutStat_LayoutStatType_USE = 2
};
bool Packet_Notice_Stat_LayoutStat_LayoutStatType_IsValid(int value);
const Packet_Notice_Stat_LayoutStat_LayoutStatType Packet_Notice_Stat_LayoutStat_LayoutStatType_LayoutStatType_MIN = Packet_Notice_Stat_LayoutStat_LayoutStatType_ADD;
const Packet_Notice_Stat_LayoutStat_LayoutStatType Packet_Notice_Stat_LayoutStat_LayoutStatType_LayoutStatType_MAX = Packet_Notice_Stat_LayoutStat_LayoutStatType_USE;
const int Packet_Notice_Stat_LayoutStat_LayoutStatType_LayoutStatType_ARRAYSIZE = Packet_Notice_Stat_LayoutStat_LayoutStatType_LayoutStatType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Packet_Notice_Stat_LayoutStat_LayoutStatType_descriptor();
inline const ::std::string& Packet_Notice_Stat_LayoutStat_LayoutStatType_Name(Packet_Notice_Stat_LayoutStat_LayoutStatType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Packet_Notice_Stat_LayoutStat_LayoutStatType_descriptor(), value);
}
inline bool Packet_Notice_Stat_LayoutStat_LayoutStatType_Parse(
    const ::std::string& name, Packet_Notice_Stat_LayoutStat_LayoutStatType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Packet_Notice_Stat_LayoutStat_LayoutStatType>(
    Packet_Notice_Stat_LayoutStat_LayoutStatType_descriptor(), name, value);
}
enum Packet_Notice_Stat_LayoutLoopStat_LayoutLoopStatType {
  Packet_Notice_Stat_LayoutLoopStat_LayoutLoopStatType_ADD = 0,
  Packet_Notice_Stat_LayoutLoopStat_LayoutLoopStatType_REMOVE = 1,
  Packet_Notice_Stat_LayoutLoopStat_LayoutLoopStatType_ADD_LAYOUT = 2,
  Packet_Notice_Stat_LayoutLoopStat_LayoutLoopStatType_USE = 3,
  Packet_Notice_Stat_LayoutLoopStat_LayoutLoopStatType_SET_LOOP = 4,
  Packet_Notice_Stat_LayoutLoopStat_LayoutLoopStatType_STOP = 5
};
bool Packet_Notice_Stat_LayoutLoopStat_LayoutLoopStatType_IsValid(int value);
const Packet_Notice_Stat_LayoutLoopStat_LayoutLoopStatType Packet_Notice_Stat_LayoutLoopStat_LayoutLoopStatType_LayoutLoopStatType_MIN = Packet_Notice_Stat_LayoutLoopStat_LayoutLoopStatType_ADD;
const Packet_Notice_Stat_LayoutLoopStat_LayoutLoopStatType Packet_Notice_Stat_LayoutLoopStat_LayoutLoopStatType_LayoutLoopStatType_MAX = Packet_Notice_Stat_LayoutLoopStat_LayoutLoopStatType_STOP;
const int Packet_Notice_Stat_LayoutLoopStat_LayoutLoopStatType_LayoutLoopStatType_ARRAYSIZE = Packet_Notice_Stat_LayoutLoopStat_LayoutLoopStatType_LayoutLoopStatType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Packet_Notice_Stat_LayoutLoopStat_LayoutLoopStatType_descriptor();
inline const ::std::string& Packet_Notice_Stat_LayoutLoopStat_LayoutLoopStatType_Name(Packet_Notice_Stat_LayoutLoopStat_LayoutLoopStatType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Packet_Notice_Stat_LayoutLoopStat_LayoutLoopStatType_descriptor(), value);
}
inline bool Packet_Notice_Stat_LayoutLoopStat_LayoutLoopStatType_Parse(
    const ::std::string& name, Packet_Notice_Stat_LayoutLoopStat_LayoutLoopStatType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Packet_Notice_Stat_LayoutLoopStat_LayoutLoopStatType>(
    Packet_Notice_Stat_LayoutLoopStat_LayoutLoopStatType_descriptor(), name, value);
}
enum Packet_Notice_Stat_MapGrpStat_MapGrpStatType {
  Packet_Notice_Stat_MapGrpStat_MapGrpStatType_RESET = 0
};
bool Packet_Notice_Stat_MapGrpStat_MapGrpStatType_IsValid(int value);
const Packet_Notice_Stat_MapGrpStat_MapGrpStatType Packet_Notice_Stat_MapGrpStat_MapGrpStatType_MapGrpStatType_MIN = Packet_Notice_Stat_MapGrpStat_MapGrpStatType_RESET;
const Packet_Notice_Stat_MapGrpStat_MapGrpStatType Packet_Notice_Stat_MapGrpStat_MapGrpStatType_MapGrpStatType_MAX = Packet_Notice_Stat_MapGrpStat_MapGrpStatType_RESET;
const int Packet_Notice_Stat_MapGrpStat_MapGrpStatType_MapGrpStatType_ARRAYSIZE = Packet_Notice_Stat_MapGrpStat_MapGrpStatType_MapGrpStatType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Packet_Notice_Stat_MapGrpStat_MapGrpStatType_descriptor();
inline const ::std::string& Packet_Notice_Stat_MapGrpStat_MapGrpStatType_Name(Packet_Notice_Stat_MapGrpStat_MapGrpStatType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Packet_Notice_Stat_MapGrpStat_MapGrpStatType_descriptor(), value);
}
inline bool Packet_Notice_Stat_MapGrpStat_MapGrpStatType_Parse(
    const ::std::string& name, Packet_Notice_Stat_MapGrpStat_MapGrpStatType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Packet_Notice_Stat_MapGrpStat_MapGrpStatType>(
    Packet_Notice_Stat_MapGrpStat_MapGrpStatType_descriptor(), name, value);
}
enum Packet_Notice_Stat_GroupLoopStat_GroupLoopStatType {
  Packet_Notice_Stat_GroupLoopStat_GroupLoopStatType_ALL = 0,
  Packet_Notice_Stat_GroupLoopStat_GroupLoopStatType_FOCUS_AREA = 1,
  Packet_Notice_Stat_GroupLoopStat_GroupLoopStatType_RESET_VIEWS = 2,
  Packet_Notice_Stat_GroupLoopStat_GroupLoopStatType_LOOP_TIME = 4,
  Packet_Notice_Stat_GroupLoopStat_GroupLoopStatType_ACTIVED = 8
};
bool Packet_Notice_Stat_GroupLoopStat_GroupLoopStatType_IsValid(int value);
const Packet_Notice_Stat_GroupLoopStat_GroupLoopStatType Packet_Notice_Stat_GroupLoopStat_GroupLoopStatType_GroupLoopStatType_MIN = Packet_Notice_Stat_GroupLoopStat_GroupLoopStatType_ALL;
const Packet_Notice_Stat_GroupLoopStat_GroupLoopStatType Packet_Notice_Stat_GroupLoopStat_GroupLoopStatType_GroupLoopStatType_MAX = Packet_Notice_Stat_GroupLoopStat_GroupLoopStatType_ACTIVED;
const int Packet_Notice_Stat_GroupLoopStat_GroupLoopStatType_GroupLoopStatType_ARRAYSIZE = Packet_Notice_Stat_GroupLoopStat_GroupLoopStatType_GroupLoopStatType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Packet_Notice_Stat_GroupLoopStat_GroupLoopStatType_descriptor();
inline const ::std::string& Packet_Notice_Stat_GroupLoopStat_GroupLoopStatType_Name(Packet_Notice_Stat_GroupLoopStat_GroupLoopStatType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Packet_Notice_Stat_GroupLoopStat_GroupLoopStatType_descriptor(), value);
}
inline bool Packet_Notice_Stat_GroupLoopStat_GroupLoopStatType_Parse(
    const ::std::string& name, Packet_Notice_Stat_GroupLoopStat_GroupLoopStatType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Packet_Notice_Stat_GroupLoopStat_GroupLoopStatType>(
    Packet_Notice_Stat_GroupLoopStat_GroupLoopStatType_descriptor(), name, value);
}
// ===================================================================

class Rect : public ::google::protobuf::Message {
 public:
  Rect();
  virtual ~Rect();

  Rect(const Rect& from);

  inline Rect& operator=(const Rect& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Rect& default_instance();

  void Swap(Rect* other);

  // implements Message ----------------------------------------------

  Rect* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Rect& from);
  void MergeFrom(const Rect& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 x = 1;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 1;
  inline ::google::protobuf::int32 x() const;
  inline void set_x(::google::protobuf::int32 value);

  // required int32 y = 2;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 2;
  inline ::google::protobuf::int32 y() const;
  inline void set_y(::google::protobuf::int32 value);

  // required int32 w = 3;
  inline bool has_w() const;
  inline void clear_w();
  static const int kWFieldNumber = 3;
  inline ::google::protobuf::int32 w() const;
  inline void set_w(::google::protobuf::int32 value);

  // required int32 h = 4;
  inline bool has_h() const;
  inline void clear_h();
  static const int kHFieldNumber = 4;
  inline ::google::protobuf::int32 h() const;
  inline void set_h(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:TvWall.Rect)
 private:
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();
  inline void set_has_w();
  inline void clear_has_w();
  inline void set_has_h();
  inline void clear_has_h();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 x_;
  ::google::protobuf::int32 y_;
  ::google::protobuf::int32 w_;
  ::google::protobuf::int32 h_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_protobuf_2ftvWall_2eproto();
  friend void protobuf_AssignDesc_protobuf_2ftvWall_2eproto();
  friend void protobuf_ShutdownFile_protobuf_2ftvWall_2eproto();

  void InitAsDefaultInstance();
  static Rect* default_instance_;
};
// -------------------------------------------------------------------

class Point : public ::google::protobuf::Message {
 public:
  Point();
  virtual ~Point();

  Point(const Point& from);

  inline Point& operator=(const Point& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Point& default_instance();

  void Swap(Point* other);

  // implements Message ----------------------------------------------

  Point* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Point& from);
  void MergeFrom(const Point& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 x = 1;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 1;
  inline ::google::protobuf::int32 x() const;
  inline void set_x(::google::protobuf::int32 value);

  // required int32 y = 2;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 2;
  inline ::google::protobuf::int32 y() const;
  inline void set_y(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:TvWall.Point)
 private:
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 x_;
  ::google::protobuf::int32 y_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_protobuf_2ftvWall_2eproto();
  friend void protobuf_AssignDesc_protobuf_2ftvWall_2eproto();
  friend void protobuf_ShutdownFile_protobuf_2ftvWall_2eproto();

  void InitAsDefaultInstance();
  static Point* default_instance_;
};
// -------------------------------------------------------------------

class Guid : public ::google::protobuf::Message {
 public:
  Guid();
  virtual ~Guid();

  Guid(const Guid& from);

  inline Guid& operator=(const Guid& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Guid& default_instance();

  void Swap(Guid* other);

  // implements Message ----------------------------------------------

  Guid* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Guid& from);
  void MergeFrom(const Guid& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes data = 1;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 1;
  inline const ::std::string& data() const;
  inline void set_data(const ::std::string& value);
  inline void set_data(const char* value);
  inline void set_data(const void* value, size_t size);
  inline ::std::string* mutable_data();
  inline ::std::string* release_data();
  inline void set_allocated_data(::std::string* data);

  // @@protoc_insertion_point(class_scope:TvWall.Guid)
 private:
  inline void set_has_data();
  inline void clear_has_data();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* data_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_protobuf_2ftvWall_2eproto();
  friend void protobuf_AssignDesc_protobuf_2ftvWall_2eproto();
  friend void protobuf_ShutdownFile_protobuf_2ftvWall_2eproto();

  void InitAsDefaultInstance();
  static Guid* default_instance_;
};
// -------------------------------------------------------------------

class NetInterface : public ::google::protobuf::Message {
 public:
  NetInterface();
  virtual ~NetInterface();

  NetInterface(const NetInterface& from);

  inline NetInterface& operator=(const NetInterface& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NetInterface& default_instance();

  void Swap(NetInterface* other);

  // implements Message ----------------------------------------------

  NetInterface* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NetInterface& from);
  void MergeFrom(const NetInterface& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string ifname = 1;
  inline bool has_ifname() const;
  inline void clear_ifname();
  static const int kIfnameFieldNumber = 1;
  inline const ::std::string& ifname() const;
  inline void set_ifname(const ::std::string& value);
  inline void set_ifname(const char* value);
  inline void set_ifname(const char* value, size_t size);
  inline ::std::string* mutable_ifname();
  inline ::std::string* release_ifname();
  inline void set_allocated_ifname(::std::string* ifname);

  // required string ip = 2;
  inline bool has_ip() const;
  inline void clear_ip();
  static const int kIpFieldNumber = 2;
  inline const ::std::string& ip() const;
  inline void set_ip(const ::std::string& value);
  inline void set_ip(const char* value);
  inline void set_ip(const char* value, size_t size);
  inline ::std::string* mutable_ip();
  inline ::std::string* release_ip();
  inline void set_allocated_ip(::std::string* ip);

  // required string netmask = 3;
  inline bool has_netmask() const;
  inline void clear_netmask();
  static const int kNetmaskFieldNumber = 3;
  inline const ::std::string& netmask() const;
  inline void set_netmask(const ::std::string& value);
  inline void set_netmask(const char* value);
  inline void set_netmask(const char* value, size_t size);
  inline ::std::string* mutable_netmask();
  inline ::std::string* release_netmask();
  inline void set_allocated_netmask(::std::string* netmask);

  // optional bool enabled = 4;
  inline bool has_enabled() const;
  inline void clear_enabled();
  static const int kEnabledFieldNumber = 4;
  inline bool enabled() const;
  inline void set_enabled(bool value);

  // optional bool plug = 5;
  inline bool has_plug() const;
  inline void clear_plug();
  static const int kPlugFieldNumber = 5;
  inline bool plug() const;
  inline void set_plug(bool value);

  // optional int32 speed = 6 [default = 1000];
  inline bool has_speed() const;
  inline void clear_speed();
  static const int kSpeedFieldNumber = 6;
  inline ::google::protobuf::int32 speed() const;
  inline void set_speed(::google::protobuf::int32 value);

  // optional bool dhcp = 7 [default = false];
  inline bool has_dhcp() const;
  inline void clear_dhcp();
  static const int kDhcpFieldNumber = 7;
  inline bool dhcp() const;
  inline void set_dhcp(bool value);

  // @@protoc_insertion_point(class_scope:TvWall.NetInterface)
 private:
  inline void set_has_ifname();
  inline void clear_has_ifname();
  inline void set_has_ip();
  inline void clear_has_ip();
  inline void set_has_netmask();
  inline void clear_has_netmask();
  inline void set_has_enabled();
  inline void clear_has_enabled();
  inline void set_has_plug();
  inline void clear_has_plug();
  inline void set_has_speed();
  inline void clear_has_speed();
  inline void set_has_dhcp();
  inline void clear_has_dhcp();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* ifname_;
  ::std::string* ip_;
  ::std::string* netmask_;
  bool enabled_;
  bool plug_;
  bool dhcp_;
  ::google::protobuf::int32 speed_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_protobuf_2ftvWall_2eproto();
  friend void protobuf_AssignDesc_protobuf_2ftvWall_2eproto();
  friend void protobuf_ShutdownFile_protobuf_2ftvWall_2eproto();

  void InitAsDefaultInstance();
  static NetInterface* default_instance_;
};
// -------------------------------------------------------------------

class Network : public ::google::protobuf::Message {
 public:
  Network();
  virtual ~Network();

  Network(const Network& from);

  inline Network& operator=(const Network& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Network& default_instance();

  void Swap(Network* other);

  // implements Message ----------------------------------------------

  Network* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Network& from);
  void MergeFrom(const Network& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string hostName = 1;
  inline bool has_hostname() const;
  inline void clear_hostname();
  static const int kHostNameFieldNumber = 1;
  inline const ::std::string& hostname() const;
  inline void set_hostname(const ::std::string& value);
  inline void set_hostname(const char* value);
  inline void set_hostname(const char* value, size_t size);
  inline ::std::string* mutable_hostname();
  inline ::std::string* release_hostname();
  inline void set_allocated_hostname(::std::string* hostname);

  // optional string gateway = 2;
  inline bool has_gateway() const;
  inline void clear_gateway();
  static const int kGatewayFieldNumber = 2;
  inline const ::std::string& gateway() const;
  inline void set_gateway(const ::std::string& value);
  inline void set_gateway(const char* value);
  inline void set_gateway(const char* value, size_t size);
  inline ::std::string* mutable_gateway();
  inline ::std::string* release_gateway();
  inline void set_allocated_gateway(::std::string* gateway);

  // optional string gateway6 = 3;
  inline bool has_gateway6() const;
  inline void clear_gateway6();
  static const int kGateway6FieldNumber = 3;
  inline const ::std::string& gateway6() const;
  inline void set_gateway6(const ::std::string& value);
  inline void set_gateway6(const char* value);
  inline void set_gateway6(const char* value, size_t size);
  inline ::std::string* mutable_gateway6();
  inline ::std::string* release_gateway6();
  inline void set_allocated_gateway6(::std::string* gateway6);

  // optional string gwdev = 4;
  inline bool has_gwdev() const;
  inline void clear_gwdev();
  static const int kGwdevFieldNumber = 4;
  inline const ::std::string& gwdev() const;
  inline void set_gwdev(const ::std::string& value);
  inline void set_gwdev(const char* value);
  inline void set_gwdev(const char* value, size_t size);
  inline ::std::string* mutable_gwdev();
  inline ::std::string* release_gwdev();
  inline void set_allocated_gwdev(::std::string* gwdev);

  // optional string nat = 5;
  inline bool has_nat() const;
  inline void clear_nat();
  static const int kNatFieldNumber = 5;
  inline const ::std::string& nat() const;
  inline void set_nat(const ::std::string& value);
  inline void set_nat(const char* value);
  inline void set_nat(const char* value, size_t size);
  inline ::std::string* mutable_nat();
  inline ::std::string* release_nat();
  inline void set_allocated_nat(::std::string* nat);

  // optional string dns = 6;
  inline bool has_dns() const;
  inline void clear_dns();
  static const int kDnsFieldNumber = 6;
  inline const ::std::string& dns() const;
  inline void set_dns(const ::std::string& value);
  inline void set_dns(const char* value);
  inline void set_dns(const char* value, size_t size);
  inline ::std::string* mutable_dns();
  inline ::std::string* release_dns();
  inline void set_allocated_dns(::std::string* dns);

  // repeated .TvWall.NetInterface interfaces = 7;
  inline int interfaces_size() const;
  inline void clear_interfaces();
  static const int kInterfacesFieldNumber = 7;
  inline const ::TvWall::NetInterface& interfaces(int index) const;
  inline ::TvWall::NetInterface* mutable_interfaces(int index);
  inline ::TvWall::NetInterface* add_interfaces();
  inline const ::google::protobuf::RepeatedPtrField< ::TvWall::NetInterface >&
      interfaces() const;
  inline ::google::protobuf::RepeatedPtrField< ::TvWall::NetInterface >*
      mutable_interfaces();

  // @@protoc_insertion_point(class_scope:TvWall.Network)
 private:
  inline void set_has_hostname();
  inline void clear_has_hostname();
  inline void set_has_gateway();
  inline void clear_has_gateway();
  inline void set_has_gateway6();
  inline void clear_has_gateway6();
  inline void set_has_gwdev();
  inline void clear_has_gwdev();
  inline void set_has_nat();
  inline void clear_has_nat();
  inline void set_has_dns();
  inline void clear_has_dns();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* hostname_;
  ::std::string* gateway_;
  ::std::string* gateway6_;
  ::std::string* gwdev_;
  ::std::string* nat_;
  ::std::string* dns_;
  ::google::protobuf::RepeatedPtrField< ::TvWall::NetInterface > interfaces_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_protobuf_2ftvWall_2eproto();
  friend void protobuf_AssignDesc_protobuf_2ftvWall_2eproto();
  friend void protobuf_ShutdownFile_protobuf_2ftvWall_2eproto();

  void InitAsDefaultInstance();
  static Network* default_instance_;
};
// -------------------------------------------------------------------

class NVR : public ::google::protobuf::Message {
 public:
  NVR();
  virtual ~NVR();

  NVR(const NVR& from);

  inline NVR& operator=(const NVR& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NVR& default_instance();

  void Swap(NVR* other);

  // implements Message ----------------------------------------------

  NVR* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NVR& from);
  void MergeFrom(const NVR& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string ip = 1;
  inline bool has_ip() const;
  inline void clear_ip();
  static const int kIpFieldNumber = 1;
  inline const ::std::string& ip() const;
  inline void set_ip(const ::std::string& value);
  inline void set_ip(const char* value);
  inline void set_ip(const char* value, size_t size);
  inline ::std::string* mutable_ip();
  inline ::std::string* release_ip();
  inline void set_allocated_ip(::std::string* ip);

  // required string userName = 2;
  inline bool has_username() const;
  inline void clear_username();
  static const int kUserNameFieldNumber = 2;
  inline const ::std::string& username() const;
  inline void set_username(const ::std::string& value);
  inline void set_username(const char* value);
  inline void set_username(const char* value, size_t size);
  inline ::std::string* mutable_username();
  inline ::std::string* release_username();
  inline void set_allocated_username(::std::string* username);

  // required string password = 3;
  inline bool has_password() const;
  inline void clear_password();
  static const int kPasswordFieldNumber = 3;
  inline const ::std::string& password() const;
  inline void set_password(const ::std::string& value);
  inline void set_password(const char* value);
  inline void set_password(const char* value, size_t size);
  inline ::std::string* mutable_password();
  inline ::std::string* release_password();
  inline void set_allocated_password(::std::string* password);

  // optional bool connected = 4;
  inline bool has_connected() const;
  inline void clear_connected();
  static const int kConnectedFieldNumber = 4;
  inline bool connected() const;
  inline void set_connected(bool value);

  // @@protoc_insertion_point(class_scope:TvWall.NVR)
 private:
  inline void set_has_ip();
  inline void clear_has_ip();
  inline void set_has_username();
  inline void clear_has_username();
  inline void set_has_password();
  inline void clear_has_password();
  inline void set_has_connected();
  inline void clear_has_connected();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* ip_;
  ::std::string* username_;
  ::std::string* password_;
  bool connected_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_protobuf_2ftvWall_2eproto();
  friend void protobuf_AssignDesc_protobuf_2ftvWall_2eproto();
  friend void protobuf_ShutdownFile_protobuf_2ftvWall_2eproto();

  void InitAsDefaultInstance();
  static NVR* default_instance_;
};
// -------------------------------------------------------------------

class FMP : public ::google::protobuf::Message {
 public:
  FMP();
  virtual ~FMP();

  FMP(const FMP& from);

  inline FMP& operator=(const FMP& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FMP& default_instance();

  void Swap(FMP* other);

  // implements Message ----------------------------------------------

  FMP* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FMP& from);
  void MergeFrom(const FMP& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string ip = 1;
  inline bool has_ip() const;
  inline void clear_ip();
  static const int kIpFieldNumber = 1;
  inline const ::std::string& ip() const;
  inline void set_ip(const ::std::string& value);
  inline void set_ip(const char* value);
  inline void set_ip(const char* value, size_t size);
  inline ::std::string* mutable_ip();
  inline ::std::string* release_ip();
  inline void set_allocated_ip(::std::string* ip);

  // required string userName = 2;
  inline bool has_username() const;
  inline void clear_username();
  static const int kUserNameFieldNumber = 2;
  inline const ::std::string& username() const;
  inline void set_username(const ::std::string& value);
  inline void set_username(const char* value);
  inline void set_username(const char* value, size_t size);
  inline ::std::string* mutable_username();
  inline ::std::string* release_username();
  inline void set_allocated_username(::std::string* username);

  // required string password = 3;
  inline bool has_password() const;
  inline void clear_password();
  static const int kPasswordFieldNumber = 3;
  inline const ::std::string& password() const;
  inline void set_password(const ::std::string& value);
  inline void set_password(const char* value);
  inline void set_password(const char* value, size_t size);
  inline ::std::string* mutable_password();
  inline ::std::string* release_password();
  inline void set_allocated_password(::std::string* password);

  // @@protoc_insertion_point(class_scope:TvWall.FMP)
 private:
  inline void set_has_ip();
  inline void clear_has_ip();
  inline void set_has_username();
  inline void clear_has_username();
  inline void set_has_password();
  inline void clear_has_password();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* ip_;
  ::std::string* username_;
  ::std::string* password_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_protobuf_2ftvWall_2eproto();
  friend void protobuf_AssignDesc_protobuf_2ftvWall_2eproto();
  friend void protobuf_ShutdownFile_protobuf_2ftvWall_2eproto();

  void InitAsDefaultInstance();
  static FMP* default_instance_;
};
// -------------------------------------------------------------------

class Packet_Session_Login : public ::google::protobuf::Message {
 public:
  Packet_Session_Login();
  virtual ~Packet_Session_Login();

  Packet_Session_Login(const Packet_Session_Login& from);

  inline Packet_Session_Login& operator=(const Packet_Session_Login& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Packet_Session_Login& default_instance();

  void Swap(Packet_Session_Login* other);

  // implements Message ----------------------------------------------

  Packet_Session_Login* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Packet_Session_Login& from);
  void MergeFrom(const Packet_Session_Login& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string version = 1 [default = "v1.0.0"];
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 1;
  inline const ::std::string& version() const;
  inline void set_version(const ::std::string& value);
  inline void set_version(const char* value);
  inline void set_version(const char* value, size_t size);
  inline ::std::string* mutable_version();
  inline ::std::string* release_version();
  inline void set_allocated_version(::std::string* version);

  // optional string userName = 2;
  inline bool has_username() const;
  inline void clear_username();
  static const int kUserNameFieldNumber = 2;
  inline const ::std::string& username() const;
  inline void set_username(const ::std::string& value);
  inline void set_username(const char* value);
  inline void set_username(const char* value, size_t size);
  inline ::std::string* mutable_username();
  inline ::std::string* release_username();
  inline void set_allocated_username(::std::string* username);

  // optional string passwd = 3;
  inline bool has_passwd() const;
  inline void clear_passwd();
  static const int kPasswdFieldNumber = 3;
  inline const ::std::string& passwd() const;
  inline void set_passwd(const ::std::string& value);
  inline void set_passwd(const char* value);
  inline void set_passwd(const char* value, size_t size);
  inline ::std::string* mutable_passwd();
  inline ::std::string* release_passwd();
  inline void set_allocated_passwd(::std::string* passwd);

  // optional string encryption = 4 [default = "md5"];
  inline bool has_encryption() const;
  inline void clear_encryption();
  static const int kEncryptionFieldNumber = 4;
  inline const ::std::string& encryption() const;
  inline void set_encryption(const ::std::string& value);
  inline void set_encryption(const char* value);
  inline void set_encryption(const char* value, size_t size);
  inline ::std::string* mutable_encryption();
  inline ::std::string* release_encryption();
  inline void set_allocated_encryption(::std::string* encryption);

  // optional int32 token = 5;
  inline bool has_token() const;
  inline void clear_token();
  static const int kTokenFieldNumber = 5;
  inline ::google::protobuf::int32 token() const;
  inline void set_token(::google::protobuf::int32 value);

  // optional bool isMaster = 6;
  inline bool has_ismaster() const;
  inline void clear_ismaster();
  static const int kIsMasterFieldNumber = 6;
  inline bool ismaster() const;
  inline void set_ismaster(bool value);

  // @@protoc_insertion_point(class_scope:TvWall.Packet.Session.Login)
 private:
  inline void set_has_version();
  inline void clear_has_version();
  inline void set_has_username();
  inline void clear_has_username();
  inline void set_has_passwd();
  inline void clear_has_passwd();
  inline void set_has_encryption();
  inline void clear_has_encryption();
  inline void set_has_token();
  inline void clear_has_token();
  inline void set_has_ismaster();
  inline void clear_has_ismaster();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* version_;
  static ::std::string* _default_version_;
  ::std::string* username_;
  ::std::string* passwd_;
  ::std::string* encryption_;
  static ::std::string* _default_encryption_;
  ::google::protobuf::int32 token_;
  bool ismaster_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_protobuf_2ftvWall_2eproto();
  friend void protobuf_AssignDesc_protobuf_2ftvWall_2eproto();
  friend void protobuf_ShutdownFile_protobuf_2ftvWall_2eproto();

  void InitAsDefaultInstance();
  static Packet_Session_Login* default_instance_;
};
// -------------------------------------------------------------------

class Packet_Session_LoginAck : public ::google::protobuf::Message {
 public:
  Packet_Session_LoginAck();
  virtual ~Packet_Session_LoginAck();

  Packet_Session_LoginAck(const Packet_Session_LoginAck& from);

  inline Packet_Session_LoginAck& operator=(const Packet_Session_LoginAck& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Packet_Session_LoginAck& default_instance();

  void Swap(Packet_Session_LoginAck* other);

  // implements Message ----------------------------------------------

  Packet_Session_LoginAck* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Packet_Session_LoginAck& from);
  void MergeFrom(const Packet_Session_LoginAck& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string version = 1 [default = "v1.0.0"];
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 1;
  inline const ::std::string& version() const;
  inline void set_version(const ::std::string& value);
  inline void set_version(const char* value);
  inline void set_version(const char* value, size_t size);
  inline ::std::string* mutable_version();
  inline ::std::string* release_version();
  inline void set_allocated_version(::std::string* version);

  // required int32 result = 2;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 2;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // optional int32 sessionId = 3;
  inline bool has_sessionid() const;
  inline void clear_sessionid();
  static const int kSessionIdFieldNumber = 3;
  inline ::google::protobuf::int32 sessionid() const;
  inline void set_sessionid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:TvWall.Packet.Session.LoginAck)
 private:
  inline void set_has_version();
  inline void clear_has_version();
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_sessionid();
  inline void clear_has_sessionid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* version_;
  static ::std::string* _default_version_;
  ::google::protobuf::int32 result_;
  ::google::protobuf::int32 sessionid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_protobuf_2ftvWall_2eproto();
  friend void protobuf_AssignDesc_protobuf_2ftvWall_2eproto();
  friend void protobuf_ShutdownFile_protobuf_2ftvWall_2eproto();

  void InitAsDefaultInstance();
  static Packet_Session_LoginAck* default_instance_;
};
// -------------------------------------------------------------------

class Packet_Session_LoginMasterAck_Server : public ::google::protobuf::Message {
 public:
  Packet_Session_LoginMasterAck_Server();
  virtual ~Packet_Session_LoginMasterAck_Server();

  Packet_Session_LoginMasterAck_Server(const Packet_Session_LoginMasterAck_Server& from);

  inline Packet_Session_LoginMasterAck_Server& operator=(const Packet_Session_LoginMasterAck_Server& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Packet_Session_LoginMasterAck_Server& default_instance();

  void Swap(Packet_Session_LoginMasterAck_Server* other);

  // implements Message ----------------------------------------------

  Packet_Session_LoginMasterAck_Server* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Packet_Session_LoginMasterAck_Server& from);
  void MergeFrom(const Packet_Session_LoginMasterAck_Server& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string peer = 1;
  inline bool has_peer() const;
  inline void clear_peer();
  static const int kPeerFieldNumber = 1;
  inline const ::std::string& peer() const;
  inline void set_peer(const ::std::string& value);
  inline void set_peer(const char* value);
  inline void set_peer(const char* value, size_t size);
  inline ::std::string* mutable_peer();
  inline ::std::string* release_peer();
  inline void set_allocated_peer(::std::string* peer);

  // optional .TvWall.Packet.Session.Login login = 3;
  inline bool has_login() const;
  inline void clear_login();
  static const int kLoginFieldNumber = 3;
  inline const ::TvWall::Packet_Session_Login& login() const;
  inline ::TvWall::Packet_Session_Login* mutable_login();
  inline ::TvWall::Packet_Session_Login* release_login();
  inline void set_allocated_login(::TvWall::Packet_Session_Login* login);

  // optional string serverName = 4;
  inline bool has_servername() const;
  inline void clear_servername();
  static const int kServerNameFieldNumber = 4;
  inline const ::std::string& servername() const;
  inline void set_servername(const ::std::string& value);
  inline void set_servername(const char* value);
  inline void set_servername(const char* value, size_t size);
  inline ::std::string* mutable_servername();
  inline ::std::string* release_servername();
  inline void set_allocated_servername(::std::string* servername);

  // @@protoc_insertion_point(class_scope:TvWall.Packet.Session.LoginMasterAck.Server)
 private:
  inline void set_has_peer();
  inline void clear_has_peer();
  inline void set_has_login();
  inline void clear_has_login();
  inline void set_has_servername();
  inline void clear_has_servername();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* peer_;
  ::TvWall::Packet_Session_Login* login_;
  ::std::string* servername_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_protobuf_2ftvWall_2eproto();
  friend void protobuf_AssignDesc_protobuf_2ftvWall_2eproto();
  friend void protobuf_ShutdownFile_protobuf_2ftvWall_2eproto();

  void InitAsDefaultInstance();
  static Packet_Session_LoginMasterAck_Server* default_instance_;
};
// -------------------------------------------------------------------

class Packet_Session_LoginMasterAck : public ::google::protobuf::Message {
 public:
  Packet_Session_LoginMasterAck();
  virtual ~Packet_Session_LoginMasterAck();

  Packet_Session_LoginMasterAck(const Packet_Session_LoginMasterAck& from);

  inline Packet_Session_LoginMasterAck& operator=(const Packet_Session_LoginMasterAck& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Packet_Session_LoginMasterAck& default_instance();

  void Swap(Packet_Session_LoginMasterAck* other);

  // implements Message ----------------------------------------------

  Packet_Session_LoginMasterAck* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Packet_Session_LoginMasterAck& from);
  void MergeFrom(const Packet_Session_LoginMasterAck& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Packet_Session_LoginMasterAck_Server Server;

  // accessors -------------------------------------------------------

  // required .TvWall.Packet.Session.LoginAck loginAck = 1;
  inline bool has_loginack() const;
  inline void clear_loginack();
  static const int kLoginAckFieldNumber = 1;
  inline const ::TvWall::Packet_Session_LoginAck& loginack() const;
  inline ::TvWall::Packet_Session_LoginAck* mutable_loginack();
  inline ::TvWall::Packet_Session_LoginAck* release_loginack();
  inline void set_allocated_loginack(::TvWall::Packet_Session_LoginAck* loginack);

  // required int32 token = 2;
  inline bool has_token() const;
  inline void clear_token();
  static const int kTokenFieldNumber = 2;
  inline ::google::protobuf::int32 token() const;
  inline void set_token(::google::protobuf::int32 value);

  // repeated .TvWall.Packet.Session.LoginMasterAck.Server ser = 3;
  inline int ser_size() const;
  inline void clear_ser();
  static const int kSerFieldNumber = 3;
  inline const ::TvWall::Packet_Session_LoginMasterAck_Server& ser(int index) const;
  inline ::TvWall::Packet_Session_LoginMasterAck_Server* mutable_ser(int index);
  inline ::TvWall::Packet_Session_LoginMasterAck_Server* add_ser();
  inline const ::google::protobuf::RepeatedPtrField< ::TvWall::Packet_Session_LoginMasterAck_Server >&
      ser() const;
  inline ::google::protobuf::RepeatedPtrField< ::TvWall::Packet_Session_LoginMasterAck_Server >*
      mutable_ser();

  // required .TvWall.Packet.ElementMaster.MasterLayout lyout = 4;
  inline bool has_lyout() const;
  inline void clear_lyout();
  static const int kLyoutFieldNumber = 4;
  inline const ::TvWall::Packet_ElementMaster_MasterLayout& lyout() const;
  inline ::TvWall::Packet_ElementMaster_MasterLayout* mutable_lyout();
  inline ::TvWall::Packet_ElementMaster_MasterLayout* release_lyout();
  inline void set_allocated_lyout(::TvWall::Packet_ElementMaster_MasterLayout* lyout);

  // @@protoc_insertion_point(class_scope:TvWall.Packet.Session.LoginMasterAck)
 private:
  inline void set_has_loginack();
  inline void clear_has_loginack();
  inline void set_has_token();
  inline void clear_has_token();
  inline void set_has_lyout();
  inline void clear_has_lyout();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TvWall::Packet_Session_LoginAck* loginack_;
  ::google::protobuf::RepeatedPtrField< ::TvWall::Packet_Session_LoginMasterAck_Server > ser_;
  ::TvWall::Packet_ElementMaster_MasterLayout* lyout_;
  ::google::protobuf::int32 token_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_protobuf_2ftvWall_2eproto();
  friend void protobuf_AssignDesc_protobuf_2ftvWall_2eproto();
  friend void protobuf_ShutdownFile_protobuf_2ftvWall_2eproto();

  void InitAsDefaultInstance();
  static Packet_Session_LoginMasterAck* default_instance_;
};
// -------------------------------------------------------------------

class Packet_Session_Logout : public ::google::protobuf::Message {
 public:
  Packet_Session_Logout();
  virtual ~Packet_Session_Logout();

  Packet_Session_Logout(const Packet_Session_Logout& from);

  inline Packet_Session_Logout& operator=(const Packet_Session_Logout& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Packet_Session_Logout& default_instance();

  void Swap(Packet_Session_Logout* other);

  // implements Message ----------------------------------------------

  Packet_Session_Logout* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Packet_Session_Logout& from);
  void MergeFrom(const Packet_Session_Logout& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TvWall.Packet.Session.LogoutReasonType reason = 1;
  inline bool has_reason() const;
  inline void clear_reason();
  static const int kReasonFieldNumber = 1;
  inline ::TvWall::Packet_Session_LogoutReasonType reason() const;
  inline void set_reason(::TvWall::Packet_Session_LogoutReasonType value);

  // @@protoc_insertion_point(class_scope:TvWall.Packet.Session.Logout)
 private:
  inline void set_has_reason();
  inline void clear_has_reason();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int reason_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_protobuf_2ftvWall_2eproto();
  friend void protobuf_AssignDesc_protobuf_2ftvWall_2eproto();
  friend void protobuf_ShutdownFile_protobuf_2ftvWall_2eproto();

  void InitAsDefaultInstance();
  static Packet_Session_Logout* default_instance_;
};
// -------------------------------------------------------------------

class Packet_Session_LogoutAck : public ::google::protobuf::Message {
 public:
  Packet_Session_LogoutAck();
  virtual ~Packet_Session_LogoutAck();

  Packet_Session_LogoutAck(const Packet_Session_LogoutAck& from);

  inline Packet_Session_LogoutAck& operator=(const Packet_Session_LogoutAck& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Packet_Session_LogoutAck& default_instance();

  void Swap(Packet_Session_LogoutAck* other);

  // implements Message ----------------------------------------------

  Packet_Session_LogoutAck* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Packet_Session_LogoutAck& from);
  void MergeFrom(const Packet_Session_LogoutAck& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:TvWall.Packet.Session.LogoutAck)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_protobuf_2ftvWall_2eproto();
  friend void protobuf_AssignDesc_protobuf_2ftvWall_2eproto();
  friend void protobuf_ShutdownFile_protobuf_2ftvWall_2eproto();

  void InitAsDefaultInstance();
  static Packet_Session_LogoutAck* default_instance_;
};
// -------------------------------------------------------------------

class Packet_Session_Ping : public ::google::protobuf::Message {
 public:
  Packet_Session_Ping();
  virtual ~Packet_Session_Ping();

  Packet_Session_Ping(const Packet_Session_Ping& from);

  inline Packet_Session_Ping& operator=(const Packet_Session_Ping& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Packet_Session_Ping& default_instance();

  void Swap(Packet_Session_Ping* other);

  // implements Message ----------------------------------------------

  Packet_Session_Ping* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Packet_Session_Ping& from);
  void MergeFrom(const Packet_Session_Ping& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 num = 1;
  inline bool has_num() const;
  inline void clear_num();
  static const int kNumFieldNumber = 1;
  inline ::google::protobuf::int32 num() const;
  inline void set_num(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:TvWall.Packet.Session.Ping)
 private:
  inline void set_has_num();
  inline void clear_has_num();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 num_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_protobuf_2ftvWall_2eproto();
  friend void protobuf_AssignDesc_protobuf_2ftvWall_2eproto();
  friend void protobuf_ShutdownFile_protobuf_2ftvWall_2eproto();

  void InitAsDefaultInstance();
  static Packet_Session_Ping* default_instance_;
};
// -------------------------------------------------------------------

class Packet_Session_PingAck : public ::google::protobuf::Message {
 public:
  Packet_Session_PingAck();
  virtual ~Packet_Session_PingAck();

  Packet_Session_PingAck(const Packet_Session_PingAck& from);

  inline Packet_Session_PingAck& operator=(const Packet_Session_PingAck& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Packet_Session_PingAck& default_instance();

  void Swap(Packet_Session_PingAck* other);

  // implements Message ----------------------------------------------

  Packet_Session_PingAck* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Packet_Session_PingAck& from);
  void MergeFrom(const Packet_Session_PingAck& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 num = 2;
  inline bool has_num() const;
  inline void clear_num();
  static const int kNumFieldNumber = 2;
  inline ::google::protobuf::int32 num() const;
  inline void set_num(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:TvWall.Packet.Session.PingAck)
 private:
  inline void set_has_num();
  inline void clear_has_num();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 num_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_protobuf_2ftvWall_2eproto();
  friend void protobuf_AssignDesc_protobuf_2ftvWall_2eproto();
  friend void protobuf_ShutdownFile_protobuf_2ftvWall_2eproto();

  void InitAsDefaultInstance();
  static Packet_Session_PingAck* default_instance_;
};
// -------------------------------------------------------------------

class Packet_Session : public ::google::protobuf::Message {
 public:
  Packet_Session();
  virtual ~Packet_Session();

  Packet_Session(const Packet_Session& from);

  inline Packet_Session& operator=(const Packet_Session& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Packet_Session& default_instance();

  void Swap(Packet_Session* other);

  // implements Message ----------------------------------------------

  Packet_Session* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Packet_Session& from);
  void MergeFrom(const Packet_Session& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Packet_Session_Login Login;
  typedef Packet_Session_LoginAck LoginAck;
  typedef Packet_Session_LoginMasterAck LoginMasterAck;
  typedef Packet_Session_Logout Logout;
  typedef Packet_Session_LogoutAck LogoutAck;
  typedef Packet_Session_Ping Ping;
  typedef Packet_Session_PingAck PingAck;

  typedef Packet_Session_LogoutReasonType LogoutReasonType;
  static const LogoutReasonType USER_LOGOUT = Packet_Session_LogoutReasonType_USER_LOGOUT;
  static inline bool LogoutReasonType_IsValid(int value) {
    return Packet_Session_LogoutReasonType_IsValid(value);
  }
  static const LogoutReasonType LogoutReasonType_MIN =
    Packet_Session_LogoutReasonType_LogoutReasonType_MIN;
  static const LogoutReasonType LogoutReasonType_MAX =
    Packet_Session_LogoutReasonType_LogoutReasonType_MAX;
  static const int LogoutReasonType_ARRAYSIZE =
    Packet_Session_LogoutReasonType_LogoutReasonType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  LogoutReasonType_descriptor() {
    return Packet_Session_LogoutReasonType_descriptor();
  }
  static inline const ::std::string& LogoutReasonType_Name(LogoutReasonType value) {
    return Packet_Session_LogoutReasonType_Name(value);
  }
  static inline bool LogoutReasonType_Parse(const ::std::string& name,
      LogoutReasonType* value) {
    return Packet_Session_LogoutReasonType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .TvWall.Packet.Session.Login login = 1;
  inline bool has_login() const;
  inline void clear_login();
  static const int kLoginFieldNumber = 1;
  inline const ::TvWall::Packet_Session_Login& login() const;
  inline ::TvWall::Packet_Session_Login* mutable_login();
  inline ::TvWall::Packet_Session_Login* release_login();
  inline void set_allocated_login(::TvWall::Packet_Session_Login* login);

  // optional .TvWall.Packet.Session.LoginAck loginAck = 2;
  inline bool has_loginack() const;
  inline void clear_loginack();
  static const int kLoginAckFieldNumber = 2;
  inline const ::TvWall::Packet_Session_LoginAck& loginack() const;
  inline ::TvWall::Packet_Session_LoginAck* mutable_loginack();
  inline ::TvWall::Packet_Session_LoginAck* release_loginack();
  inline void set_allocated_loginack(::TvWall::Packet_Session_LoginAck* loginack);

  // optional .TvWall.Packet.Session.LoginMasterAck loginMstAck = 3;
  inline bool has_loginmstack() const;
  inline void clear_loginmstack();
  static const int kLoginMstAckFieldNumber = 3;
  inline const ::TvWall::Packet_Session_LoginMasterAck& loginmstack() const;
  inline ::TvWall::Packet_Session_LoginMasterAck* mutable_loginmstack();
  inline ::TvWall::Packet_Session_LoginMasterAck* release_loginmstack();
  inline void set_allocated_loginmstack(::TvWall::Packet_Session_LoginMasterAck* loginmstack);

  // optional .TvWall.Packet.Session.Logout logout = 4;
  inline bool has_logout() const;
  inline void clear_logout();
  static const int kLogoutFieldNumber = 4;
  inline const ::TvWall::Packet_Session_Logout& logout() const;
  inline ::TvWall::Packet_Session_Logout* mutable_logout();
  inline ::TvWall::Packet_Session_Logout* release_logout();
  inline void set_allocated_logout(::TvWall::Packet_Session_Logout* logout);

  // optional .TvWall.Packet.Session.LogoutAck logoutAck = 5;
  inline bool has_logoutack() const;
  inline void clear_logoutack();
  static const int kLogoutAckFieldNumber = 5;
  inline const ::TvWall::Packet_Session_LogoutAck& logoutack() const;
  inline ::TvWall::Packet_Session_LogoutAck* mutable_logoutack();
  inline ::TvWall::Packet_Session_LogoutAck* release_logoutack();
  inline void set_allocated_logoutack(::TvWall::Packet_Session_LogoutAck* logoutack);

  // optional .TvWall.Packet.Session.Ping ping = 6;
  inline bool has_ping() const;
  inline void clear_ping();
  static const int kPingFieldNumber = 6;
  inline const ::TvWall::Packet_Session_Ping& ping() const;
  inline ::TvWall::Packet_Session_Ping* mutable_ping();
  inline ::TvWall::Packet_Session_Ping* release_ping();
  inline void set_allocated_ping(::TvWall::Packet_Session_Ping* ping);

  // optional .TvWall.Packet.Session.PingAck pingAck = 7;
  inline bool has_pingack() const;
  inline void clear_pingack();
  static const int kPingAckFieldNumber = 7;
  inline const ::TvWall::Packet_Session_PingAck& pingack() const;
  inline ::TvWall::Packet_Session_PingAck* mutable_pingack();
  inline ::TvWall::Packet_Session_PingAck* release_pingack();
  inline void set_allocated_pingack(::TvWall::Packet_Session_PingAck* pingack);

  // @@protoc_insertion_point(class_scope:TvWall.Packet.Session)
 private:
  inline void set_has_login();
  inline void clear_has_login();
  inline void set_has_loginack();
  inline void clear_has_loginack();
  inline void set_has_loginmstack();
  inline void clear_has_loginmstack();
  inline void set_has_logout();
  inline void clear_has_logout();
  inline void set_has_logoutack();
  inline void clear_has_logoutack();
  inline void set_has_ping();
  inline void clear_has_ping();
  inline void set_has_pingack();
  inline void clear_has_pingack();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TvWall::Packet_Session_Login* login_;
  ::TvWall::Packet_Session_LoginAck* loginack_;
  ::TvWall::Packet_Session_LoginMasterAck* loginmstack_;
  ::TvWall::Packet_Session_Logout* logout_;
  ::TvWall::Packet_Session_LogoutAck* logoutack_;
  ::TvWall::Packet_Session_Ping* ping_;
  ::TvWall::Packet_Session_PingAck* pingack_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_protobuf_2ftvWall_2eproto();
  friend void protobuf_AssignDesc_protobuf_2ftvWall_2eproto();
  friend void protobuf_ShutdownFile_protobuf_2ftvWall_2eproto();

  void InitAsDefaultInstance();
  static Packet_Session* default_instance_;
};
// -------------------------------------------------------------------

class Packet_ElementDat_Screen : public ::google::protobuf::Message {
 public:
  Packet_ElementDat_Screen();
  virtual ~Packet_ElementDat_Screen();

  Packet_ElementDat_Screen(const Packet_ElementDat_Screen& from);

  inline Packet_ElementDat_Screen& operator=(const Packet_ElementDat_Screen& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Packet_ElementDat_Screen& default_instance();

  void Swap(Packet_ElementDat_Screen* other);

  // implements Message ----------------------------------------------

  Packet_ElementDat_Screen* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Packet_ElementDat_Screen& from);
  void MergeFrom(const Packet_ElementDat_Screen& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TvWall.Rect geometry = 1;
  inline bool has_geometry() const;
  inline void clear_geometry();
  static const int kGeometryFieldNumber = 1;
  inline const ::TvWall::Rect& geometry() const;
  inline ::TvWall::Rect* mutable_geometry();
  inline ::TvWall::Rect* release_geometry();
  inline void set_allocated_geometry(::TvWall::Rect* geometry);

  // optional int32 screenIndex = 2;
  inline bool has_screenindex() const;
  inline void clear_screenindex();
  static const int kScreenIndexFieldNumber = 2;
  inline ::google::protobuf::int32 screenindex() const;
  inline void set_screenindex(::google::protobuf::int32 value);

  // required int32 row = 3;
  inline bool has_row() const;
  inline void clear_row();
  static const int kRowFieldNumber = 3;
  inline ::google::protobuf::int32 row() const;
  inline void set_row(::google::protobuf::int32 value);

  // required int32 col = 4;
  inline bool has_col() const;
  inline void clear_col();
  static const int kColFieldNumber = 4;
  inline ::google::protobuf::int32 col() const;
  inline void set_col(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:TvWall.Packet.ElementDat.Screen)
 private:
  inline void set_has_geometry();
  inline void clear_has_geometry();
  inline void set_has_screenindex();
  inline void clear_has_screenindex();
  inline void set_has_row();
  inline void clear_has_row();
  inline void set_has_col();
  inline void clear_has_col();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TvWall::Rect* geometry_;
  ::google::protobuf::int32 screenindex_;
  ::google::protobuf::int32 row_;
  ::google::protobuf::int32 col_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_protobuf_2ftvWall_2eproto();
  friend void protobuf_AssignDesc_protobuf_2ftvWall_2eproto();
  friend void protobuf_ShutdownFile_protobuf_2ftvWall_2eproto();

  void InitAsDefaultInstance();
  static Packet_ElementDat_Screen* default_instance_;
};
// -------------------------------------------------------------------

class Packet_ElementDat_Camera_CameraInfo : public ::google::protobuf::Message {
 public:
  Packet_ElementDat_Camera_CameraInfo();
  virtual ~Packet_ElementDat_Camera_CameraInfo();

  Packet_ElementDat_Camera_CameraInfo(const Packet_ElementDat_Camera_CameraInfo& from);

  inline Packet_ElementDat_Camera_CameraInfo& operator=(const Packet_ElementDat_Camera_CameraInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Packet_ElementDat_Camera_CameraInfo& default_instance();

  void Swap(Packet_ElementDat_Camera_CameraInfo* other);

  // implements Message ----------------------------------------------

  Packet_ElementDat_Camera_CameraInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Packet_ElementDat_Camera_CameraInfo& from);
  void MergeFrom(const Packet_ElementDat_Camera_CameraInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string cameraIP = 1;
  inline bool has_cameraip() const;
  inline void clear_cameraip();
  static const int kCameraIPFieldNumber = 1;
  inline const ::std::string& cameraip() const;
  inline void set_cameraip(const ::std::string& value);
  inline void set_cameraip(const char* value);
  inline void set_cameraip(const char* value, size_t size);
  inline ::std::string* mutable_cameraip();
  inline ::std::string* release_cameraip();
  inline void set_allocated_cameraip(::std::string* cameraip);

  // required int32 cameraPort = 2;
  inline bool has_cameraport() const;
  inline void clear_cameraport();
  static const int kCameraPortFieldNumber = 2;
  inline ::google::protobuf::int32 cameraport() const;
  inline void set_cameraport(::google::protobuf::int32 value);

  // optional string cameraName = 3;
  inline bool has_cameraname() const;
  inline void clear_cameraname();
  static const int kCameraNameFieldNumber = 3;
  inline const ::std::string& cameraname() const;
  inline void set_cameraname(const ::std::string& value);
  inline void set_cameraname(const char* value);
  inline void set_cameraname(const char* value, size_t size);
  inline ::std::string* mutable_cameraname();
  inline ::std::string* release_cameraname();
  inline void set_allocated_cameraname(::std::string* cameraname);

  // optional int32 width = 4;
  inline bool has_width() const;
  inline void clear_width();
  static const int kWidthFieldNumber = 4;
  inline ::google::protobuf::int32 width() const;
  inline void set_width(::google::protobuf::int32 value);

  // optional int32 height = 5;
  inline bool has_height() const;
  inline void clear_height();
  static const int kHeightFieldNumber = 5;
  inline ::google::protobuf::int32 height() const;
  inline void set_height(::google::protobuf::int32 value);

  // optional bool canPtz = 6;
  inline bool has_canptz() const;
  inline void clear_canptz();
  static const int kCanPtzFieldNumber = 6;
  inline bool canptz() const;
  inline void set_canptz(bool value);

  // optional bool composite = 7 [default = false];
  inline bool has_composite() const;
  inline void clear_composite();
  static const int kCompositeFieldNumber = 7;
  inline bool composite() const;
  inline void set_composite(bool value);

  // optional uint32 model = 8;
  inline bool has_model() const;
  inline void clear_model();
  static const int kModelFieldNumber = 8;
  inline ::google::protobuf::uint32 model() const;
  inline void set_model(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:TvWall.Packet.ElementDat.Camera.CameraInfo)
 private:
  inline void set_has_cameraip();
  inline void clear_has_cameraip();
  inline void set_has_cameraport();
  inline void clear_has_cameraport();
  inline void set_has_cameraname();
  inline void clear_has_cameraname();
  inline void set_has_width();
  inline void clear_has_width();
  inline void set_has_height();
  inline void clear_has_height();
  inline void set_has_canptz();
  inline void clear_has_canptz();
  inline void set_has_composite();
  inline void clear_has_composite();
  inline void set_has_model();
  inline void clear_has_model();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* cameraip_;
  ::std::string* cameraname_;
  ::google::protobuf::int32 cameraport_;
  ::google::protobuf::int32 width_;
  ::google::protobuf::int32 height_;
  bool canptz_;
  bool composite_;
  ::google::protobuf::uint32 model_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  friend void  protobuf_AddDesc_protobuf_2ftvWall_2eproto();
  friend void protobuf_AssignDesc_protobuf_2ftvWall_2eproto();
  friend void protobuf_ShutdownFile_protobuf_2ftvWall_2eproto();

  void InitAsDefaultInstance();
  static Packet_ElementDat_Camera_CameraInfo* default_instance_;
};
// -------------------------------------------------------------------

class Packet_ElementDat_Camera_RecordInfo : public ::google::protobuf::Message {
 public:
  Packet_ElementDat_Camera_RecordInfo();
  virtual ~Packet_ElementDat_Camera_RecordInfo();

  Packet_ElementDat_Camera_RecordInfo(const Packet_ElementDat_Camera_RecordInfo& from);

  inline Packet_ElementDat_Camera_RecordInfo& operator=(const Packet_ElementDat_Camera_RecordInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Packet_ElementDat_Camera_RecordInfo& default_instance();

  void Swap(Packet_ElementDat_Camera_RecordInfo* other);

  // implements Message ----------------------------------------------

  Packet_ElementDat_Camera_RecordInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Packet_ElementDat_Camera_RecordInfo& from);
  void MergeFrom(const Packet_ElementDat_Camera_RecordInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 begin = 1;
  inline bool has_begin() const;
  inline void clear_begin();
  static const int kBeginFieldNumber = 1;
  inline ::google::protobuf::uint64 begin() const;
  inline void set_begin(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:TvWall.Packet.ElementDat.Camera.RecordInfo)
 private:
  inline void set_has_begin();
  inline void clear_has_begin();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 begin_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_protobuf_2ftvWall_2eproto();
  friend void protobuf_AssignDesc_protobuf_2ftvWall_2eproto();
  friend void protobuf_ShutdownFile_protobuf_2ftvWall_2eproto();

  void InitAsDefaultInstance();
  static Packet_ElementDat_Camera_RecordInfo* default_instance_;
};
// -------------------------------------------------------------------

class Packet_ElementDat_Camera : public ::google::protobuf::Message {
 public:
  Packet_ElementDat_Camera();
  virtual ~Packet_ElementDat_Camera();

  Packet_ElementDat_Camera(const Packet_ElementDat_Camera& from);

  inline Packet_ElementDat_Camera& operator=(const Packet_ElementDat_Camera& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Packet_ElementDat_Camera& default_instance();

  void Swap(Packet_ElementDat_Camera* other);

  // implements Message ----------------------------------------------

  Packet_ElementDat_Camera* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Packet_ElementDat_Camera& from);
  void MergeFrom(const Packet_ElementDat_Camera& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Packet_ElementDat_Camera_CameraInfo CameraInfo;
  typedef Packet_ElementDat_Camera_RecordInfo RecordInfo;

  // accessors -------------------------------------------------------

  // required .TvWall.Guid cameraId = 1;
  inline bool has_cameraid() const;
  inline void clear_cameraid();
  static const int kCameraIdFieldNumber = 1;
  inline const ::TvWall::Guid& cameraid() const;
  inline ::TvWall::Guid* mutable_cameraid();
  inline ::TvWall::Guid* release_cameraid();
  inline void set_allocated_cameraid(::TvWall::Guid* cameraid);

  // required .TvWall.Packet.ElementDat.Camera.CameraInfo cameraInfo = 2;
  inline bool has_camerainfo() const;
  inline void clear_camerainfo();
  static const int kCameraInfoFieldNumber = 2;
  inline const ::TvWall::Packet_ElementDat_Camera_CameraInfo& camerainfo() const;
  inline ::TvWall::Packet_ElementDat_Camera_CameraInfo* mutable_camerainfo();
  inline ::TvWall::Packet_ElementDat_Camera_CameraInfo* release_camerainfo();
  inline void set_allocated_camerainfo(::TvWall::Packet_ElementDat_Camera_CameraInfo* camerainfo);

  // optional .TvWall.Packet.ElementDat.Camera.RecordInfo recordInfo = 3;
  inline bool has_recordinfo() const;
  inline void clear_recordinfo();
  static const int kRecordInfoFieldNumber = 3;
  inline const ::TvWall::Packet_ElementDat_Camera_RecordInfo& recordinfo() const;
  inline ::TvWall::Packet_ElementDat_Camera_RecordInfo* mutable_recordinfo();
  inline ::TvWall::Packet_ElementDat_Camera_RecordInfo* release_recordinfo();
  inline void set_allocated_recordinfo(::TvWall::Packet_ElementDat_Camera_RecordInfo* recordinfo);

  // optional bool isPlaying = 4 [default = false];
  inline bool has_isplaying() const;
  inline void clear_isplaying();
  static const int kIsPlayingFieldNumber = 4;
  inline bool isplaying() const;
  inline void set_isplaying(bool value);

  // optional bool isConnected = 5 [default = false];
  inline bool has_isconnected() const;
  inline void clear_isconnected();
  static const int kIsConnectedFieldNumber = 5;
  inline bool isconnected() const;
  inline void set_isconnected(bool value);

  // optional bool isDel = 6 [default = false];
  inline bool has_isdel() const;
  inline void clear_isdel();
  static const int kIsDelFieldNumber = 6;
  inline bool isdel() const;
  inline void set_isdel(bool value);

  // optional bool isPlayBack = 7 [default = false];
  inline bool has_isplayback() const;
  inline void clear_isplayback();
  static const int kIsPlayBackFieldNumber = 7;
  inline bool isplayback() const;
  inline void set_isplayback(bool value);

  // optional .TvWall.Guid parentId = 8;
  inline bool has_parentid() const;
  inline void clear_parentid();
  static const int kParentIdFieldNumber = 8;
  inline const ::TvWall::Guid& parentid() const;
  inline ::TvWall::Guid* mutable_parentid();
  inline ::TvWall::Guid* release_parentid();
  inline void set_allocated_parentid(::TvWall::Guid* parentid);

  // @@protoc_insertion_point(class_scope:TvWall.Packet.ElementDat.Camera)
 private:
  inline void set_has_cameraid();
  inline void clear_has_cameraid();
  inline void set_has_camerainfo();
  inline void clear_has_camerainfo();
  inline void set_has_recordinfo();
  inline void clear_has_recordinfo();
  inline void set_has_isplaying();
  inline void clear_has_isplaying();
  inline void set_has_isconnected();
  inline void clear_has_isconnected();
  inline void set_has_isdel();
  inline void clear_has_isdel();
  inline void set_has_isplayback();
  inline void clear_has_isplayback();
  inline void set_has_parentid();
  inline void clear_has_parentid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TvWall::Guid* cameraid_;
  ::TvWall::Packet_ElementDat_Camera_CameraInfo* camerainfo_;
  ::TvWall::Packet_ElementDat_Camera_RecordInfo* recordinfo_;
  ::TvWall::Guid* parentid_;
  bool isplaying_;
  bool isconnected_;
  bool isdel_;
  bool isplayback_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  friend void  protobuf_AddDesc_protobuf_2ftvWall_2eproto();
  friend void protobuf_AssignDesc_protobuf_2ftvWall_2eproto();
  friend void protobuf_ShutdownFile_protobuf_2ftvWall_2eproto();

  void InitAsDefaultInstance();
  static Packet_ElementDat_Camera* default_instance_;
};
// -------------------------------------------------------------------

class Packet_ElementDat_CameraGrp : public ::google::protobuf::Message {
 public:
  Packet_ElementDat_CameraGrp();
  virtual ~Packet_ElementDat_CameraGrp();

  Packet_ElementDat_CameraGrp(const Packet_ElementDat_CameraGrp& from);

  inline Packet_ElementDat_CameraGrp& operator=(const Packet_ElementDat_CameraGrp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Packet_ElementDat_CameraGrp& default_instance();

  void Swap(Packet_ElementDat_CameraGrp* other);

  // implements Message ----------------------------------------------

  Packet_ElementDat_CameraGrp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Packet_ElementDat_CameraGrp& from);
  void MergeFrom(const Packet_ElementDat_CameraGrp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string grpName = 1;
  inline bool has_grpname() const;
  inline void clear_grpname();
  static const int kGrpNameFieldNumber = 1;
  inline const ::std::string& grpname() const;
  inline void set_grpname(const ::std::string& value);
  inline void set_grpname(const char* value);
  inline void set_grpname(const char* value, size_t size);
  inline ::std::string* mutable_grpname();
  inline ::std::string* release_grpname();
  inline void set_allocated_grpname(::std::string* grpname);

  // repeated .TvWall.Packet.ElementDat.Camera cam = 2;
  inline int cam_size() const;
  inline void clear_cam();
  static const int kCamFieldNumber = 2;
  inline const ::TvWall::Packet_ElementDat_Camera& cam(int index) const;
  inline ::TvWall::Packet_ElementDat_Camera* mutable_cam(int index);
  inline ::TvWall::Packet_ElementDat_Camera* add_cam();
  inline const ::google::protobuf::RepeatedPtrField< ::TvWall::Packet_ElementDat_Camera >&
      cam() const;
  inline ::google::protobuf::RepeatedPtrField< ::TvWall::Packet_ElementDat_Camera >*
      mutable_cam();

  // repeated .TvWall.Packet.ElementDat.CameraGrp camGrp = 3;
  inline int camgrp_size() const;
  inline void clear_camgrp();
  static const int kCamGrpFieldNumber = 3;
  inline const ::TvWall::Packet_ElementDat_CameraGrp& camgrp(int index) const;
  inline ::TvWall::Packet_ElementDat_CameraGrp* mutable_camgrp(int index);
  inline ::TvWall::Packet_ElementDat_CameraGrp* add_camgrp();
  inline const ::google::protobuf::RepeatedPtrField< ::TvWall::Packet_ElementDat_CameraGrp >&
      camgrp() const;
  inline ::google::protobuf::RepeatedPtrField< ::TvWall::Packet_ElementDat_CameraGrp >*
      mutable_camgrp();

  // required .TvWall.Guid grpId = 4;
  inline bool has_grpid() const;
  inline void clear_grpid();
  static const int kGrpIdFieldNumber = 4;
  inline const ::TvWall::Guid& grpid() const;
  inline ::TvWall::Guid* mutable_grpid();
  inline ::TvWall::Guid* release_grpid();
  inline void set_allocated_grpid(::TvWall::Guid* grpid);

  // optional bool isDel = 5 [default = false];
  inline bool has_isdel() const;
  inline void clear_isdel();
  static const int kIsDelFieldNumber = 5;
  inline bool isdel() const;
  inline void set_isdel(bool value);

  // optional .TvWall.Guid parentId = 6;
  inline bool has_parentid() const;
  inline void clear_parentid();
  static const int kParentIdFieldNumber = 6;
  inline const ::TvWall::Guid& parentid() const;
  inline ::TvWall::Guid* mutable_parentid();
  inline ::TvWall::Guid* release_parentid();
  inline void set_allocated_parentid(::TvWall::Guid* parentid);

  // @@protoc_insertion_point(class_scope:TvWall.Packet.ElementDat.CameraGrp)
 private:
  inline void set_has_grpname();
  inline void clear_has_grpname();
  inline void set_has_grpid();
  inline void clear_has_grpid();
  inline void set_has_isdel();
  inline void clear_has_isdel();
  inline void set_has_parentid();
  inline void clear_has_parentid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* grpname_;
  ::google::protobuf::RepeatedPtrField< ::TvWall::Packet_ElementDat_Camera > cam_;
  ::google::protobuf::RepeatedPtrField< ::TvWall::Packet_ElementDat_CameraGrp > camgrp_;
  ::TvWall::Guid* grpid_;
  ::TvWall::Guid* parentid_;
  bool isdel_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_protobuf_2ftvWall_2eproto();
  friend void protobuf_AssignDesc_protobuf_2ftvWall_2eproto();
  friend void protobuf_ShutdownFile_protobuf_2ftvWall_2eproto();

  void InitAsDefaultInstance();
  static Packet_ElementDat_CameraGrp* default_instance_;
};
// -------------------------------------------------------------------

class Packet_ElementDat_LocalMovie : public ::google::protobuf::Message {
 public:
  Packet_ElementDat_LocalMovie();
  virtual ~Packet_ElementDat_LocalMovie();

  Packet_ElementDat_LocalMovie(const Packet_ElementDat_LocalMovie& from);

  inline Packet_ElementDat_LocalMovie& operator=(const Packet_ElementDat_LocalMovie& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Packet_ElementDat_LocalMovie& default_instance();

  void Swap(Packet_ElementDat_LocalMovie* other);

  // implements Message ----------------------------------------------

  Packet_ElementDat_LocalMovie* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Packet_ElementDat_LocalMovie& from);
  void MergeFrom(const Packet_ElementDat_LocalMovie& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string fileName = 1;
  inline bool has_filename() const;
  inline void clear_filename();
  static const int kFileNameFieldNumber = 1;
  inline const ::std::string& filename() const;
  inline void set_filename(const ::std::string& value);
  inline void set_filename(const char* value);
  inline void set_filename(const char* value, size_t size);
  inline ::std::string* mutable_filename();
  inline ::std::string* release_filename();
  inline void set_allocated_filename(::std::string* filename);

  // @@protoc_insertion_point(class_scope:TvWall.Packet.ElementDat.LocalMovie)
 private:
  inline void set_has_filename();
  inline void clear_has_filename();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* filename_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_protobuf_2ftvWall_2eproto();
  friend void protobuf_AssignDesc_protobuf_2ftvWall_2eproto();
  friend void protobuf_ShutdownFile_protobuf_2ftvWall_2eproto();

  void InitAsDefaultInstance();
  static Packet_ElementDat_LocalMovie* default_instance_;
};
// -------------------------------------------------------------------

class Packet_ElementDat_Flash : public ::google::protobuf::Message {
 public:
  Packet_ElementDat_Flash();
  virtual ~Packet_ElementDat_Flash();

  Packet_ElementDat_Flash(const Packet_ElementDat_Flash& from);

  inline Packet_ElementDat_Flash& operator=(const Packet_ElementDat_Flash& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Packet_ElementDat_Flash& default_instance();

  void Swap(Packet_ElementDat_Flash* other);

  // implements Message ----------------------------------------------

  Packet_ElementDat_Flash* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Packet_ElementDat_Flash& from);
  void MergeFrom(const Packet_ElementDat_Flash& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string url = 1;
  inline bool has_url() const;
  inline void clear_url();
  static const int kUrlFieldNumber = 1;
  inline const ::std::string& url() const;
  inline void set_url(const ::std::string& value);
  inline void set_url(const char* value);
  inline void set_url(const char* value, size_t size);
  inline ::std::string* mutable_url();
  inline ::std::string* release_url();
  inline void set_allocated_url(::std::string* url);

  // @@protoc_insertion_point(class_scope:TvWall.Packet.ElementDat.Flash)
 private:
  inline void set_has_url();
  inline void clear_has_url();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* url_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_protobuf_2ftvWall_2eproto();
  friend void protobuf_AssignDesc_protobuf_2ftvWall_2eproto();
  friend void protobuf_ShutdownFile_protobuf_2ftvWall_2eproto();

  void InitAsDefaultInstance();
  static Packet_ElementDat_Flash* default_instance_;
};
// -------------------------------------------------------------------

class Packet_ElementDat_View : public ::google::protobuf::Message {
 public:
  Packet_ElementDat_View();
  virtual ~Packet_ElementDat_View();

  Packet_ElementDat_View(const Packet_ElementDat_View& from);

  inline Packet_ElementDat_View& operator=(const Packet_ElementDat_View& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Packet_ElementDat_View& default_instance();

  void Swap(Packet_ElementDat_View* other);

  // implements Message ----------------------------------------------

  Packet_ElementDat_View* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Packet_ElementDat_View& from);
  void MergeFrom(const Packet_ElementDat_View& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Packet_ElementDat_View_ViewType ViewType;
  static const ViewType VIDEO = Packet_ElementDat_View_ViewType_VIDEO;
  static const ViewType FLASH = Packet_ElementDat_View_ViewType_FLASH;
  static const ViewType HTML = Packet_ElementDat_View_ViewType_HTML;
  static const ViewType TEXT = Packet_ElementDat_View_ViewType_TEXT;
  static const ViewType LOCAL_MOVIE = Packet_ElementDat_View_ViewType_LOCAL_MOVIE;
  static const ViewType MAP = Packet_ElementDat_View_ViewType_MAP;
  static const ViewType OTHERS = Packet_ElementDat_View_ViewType_OTHERS;
  static const ViewType RECORDFILE = Packet_ElementDat_View_ViewType_RECORDFILE;
  static const ViewType ALARM = Packet_ElementDat_View_ViewType_ALARM;
  static inline bool ViewType_IsValid(int value) {
    return Packet_ElementDat_View_ViewType_IsValid(value);
  }
  static const ViewType ViewType_MIN =
    Packet_ElementDat_View_ViewType_ViewType_MIN;
  static const ViewType ViewType_MAX =
    Packet_ElementDat_View_ViewType_ViewType_MAX;
  static const int ViewType_ARRAYSIZE =
    Packet_ElementDat_View_ViewType_ViewType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ViewType_descriptor() {
    return Packet_ElementDat_View_ViewType_descriptor();
  }
  static inline const ::std::string& ViewType_Name(ViewType value) {
    return Packet_ElementDat_View_ViewType_Name(value);
  }
  static inline bool ViewType_Parse(const ::std::string& name,
      ViewType* value) {
    return Packet_ElementDat_View_ViewType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required int32 winId = 1;
  inline bool has_winid() const;
  inline void clear_winid();
  static const int kWinIdFieldNumber = 1;
  inline ::google::protobuf::int32 winid() const;
  inline void set_winid(::google::protobuf::int32 value);

  // required .TvWall.Rect rect = 2;
  inline bool has_rect() const;
  inline void clear_rect();
  static const int kRectFieldNumber = 2;
  inline const ::TvWall::Rect& rect() const;
  inline ::TvWall::Rect* mutable_rect();
  inline ::TvWall::Rect* release_rect();
  inline void set_allocated_rect(::TvWall::Rect* rect);

  // required .TvWall.Packet.ElementDat.View.ViewType viewType = 3;
  inline bool has_viewtype() const;
  inline void clear_viewtype();
  static const int kViewTypeFieldNumber = 3;
  inline ::TvWall::Packet_ElementDat_View_ViewType viewtype() const;
  inline void set_viewtype(::TvWall::Packet_ElementDat_View_ViewType value);

  // optional string url = 4;
  inline bool has_url() const;
  inline void clear_url();
  static const int kUrlFieldNumber = 4;
  inline const ::std::string& url() const;
  inline void set_url(const ::std::string& value);
  inline void set_url(const char* value);
  inline void set_url(const char* value, size_t size);
  inline ::std::string* mutable_url();
  inline ::std::string* release_url();
  inline void set_allocated_url(::std::string* url);

  // repeated .TvWall.Guid cameraId = 5;
  inline int cameraid_size() const;
  inline void clear_cameraid();
  static const int kCameraIdFieldNumber = 5;
  inline const ::TvWall::Guid& cameraid(int index) const;
  inline ::TvWall::Guid* mutable_cameraid(int index);
  inline ::TvWall::Guid* add_cameraid();
  inline const ::google::protobuf::RepeatedPtrField< ::TvWall::Guid >&
      cameraid() const;
  inline ::google::protobuf::RepeatedPtrField< ::TvWall::Guid >*
      mutable_cameraid();

  // optional uint64 startTime = 6;
  inline bool has_starttime() const;
  inline void clear_starttime();
  static const int kStartTimeFieldNumber = 6;
  inline ::google::protobuf::uint64 starttime() const;
  inline void set_starttime(::google::protobuf::uint64 value);

  // optional bool keepStretch = 7;
  inline bool has_keepstretch() const;
  inline void clear_keepstretch();
  static const int kKeepStretchFieldNumber = 7;
  inline bool keepstretch() const;
  inline void set_keepstretch(bool value);

  // optional int32 borderWidth = 8;
  inline bool has_borderwidth() const;
  inline void clear_borderwidth();
  static const int kBorderWidthFieldNumber = 8;
  inline ::google::protobuf::int32 borderwidth() const;
  inline void set_borderwidth(::google::protobuf::int32 value);

  // optional bool showTitle = 9;
  inline bool has_showtitle() const;
  inline void clear_showtitle();
  static const int kShowTitleFieldNumber = 9;
  inline bool showtitle() const;
  inline void set_showtitle(bool value);

  // optional string title = 10;
  inline bool has_title() const;
  inline void clear_title();
  static const int kTitleFieldNumber = 10;
  inline const ::std::string& title() const;
  inline void set_title(const ::std::string& value);
  inline void set_title(const char* value);
  inline void set_title(const char* value, size_t size);
  inline ::std::string* mutable_title();
  inline ::std::string* release_title();
  inline void set_allocated_title(::std::string* title);

  // optional int32 pollInterval = 11;
  inline bool has_pollinterval() const;
  inline void clear_pollinterval();
  static const int kPollIntervalFieldNumber = 11;
  inline ::google::protobuf::int32 pollinterval() const;
  inline void set_pollinterval(::google::protobuf::int32 value);

  // optional int32 gpuId = 12;
  inline bool has_gpuid() const;
  inline void clear_gpuid();
  static const int kGpuIdFieldNumber = 12;
  inline ::google::protobuf::int32 gpuid() const;
  inline void set_gpuid(::google::protobuf::int32 value);

  // optional bool showFullScreen = 13;
  inline bool has_showfullscreen() const;
  inline void clear_showfullscreen();
  static const int kShowFullScreenFieldNumber = 13;
  inline bool showfullscreen() const;
  inline void set_showfullscreen(bool value);

  // optional int32 windowStack = 14;
  inline bool has_windowstack() const;
  inline void clear_windowstack();
  static const int kWindowStackFieldNumber = 14;
  inline ::google::protobuf::int32 windowstack() const;
  inline void set_windowstack(::google::protobuf::int32 value);

  // optional bool isAlarm = 15;
  inline bool has_isalarm() const;
  inline void clear_isalarm();
  static const int kIsAlarmFieldNumber = 15;
  inline bool isalarm() const;
  inline void set_isalarm(bool value);

  // optional int32 alarmInterval = 16;
  inline bool has_alarminterval() const;
  inline void clear_alarminterval();
  static const int kAlarmIntervalFieldNumber = 16;
  inline ::google::protobuf::int32 alarminterval() const;
  inline void set_alarminterval(::google::protobuf::int32 value);

  // optional bool showMaxFullScreen = 17;
  inline bool has_showmaxfullscreen() const;
  inline void clear_showmaxfullscreen();
  static const int kShowMaxFullScreenFieldNumber = 17;
  inline bool showmaxfullscreen() const;
  inline void set_showmaxfullscreen(bool value);

  // optional bool showMinFullScreen = 18;
  inline bool has_showminfullscreen() const;
  inline void clear_showminfullscreen();
  static const int kShowMinFullScreenFieldNumber = 18;
  inline bool showminfullscreen() const;
  inline void set_showminfullscreen(bool value);

  // optional .TvWall.Rect fullscreenRect = 19;
  inline bool has_fullscreenrect() const;
  inline void clear_fullscreenrect();
  static const int kFullscreenRectFieldNumber = 19;
  inline const ::TvWall::Rect& fullscreenrect() const;
  inline ::TvWall::Rect* mutable_fullscreenrect();
  inline ::TvWall::Rect* release_fullscreenrect();
  inline void set_allocated_fullscreenrect(::TvWall::Rect* fullscreenrect);

  // @@protoc_insertion_point(class_scope:TvWall.Packet.ElementDat.View)
 private:
  inline void set_has_winid();
  inline void clear_has_winid();
  inline void set_has_rect();
  inline void clear_has_rect();
  inline void set_has_viewtype();
  inline void clear_has_viewtype();
  inline void set_has_url();
  inline void clear_has_url();
  inline void set_has_starttime();
  inline void clear_has_starttime();
  inline void set_has_keepstretch();
  inline void clear_has_keepstretch();
  inline void set_has_borderwidth();
  inline void clear_has_borderwidth();
  inline void set_has_showtitle();
  inline void clear_has_showtitle();
  inline void set_has_title();
  inline void clear_has_title();
  inline void set_has_pollinterval();
  inline void clear_has_pollinterval();
  inline void set_has_gpuid();
  inline void clear_has_gpuid();
  inline void set_has_showfullscreen();
  inline void clear_has_showfullscreen();
  inline void set_has_windowstack();
  inline void clear_has_windowstack();
  inline void set_has_isalarm();
  inline void clear_has_isalarm();
  inline void set_has_alarminterval();
  inline void clear_has_alarminterval();
  inline void set_has_showmaxfullscreen();
  inline void clear_has_showmaxfullscreen();
  inline void set_has_showminfullscreen();
  inline void clear_has_showminfullscreen();
  inline void set_has_fullscreenrect();
  inline void clear_has_fullscreenrect();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TvWall::Rect* rect_;
  ::google::protobuf::int32 winid_;
  int viewtype_;
  ::std::string* url_;
  ::google::protobuf::RepeatedPtrField< ::TvWall::Guid > cameraid_;
  ::google::protobuf::uint64 starttime_;
  ::google::protobuf::int32 borderwidth_;
  ::google::protobuf::int32 pollinterval_;
  ::std::string* title_;
  bool keepstretch_;
  bool showtitle_;
  bool showfullscreen_;
  bool isalarm_;
  ::google::protobuf::int32 gpuid_;
  ::google::protobuf::int32 windowstack_;
  ::google::protobuf::int32 alarminterval_;
  ::TvWall::Rect* fullscreenrect_;
  bool showmaxfullscreen_;
  bool showminfullscreen_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(19 + 31) / 32];

  friend void  protobuf_AddDesc_protobuf_2ftvWall_2eproto();
  friend void protobuf_AssignDesc_protobuf_2ftvWall_2eproto();
  friend void protobuf_ShutdownFile_protobuf_2ftvWall_2eproto();

  void InitAsDefaultInstance();
  static Packet_ElementDat_View* default_instance_;
};
// -------------------------------------------------------------------

class Packet_ElementDat_FocusPoint : public ::google::protobuf::Message {
 public:
  Packet_ElementDat_FocusPoint();
  virtual ~Packet_ElementDat_FocusPoint();

  Packet_ElementDat_FocusPoint(const Packet_ElementDat_FocusPoint& from);

  inline Packet_ElementDat_FocusPoint& operator=(const Packet_ElementDat_FocusPoint& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Packet_ElementDat_FocusPoint& default_instance();

  void Swap(Packet_ElementDat_FocusPoint* other);

  // implements Message ----------------------------------------------

  Packet_ElementDat_FocusPoint* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Packet_ElementDat_FocusPoint& from);
  void MergeFrom(const Packet_ElementDat_FocusPoint& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:TvWall.Packet.ElementDat.FocusPoint)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_protobuf_2ftvWall_2eproto();
  friend void protobuf_AssignDesc_protobuf_2ftvWall_2eproto();
  friend void protobuf_ShutdownFile_protobuf_2ftvWall_2eproto();

  void InitAsDefaultInstance();
  static Packet_ElementDat_FocusPoint* default_instance_;
};
// -------------------------------------------------------------------

class Packet_ElementDat_HotPoint : public ::google::protobuf::Message {
 public:
  Packet_ElementDat_HotPoint();
  virtual ~Packet_ElementDat_HotPoint();

  Packet_ElementDat_HotPoint(const Packet_ElementDat_HotPoint& from);

  inline Packet_ElementDat_HotPoint& operator=(const Packet_ElementDat_HotPoint& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Packet_ElementDat_HotPoint& default_instance();

  void Swap(Packet_ElementDat_HotPoint* other);

  // implements Message ----------------------------------------------

  Packet_ElementDat_HotPoint* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Packet_ElementDat_HotPoint& from);
  void MergeFrom(const Packet_ElementDat_HotPoint& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TvWall.Rect geometry = 1;
  inline bool has_geometry() const;
  inline void clear_geometry();
  static const int kGeometryFieldNumber = 1;
  inline const ::TvWall::Rect& geometry() const;
  inline ::TvWall::Rect* mutable_geometry();
  inline ::TvWall::Rect* release_geometry();
  inline void set_allocated_geometry(::TvWall::Rect* geometry);

  // required int32 screenIndex = 3;
  inline bool has_screenindex() const;
  inline void clear_screenindex();
  static const int kScreenIndexFieldNumber = 3;
  inline ::google::protobuf::int32 screenindex() const;
  inline void set_screenindex(::google::protobuf::int32 value);

  // required bool limitedMap = 4;
  inline bool has_limitedmap() const;
  inline void clear_limitedmap();
  static const int kLimitedMapFieldNumber = 4;
  inline bool limitedmap() const;
  inline void set_limitedmap(bool value);

  // required bool limitedRecord = 5;
  inline bool has_limitedrecord() const;
  inline void clear_limitedrecord();
  static const int kLimitedRecordFieldNumber = 5;
  inline bool limitedrecord() const;
  inline void set_limitedrecord(bool value);

  // @@protoc_insertion_point(class_scope:TvWall.Packet.ElementDat.HotPoint)
 private:
  inline void set_has_geometry();
  inline void clear_has_geometry();
  inline void set_has_screenindex();
  inline void clear_has_screenindex();
  inline void set_has_limitedmap();
  inline void clear_has_limitedmap();
  inline void set_has_limitedrecord();
  inline void clear_has_limitedrecord();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TvWall::Rect* geometry_;
  ::google::protobuf::int32 screenindex_;
  bool limitedmap_;
  bool limitedrecord_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_protobuf_2ftvWall_2eproto();
  friend void protobuf_AssignDesc_protobuf_2ftvWall_2eproto();
  friend void protobuf_ShutdownFile_protobuf_2ftvWall_2eproto();

  void InitAsDefaultInstance();
  static Packet_ElementDat_HotPoint* default_instance_;
};
// -------------------------------------------------------------------

class Packet_ElementDat_ServerLayout : public ::google::protobuf::Message {
 public:
  Packet_ElementDat_ServerLayout();
  virtual ~Packet_ElementDat_ServerLayout();

  Packet_ElementDat_ServerLayout(const Packet_ElementDat_ServerLayout& from);

  inline Packet_ElementDat_ServerLayout& operator=(const Packet_ElementDat_ServerLayout& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Packet_ElementDat_ServerLayout& default_instance();

  void Swap(Packet_ElementDat_ServerLayout* other);

  // implements Message ----------------------------------------------

  Packet_ElementDat_ServerLayout* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Packet_ElementDat_ServerLayout& from);
  void MergeFrom(const Packet_ElementDat_ServerLayout& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required .TvWall.Packet.ElementDat layoutDat = 2;
  inline bool has_layoutdat() const;
  inline void clear_layoutdat();
  static const int kLayoutDatFieldNumber = 2;
  inline const ::TvWall::Packet_ElementDat& layoutdat() const;
  inline ::TvWall::Packet_ElementDat* mutable_layoutdat();
  inline ::TvWall::Packet_ElementDat* release_layoutdat();
  inline void set_allocated_layoutdat(::TvWall::Packet_ElementDat* layoutdat);

  // @@protoc_insertion_point(class_scope:TvWall.Packet.ElementDat.ServerLayout)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_layoutdat();
  inline void clear_has_layoutdat();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::TvWall::Packet_ElementDat* layoutdat_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_protobuf_2ftvWall_2eproto();
  friend void protobuf_AssignDesc_protobuf_2ftvWall_2eproto();
  friend void protobuf_ShutdownFile_protobuf_2ftvWall_2eproto();

  void InitAsDefaultInstance();
  static Packet_ElementDat_ServerLayout* default_instance_;
};
// -------------------------------------------------------------------

class Packet_ElementDat_ServerLayoutLoop : public ::google::protobuf::Message {
 public:
  Packet_ElementDat_ServerLayoutLoop();
  virtual ~Packet_ElementDat_ServerLayoutLoop();

  Packet_ElementDat_ServerLayoutLoop(const Packet_ElementDat_ServerLayoutLoop& from);

  inline Packet_ElementDat_ServerLayoutLoop& operator=(const Packet_ElementDat_ServerLayoutLoop& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Packet_ElementDat_ServerLayoutLoop& default_instance();

  void Swap(Packet_ElementDat_ServerLayoutLoop* other);

  // implements Message ----------------------------------------------

  Packet_ElementDat_ServerLayoutLoop* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Packet_ElementDat_ServerLayoutLoop& from);
  void MergeFrom(const Packet_ElementDat_ServerLayoutLoop& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required uint32 pollInterval = 2;
  inline bool has_pollinterval() const;
  inline void clear_pollinterval();
  static const int kPollIntervalFieldNumber = 2;
  inline ::google::protobuf::uint32 pollinterval() const;
  inline void set_pollinterval(::google::protobuf::uint32 value);

  // repeated string layoutName = 3;
  inline int layoutname_size() const;
  inline void clear_layoutname();
  static const int kLayoutNameFieldNumber = 3;
  inline const ::std::string& layoutname(int index) const;
  inline ::std::string* mutable_layoutname(int index);
  inline void set_layoutname(int index, const ::std::string& value);
  inline void set_layoutname(int index, const char* value);
  inline void set_layoutname(int index, const char* value, size_t size);
  inline ::std::string* add_layoutname();
  inline void add_layoutname(const ::std::string& value);
  inline void add_layoutname(const char* value);
  inline void add_layoutname(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& layoutname() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_layoutname();

  // @@protoc_insertion_point(class_scope:TvWall.Packet.ElementDat.ServerLayoutLoop)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_pollinterval();
  inline void clear_has_pollinterval();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::google::protobuf::RepeatedPtrField< ::std::string> layoutname_;
  ::google::protobuf::uint32 pollinterval_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_protobuf_2ftvWall_2eproto();
  friend void protobuf_AssignDesc_protobuf_2ftvWall_2eproto();
  friend void protobuf_ShutdownFile_protobuf_2ftvWall_2eproto();

  void InitAsDefaultInstance();
  static Packet_ElementDat_ServerLayoutLoop* default_instance_;
};
// -------------------------------------------------------------------

class Packet_ElementDat_Map : public ::google::protobuf::Message {
 public:
  Packet_ElementDat_Map();
  virtual ~Packet_ElementDat_Map();

  Packet_ElementDat_Map(const Packet_ElementDat_Map& from);

  inline Packet_ElementDat_Map& operator=(const Packet_ElementDat_Map& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Packet_ElementDat_Map& default_instance();

  void Swap(Packet_ElementDat_Map* other);

  // implements Message ----------------------------------------------

  Packet_ElementDat_Map* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Packet_ElementDat_Map& from);
  void MergeFrom(const Packet_ElementDat_Map& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string mapUrl = 1;
  inline bool has_mapurl() const;
  inline void clear_mapurl();
  static const int kMapUrlFieldNumber = 1;
  inline const ::std::string& mapurl() const;
  inline void set_mapurl(const ::std::string& value);
  inline void set_mapurl(const char* value);
  inline void set_mapurl(const char* value, size_t size);
  inline ::std::string* mutable_mapurl();
  inline ::std::string* release_mapurl();
  inline void set_allocated_mapurl(::std::string* mapurl);

  // repeated .TvWall.Packet.ElementDat.Map map = 2;
  inline int map_size() const;
  inline void clear_map();
  static const int kMapFieldNumber = 2;
  inline const ::TvWall::Packet_ElementDat_Map& map(int index) const;
  inline ::TvWall::Packet_ElementDat_Map* mutable_map(int index);
  inline ::TvWall::Packet_ElementDat_Map* add_map();
  inline const ::google::protobuf::RepeatedPtrField< ::TvWall::Packet_ElementDat_Map >&
      map() const;
  inline ::google::protobuf::RepeatedPtrField< ::TvWall::Packet_ElementDat_Map >*
      mutable_map();

  // @@protoc_insertion_point(class_scope:TvWall.Packet.ElementDat.Map)
 private:
  inline void set_has_mapurl();
  inline void clear_has_mapurl();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* mapurl_;
  ::google::protobuf::RepeatedPtrField< ::TvWall::Packet_ElementDat_Map > map_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_protobuf_2ftvWall_2eproto();
  friend void protobuf_AssignDesc_protobuf_2ftvWall_2eproto();
  friend void protobuf_ShutdownFile_protobuf_2ftvWall_2eproto();

  void InitAsDefaultInstance();
  static Packet_ElementDat_Map* default_instance_;
};
// -------------------------------------------------------------------

class Packet_ElementDat_GroupLoop : public ::google::protobuf::Message {
 public:
  Packet_ElementDat_GroupLoop();
  virtual ~Packet_ElementDat_GroupLoop();

  Packet_ElementDat_GroupLoop(const Packet_ElementDat_GroupLoop& from);

  inline Packet_ElementDat_GroupLoop& operator=(const Packet_ElementDat_GroupLoop& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Packet_ElementDat_GroupLoop& default_instance();

  void Swap(Packet_ElementDat_GroupLoop* other);

  // implements Message ----------------------------------------------

  Packet_ElementDat_GroupLoop* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Packet_ElementDat_GroupLoop& from);
  void MergeFrom(const Packet_ElementDat_GroupLoop& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .TvWall.Packet.ElementDat.View views = 1;
  inline int views_size() const;
  inline void clear_views();
  static const int kViewsFieldNumber = 1;
  inline const ::TvWall::Packet_ElementDat_View& views(int index) const;
  inline ::TvWall::Packet_ElementDat_View* mutable_views(int index);
  inline ::TvWall::Packet_ElementDat_View* add_views();
  inline const ::google::protobuf::RepeatedPtrField< ::TvWall::Packet_ElementDat_View >&
      views() const;
  inline ::google::protobuf::RepeatedPtrField< ::TvWall::Packet_ElementDat_View >*
      mutable_views();

  // required uint32 pollInterval = 2;
  inline bool has_pollinterval() const;
  inline void clear_pollinterval();
  static const int kPollIntervalFieldNumber = 2;
  inline ::google::protobuf::uint32 pollinterval() const;
  inline void set_pollinterval(::google::protobuf::uint32 value);

  // optional bool isOn = 3;
  inline bool has_ison() const;
  inline void clear_ison();
  static const int kIsOnFieldNumber = 3;
  inline bool ison() const;
  inline void set_ison(bool value);

  // @@protoc_insertion_point(class_scope:TvWall.Packet.ElementDat.GroupLoop)
 private:
  inline void set_has_pollinterval();
  inline void clear_has_pollinterval();
  inline void set_has_ison();
  inline void clear_has_ison();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::TvWall::Packet_ElementDat_View > views_;
  ::google::protobuf::uint32 pollinterval_;
  bool ison_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_protobuf_2ftvWall_2eproto();
  friend void protobuf_AssignDesc_protobuf_2ftvWall_2eproto();
  friend void protobuf_ShutdownFile_protobuf_2ftvWall_2eproto();

  void InitAsDefaultInstance();
  static Packet_ElementDat_GroupLoop* default_instance_;
};
// -------------------------------------------------------------------

class Packet_ElementDat : public ::google::protobuf::Message {
 public:
  Packet_ElementDat();
  virtual ~Packet_ElementDat();

  Packet_ElementDat(const Packet_ElementDat& from);

  inline Packet_ElementDat& operator=(const Packet_ElementDat& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Packet_ElementDat& default_instance();

  void Swap(Packet_ElementDat* other);

  // implements Message ----------------------------------------------

  Packet_ElementDat* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Packet_ElementDat& from);
  void MergeFrom(const Packet_ElementDat& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Packet_ElementDat_Screen Screen;
  typedef Packet_ElementDat_Camera Camera;
  typedef Packet_ElementDat_CameraGrp CameraGrp;
  typedef Packet_ElementDat_LocalMovie LocalMovie;
  typedef Packet_ElementDat_Flash Flash;
  typedef Packet_ElementDat_View View;
  typedef Packet_ElementDat_FocusPoint FocusPoint;
  typedef Packet_ElementDat_HotPoint HotPoint;
  typedef Packet_ElementDat_ServerLayout ServerLayout;
  typedef Packet_ElementDat_ServerLayoutLoop ServerLayoutLoop;
  typedef Packet_ElementDat_Map Map;
  typedef Packet_ElementDat_GroupLoop GroupLoop;

  // accessors -------------------------------------------------------

  // repeated .TvWall.Packet.ElementDat.Screen screen = 1;
  inline int screen_size() const;
  inline void clear_screen();
  static const int kScreenFieldNumber = 1;
  inline const ::TvWall::Packet_ElementDat_Screen& screen(int index) const;
  inline ::TvWall::Packet_ElementDat_Screen* mutable_screen(int index);
  inline ::TvWall::Packet_ElementDat_Screen* add_screen();
  inline const ::google::protobuf::RepeatedPtrField< ::TvWall::Packet_ElementDat_Screen >&
      screen() const;
  inline ::google::protobuf::RepeatedPtrField< ::TvWall::Packet_ElementDat_Screen >*
      mutable_screen();

  // repeated .TvWall.Packet.ElementDat.View view = 2;
  inline int view_size() const;
  inline void clear_view();
  static const int kViewFieldNumber = 2;
  inline const ::TvWall::Packet_ElementDat_View& view(int index) const;
  inline ::TvWall::Packet_ElementDat_View* mutable_view(int index);
  inline ::TvWall::Packet_ElementDat_View* add_view();
  inline const ::google::protobuf::RepeatedPtrField< ::TvWall::Packet_ElementDat_View >&
      view() const;
  inline ::google::protobuf::RepeatedPtrField< ::TvWall::Packet_ElementDat_View >*
      mutable_view();

  // repeated .TvWall.Packet.ElementDat.CameraGrp camGrp = 3;
  inline int camgrp_size() const;
  inline void clear_camgrp();
  static const int kCamGrpFieldNumber = 3;
  inline const ::TvWall::Packet_ElementDat_CameraGrp& camgrp(int index) const;
  inline ::TvWall::Packet_ElementDat_CameraGrp* mutable_camgrp(int index);
  inline ::TvWall::Packet_ElementDat_CameraGrp* add_camgrp();
  inline const ::google::protobuf::RepeatedPtrField< ::TvWall::Packet_ElementDat_CameraGrp >&
      camgrp() const;
  inline ::google::protobuf::RepeatedPtrField< ::TvWall::Packet_ElementDat_CameraGrp >*
      mutable_camgrp();

  // optional .TvWall.Packet.ElementDat.HotPoint hotPoint = 4;
  inline bool has_hotpoint() const;
  inline void clear_hotpoint();
  static const int kHotPointFieldNumber = 4;
  inline const ::TvWall::Packet_ElementDat_HotPoint& hotpoint() const;
  inline ::TvWall::Packet_ElementDat_HotPoint* mutable_hotpoint();
  inline ::TvWall::Packet_ElementDat_HotPoint* release_hotpoint();
  inline void set_allocated_hotpoint(::TvWall::Packet_ElementDat_HotPoint* hotpoint);

  // repeated .TvWall.Packet.ElementDat.LocalMovie localMovie = 5;
  inline int localmovie_size() const;
  inline void clear_localmovie();
  static const int kLocalMovieFieldNumber = 5;
  inline const ::TvWall::Packet_ElementDat_LocalMovie& localmovie(int index) const;
  inline ::TvWall::Packet_ElementDat_LocalMovie* mutable_localmovie(int index);
  inline ::TvWall::Packet_ElementDat_LocalMovie* add_localmovie();
  inline const ::google::protobuf::RepeatedPtrField< ::TvWall::Packet_ElementDat_LocalMovie >&
      localmovie() const;
  inline ::google::protobuf::RepeatedPtrField< ::TvWall::Packet_ElementDat_LocalMovie >*
      mutable_localmovie();

  // repeated .TvWall.Packet.ElementDat.Flash flash = 6;
  inline int flash_size() const;
  inline void clear_flash();
  static const int kFlashFieldNumber = 6;
  inline const ::TvWall::Packet_ElementDat_Flash& flash(int index) const;
  inline ::TvWall::Packet_ElementDat_Flash* mutable_flash(int index);
  inline ::TvWall::Packet_ElementDat_Flash* add_flash();
  inline const ::google::protobuf::RepeatedPtrField< ::TvWall::Packet_ElementDat_Flash >&
      flash() const;
  inline ::google::protobuf::RepeatedPtrField< ::TvWall::Packet_ElementDat_Flash >*
      mutable_flash();

  // required string serverName = 7;
  inline bool has_servername() const;
  inline void clear_servername();
  static const int kServerNameFieldNumber = 7;
  inline const ::std::string& servername() const;
  inline void set_servername(const ::std::string& value);
  inline void set_servername(const char* value);
  inline void set_servername(const char* value, size_t size);
  inline ::std::string* mutable_servername();
  inline ::std::string* release_servername();
  inline void set_allocated_servername(::std::string* servername);

  // repeated .TvWall.Packet.ElementDat.ServerLayout servLayout = 8;
  inline int servlayout_size() const;
  inline void clear_servlayout();
  static const int kServLayoutFieldNumber = 8;
  inline const ::TvWall::Packet_ElementDat_ServerLayout& servlayout(int index) const;
  inline ::TvWall::Packet_ElementDat_ServerLayout* mutable_servlayout(int index);
  inline ::TvWall::Packet_ElementDat_ServerLayout* add_servlayout();
  inline const ::google::protobuf::RepeatedPtrField< ::TvWall::Packet_ElementDat_ServerLayout >&
      servlayout() const;
  inline ::google::protobuf::RepeatedPtrField< ::TvWall::Packet_ElementDat_ServerLayout >*
      mutable_servlayout();

  // optional .TvWall.Guid guid = 9;
  inline bool has_guid() const;
  inline void clear_guid();
  static const int kGuidFieldNumber = 9;
  inline const ::TvWall::Guid& guid() const;
  inline ::TvWall::Guid* mutable_guid();
  inline ::TvWall::Guid* release_guid();
  inline void set_allocated_guid(::TvWall::Guid* guid);

  // repeated .TvWall.Packet.ElementDat.Map map = 10;
  inline int map_size() const;
  inline void clear_map();
  static const int kMapFieldNumber = 10;
  inline const ::TvWall::Packet_ElementDat_Map& map(int index) const;
  inline ::TvWall::Packet_ElementDat_Map* mutable_map(int index);
  inline ::TvWall::Packet_ElementDat_Map* add_map();
  inline const ::google::protobuf::RepeatedPtrField< ::TvWall::Packet_ElementDat_Map >&
      map() const;
  inline ::google::protobuf::RepeatedPtrField< ::TvWall::Packet_ElementDat_Map >*
      mutable_map();

  // optional string currentLayout = 11;
  inline bool has_currentlayout() const;
  inline void clear_currentlayout();
  static const int kCurrentLayoutFieldNumber = 11;
  inline const ::std::string& currentlayout() const;
  inline void set_currentlayout(const ::std::string& value);
  inline void set_currentlayout(const char* value);
  inline void set_currentlayout(const char* value, size_t size);
  inline ::std::string* mutable_currentlayout();
  inline ::std::string* release_currentlayout();
  inline void set_allocated_currentlayout(::std::string* currentlayout);

  // repeated .TvWall.Packet.ElementDat.ServerLayoutLoop servLayoutLoop = 12;
  inline int servlayoutloop_size() const;
  inline void clear_servlayoutloop();
  static const int kServLayoutLoopFieldNumber = 12;
  inline const ::TvWall::Packet_ElementDat_ServerLayoutLoop& servlayoutloop(int index) const;
  inline ::TvWall::Packet_ElementDat_ServerLayoutLoop* mutable_servlayoutloop(int index);
  inline ::TvWall::Packet_ElementDat_ServerLayoutLoop* add_servlayoutloop();
  inline const ::google::protobuf::RepeatedPtrField< ::TvWall::Packet_ElementDat_ServerLayoutLoop >&
      servlayoutloop() const;
  inline ::google::protobuf::RepeatedPtrField< ::TvWall::Packet_ElementDat_ServerLayoutLoop >*
      mutable_servlayoutloop();

  // optional string currentLayoutLoop = 13;
  inline bool has_currentlayoutloop() const;
  inline void clear_currentlayoutloop();
  static const int kCurrentLayoutLoopFieldNumber = 13;
  inline const ::std::string& currentlayoutloop() const;
  inline void set_currentlayoutloop(const ::std::string& value);
  inline void set_currentlayoutloop(const char* value);
  inline void set_currentlayoutloop(const char* value, size_t size);
  inline ::std::string* mutable_currentlayoutloop();
  inline ::std::string* release_currentlayoutloop();
  inline void set_allocated_currentlayoutloop(::std::string* currentlayoutloop);

  // repeated .TvWall.NVR nvrLst = 14;
  inline int nvrlst_size() const;
  inline void clear_nvrlst();
  static const int kNvrLstFieldNumber = 14;
  inline const ::TvWall::NVR& nvrlst(int index) const;
  inline ::TvWall::NVR* mutable_nvrlst(int index);
  inline ::TvWall::NVR* add_nvrlst();
  inline const ::google::protobuf::RepeatedPtrField< ::TvWall::NVR >&
      nvrlst() const;
  inline ::google::protobuf::RepeatedPtrField< ::TvWall::NVR >*
      mutable_nvrlst();

  // optional .TvWall.Packet.ElementDat.GroupLoop groupLoop = 15;
  inline bool has_grouploop() const;
  inline void clear_grouploop();
  static const int kGroupLoopFieldNumber = 15;
  inline const ::TvWall::Packet_ElementDat_GroupLoop& grouploop() const;
  inline ::TvWall::Packet_ElementDat_GroupLoop* mutable_grouploop();
  inline ::TvWall::Packet_ElementDat_GroupLoop* release_grouploop();
  inline void set_allocated_grouploop(::TvWall::Packet_ElementDat_GroupLoop* grouploop);

  // optional uint32 maxPlaybackRate = 16;
  inline bool has_maxplaybackrate() const;
  inline void clear_maxplaybackrate();
  static const int kMaxPlaybackRateFieldNumber = 16;
  inline ::google::protobuf::uint32 maxplaybackrate() const;
  inline void set_maxplaybackrate(::google::protobuf::uint32 value);

  // optional .TvWall.FMP fmp = 17;
  inline bool has_fmp() const;
  inline void clear_fmp();
  static const int kFmpFieldNumber = 17;
  inline const ::TvWall::FMP& fmp() const;
  inline ::TvWall::FMP* mutable_fmp();
  inline ::TvWall::FMP* release_fmp();
  inline void set_allocated_fmp(::TvWall::FMP* fmp);

  // optional int32 tvwallindex = 18;
  inline bool has_tvwallindex() const;
  inline void clear_tvwallindex();
  static const int kTvwallindexFieldNumber = 18;
  inline ::google::protobuf::int32 tvwallindex() const;
  inline void set_tvwallindex(::google::protobuf::int32 value);

  // optional string anoleVersion = 19;
  inline bool has_anoleversion() const;
  inline void clear_anoleversion();
  static const int kAnoleVersionFieldNumber = 19;
  inline const ::std::string& anoleversion() const;
  inline void set_anoleversion(const ::std::string& value);
  inline void set_anoleversion(const char* value);
  inline void set_anoleversion(const char* value, size_t size);
  inline ::std::string* mutable_anoleversion();
  inline ::std::string* release_anoleversion();
  inline void set_allocated_anoleversion(::std::string* anoleversion);

  // optional string SN = 20;
  inline bool has_sn() const;
  inline void clear_sn();
  static const int kSNFieldNumber = 20;
  inline const ::std::string& sn() const;
  inline void set_sn(const ::std::string& value);
  inline void set_sn(const char* value);
  inline void set_sn(const char* value, size_t size);
  inline ::std::string* mutable_sn();
  inline ::std::string* release_sn();
  inline void set_allocated_sn(::std::string* sn);

  // @@protoc_insertion_point(class_scope:TvWall.Packet.ElementDat)
 private:
  inline void set_has_hotpoint();
  inline void clear_has_hotpoint();
  inline void set_has_servername();
  inline void clear_has_servername();
  inline void set_has_guid();
  inline void clear_has_guid();
  inline void set_has_currentlayout();
  inline void clear_has_currentlayout();
  inline void set_has_currentlayoutloop();
  inline void clear_has_currentlayoutloop();
  inline void set_has_grouploop();
  inline void clear_has_grouploop();
  inline void set_has_maxplaybackrate();
  inline void clear_has_maxplaybackrate();
  inline void set_has_fmp();
  inline void clear_has_fmp();
  inline void set_has_tvwallindex();
  inline void clear_has_tvwallindex();
  inline void set_has_anoleversion();
  inline void clear_has_anoleversion();
  inline void set_has_sn();
  inline void clear_has_sn();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::TvWall::Packet_ElementDat_Screen > screen_;
  ::google::protobuf::RepeatedPtrField< ::TvWall::Packet_ElementDat_View > view_;
  ::google::protobuf::RepeatedPtrField< ::TvWall::Packet_ElementDat_CameraGrp > camgrp_;
  ::TvWall::Packet_ElementDat_HotPoint* hotpoint_;
  ::google::protobuf::RepeatedPtrField< ::TvWall::Packet_ElementDat_LocalMovie > localmovie_;
  ::google::protobuf::RepeatedPtrField< ::TvWall::Packet_ElementDat_Flash > flash_;
  ::std::string* servername_;
  ::google::protobuf::RepeatedPtrField< ::TvWall::Packet_ElementDat_ServerLayout > servlayout_;
  ::TvWall::Guid* guid_;
  ::google::protobuf::RepeatedPtrField< ::TvWall::Packet_ElementDat_Map > map_;
  ::std::string* currentlayout_;
  ::google::protobuf::RepeatedPtrField< ::TvWall::Packet_ElementDat_ServerLayoutLoop > servlayoutloop_;
  ::std::string* currentlayoutloop_;
  ::google::protobuf::RepeatedPtrField< ::TvWall::NVR > nvrlst_;
  ::TvWall::Packet_ElementDat_GroupLoop* grouploop_;
  ::TvWall::FMP* fmp_;
  ::google::protobuf::uint32 maxplaybackrate_;
  ::google::protobuf::int32 tvwallindex_;
  ::std::string* anoleversion_;
  ::std::string* sn_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(20 + 31) / 32];

  friend void  protobuf_AddDesc_protobuf_2ftvWall_2eproto();
  friend void protobuf_AssignDesc_protobuf_2ftvWall_2eproto();
  friend void protobuf_ShutdownFile_protobuf_2ftvWall_2eproto();

  void InitAsDefaultInstance();
  static Packet_ElementDat* default_instance_;
};
// -------------------------------------------------------------------

class Packet_ElementMaster_MasterLayout_ServerPos : public ::google::protobuf::Message {
 public:
  Packet_ElementMaster_MasterLayout_ServerPos();
  virtual ~Packet_ElementMaster_MasterLayout_ServerPos();

  Packet_ElementMaster_MasterLayout_ServerPos(const Packet_ElementMaster_MasterLayout_ServerPos& from);

  inline Packet_ElementMaster_MasterLayout_ServerPos& operator=(const Packet_ElementMaster_MasterLayout_ServerPos& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Packet_ElementMaster_MasterLayout_ServerPos& default_instance();

  void Swap(Packet_ElementMaster_MasterLayout_ServerPos* other);

  // implements Message ----------------------------------------------

  Packet_ElementMaster_MasterLayout_ServerPos* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Packet_ElementMaster_MasterLayout_ServerPos& from);
  void MergeFrom(const Packet_ElementMaster_MasterLayout_ServerPos& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string serverName = 1;
  inline bool has_servername() const;
  inline void clear_servername();
  static const int kServerNameFieldNumber = 1;
  inline const ::std::string& servername() const;
  inline void set_servername(const ::std::string& value);
  inline void set_servername(const char* value);
  inline void set_servername(const char* value, size_t size);
  inline ::std::string* mutable_servername();
  inline ::std::string* release_servername();
  inline void set_allocated_servername(::std::string* servername);

  // required .TvWall.Guid guid = 2;
  inline bool has_guid() const;
  inline void clear_guid();
  static const int kGuidFieldNumber = 2;
  inline const ::TvWall::Guid& guid() const;
  inline ::TvWall::Guid* mutable_guid();
  inline ::TvWall::Guid* release_guid();
  inline void set_allocated_guid(::TvWall::Guid* guid);

  // required .TvWall.Point point = 3;
  inline bool has_point() const;
  inline void clear_point();
  static const int kPointFieldNumber = 3;
  inline const ::TvWall::Point& point() const;
  inline ::TvWall::Point* mutable_point();
  inline ::TvWall::Point* release_point();
  inline void set_allocated_point(::TvWall::Point* point);

  // @@protoc_insertion_point(class_scope:TvWall.Packet.ElementMaster.MasterLayout.ServerPos)
 private:
  inline void set_has_servername();
  inline void clear_has_servername();
  inline void set_has_guid();
  inline void clear_has_guid();
  inline void set_has_point();
  inline void clear_has_point();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* servername_;
  ::TvWall::Guid* guid_;
  ::TvWall::Point* point_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_protobuf_2ftvWall_2eproto();
  friend void protobuf_AssignDesc_protobuf_2ftvWall_2eproto();
  friend void protobuf_ShutdownFile_protobuf_2ftvWall_2eproto();

  void InitAsDefaultInstance();
  static Packet_ElementMaster_MasterLayout_ServerPos* default_instance_;
};
// -------------------------------------------------------------------

class Packet_ElementMaster_MasterLayout_MasLayout : public ::google::protobuf::Message {
 public:
  Packet_ElementMaster_MasterLayout_MasLayout();
  virtual ~Packet_ElementMaster_MasterLayout_MasLayout();

  Packet_ElementMaster_MasterLayout_MasLayout(const Packet_ElementMaster_MasterLayout_MasLayout& from);

  inline Packet_ElementMaster_MasterLayout_MasLayout& operator=(const Packet_ElementMaster_MasterLayout_MasLayout& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Packet_ElementMaster_MasterLayout_MasLayout& default_instance();

  void Swap(Packet_ElementMaster_MasterLayout_MasLayout* other);

  // implements Message ----------------------------------------------

  Packet_ElementMaster_MasterLayout_MasLayout* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Packet_ElementMaster_MasterLayout_MasLayout& from);
  void MergeFrom(const Packet_ElementMaster_MasterLayout_MasLayout& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string lyoutName = 1;
  inline bool has_lyoutname() const;
  inline void clear_lyoutname();
  static const int kLyoutNameFieldNumber = 1;
  inline const ::std::string& lyoutname() const;
  inline void set_lyoutname(const ::std::string& value);
  inline void set_lyoutname(const char* value);
  inline void set_lyoutname(const char* value, size_t size);
  inline ::std::string* mutable_lyoutname();
  inline ::std::string* release_lyoutname();
  inline void set_allocated_lyoutname(::std::string* lyoutname);

  // repeated .TvWall.Packet.ElementMaster.MasterLayout.ServerPos sp = 2;
  inline int sp_size() const;
  inline void clear_sp();
  static const int kSpFieldNumber = 2;
  inline const ::TvWall::Packet_ElementMaster_MasterLayout_ServerPos& sp(int index) const;
  inline ::TvWall::Packet_ElementMaster_MasterLayout_ServerPos* mutable_sp(int index);
  inline ::TvWall::Packet_ElementMaster_MasterLayout_ServerPos* add_sp();
  inline const ::google::protobuf::RepeatedPtrField< ::TvWall::Packet_ElementMaster_MasterLayout_ServerPos >&
      sp() const;
  inline ::google::protobuf::RepeatedPtrField< ::TvWall::Packet_ElementMaster_MasterLayout_ServerPos >*
      mutable_sp();

  // repeated string serverln = 3;
  inline int serverln_size() const;
  inline void clear_serverln();
  static const int kServerlnFieldNumber = 3;
  inline const ::std::string& serverln(int index) const;
  inline ::std::string* mutable_serverln(int index);
  inline void set_serverln(int index, const ::std::string& value);
  inline void set_serverln(int index, const char* value);
  inline void set_serverln(int index, const char* value, size_t size);
  inline ::std::string* add_serverln();
  inline void add_serverln(const ::std::string& value);
  inline void add_serverln(const char* value);
  inline void add_serverln(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& serverln() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_serverln();

  // @@protoc_insertion_point(class_scope:TvWall.Packet.ElementMaster.MasterLayout.MasLayout)
 private:
  inline void set_has_lyoutname();
  inline void clear_has_lyoutname();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* lyoutname_;
  ::google::protobuf::RepeatedPtrField< ::TvWall::Packet_ElementMaster_MasterLayout_ServerPos > sp_;
  ::google::protobuf::RepeatedPtrField< ::std::string> serverln_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_protobuf_2ftvWall_2eproto();
  friend void protobuf_AssignDesc_protobuf_2ftvWall_2eproto();
  friend void protobuf_ShutdownFile_protobuf_2ftvWall_2eproto();

  void InitAsDefaultInstance();
  static Packet_ElementMaster_MasterLayout_MasLayout* default_instance_;
};
// -------------------------------------------------------------------

class Packet_ElementMaster_MasterLayout : public ::google::protobuf::Message {
 public:
  Packet_ElementMaster_MasterLayout();
  virtual ~Packet_ElementMaster_MasterLayout();

  Packet_ElementMaster_MasterLayout(const Packet_ElementMaster_MasterLayout& from);

  inline Packet_ElementMaster_MasterLayout& operator=(const Packet_ElementMaster_MasterLayout& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Packet_ElementMaster_MasterLayout& default_instance();

  void Swap(Packet_ElementMaster_MasterLayout* other);

  // implements Message ----------------------------------------------

  Packet_ElementMaster_MasterLayout* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Packet_ElementMaster_MasterLayout& from);
  void MergeFrom(const Packet_ElementMaster_MasterLayout& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Packet_ElementMaster_MasterLayout_ServerPos ServerPos;
  typedef Packet_ElementMaster_MasterLayout_MasLayout MasLayout;

  // accessors -------------------------------------------------------

  // repeated .TvWall.Packet.ElementMaster.MasterLayout.MasLayout masterLayout = 1;
  inline int masterlayout_size() const;
  inline void clear_masterlayout();
  static const int kMasterLayoutFieldNumber = 1;
  inline const ::TvWall::Packet_ElementMaster_MasterLayout_MasLayout& masterlayout(int index) const;
  inline ::TvWall::Packet_ElementMaster_MasterLayout_MasLayout* mutable_masterlayout(int index);
  inline ::TvWall::Packet_ElementMaster_MasterLayout_MasLayout* add_masterlayout();
  inline const ::google::protobuf::RepeatedPtrField< ::TvWall::Packet_ElementMaster_MasterLayout_MasLayout >&
      masterlayout() const;
  inline ::google::protobuf::RepeatedPtrField< ::TvWall::Packet_ElementMaster_MasterLayout_MasLayout >*
      mutable_masterlayout();

  // @@protoc_insertion_point(class_scope:TvWall.Packet.ElementMaster.MasterLayout)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::TvWall::Packet_ElementMaster_MasterLayout_MasLayout > masterlayout_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_protobuf_2ftvWall_2eproto();
  friend void protobuf_AssignDesc_protobuf_2ftvWall_2eproto();
  friend void protobuf_ShutdownFile_protobuf_2ftvWall_2eproto();

  void InitAsDefaultInstance();
  static Packet_ElementMaster_MasterLayout* default_instance_;
};
// -------------------------------------------------------------------

class Packet_ElementMaster : public ::google::protobuf::Message {
 public:
  Packet_ElementMaster();
  virtual ~Packet_ElementMaster();

  Packet_ElementMaster(const Packet_ElementMaster& from);

  inline Packet_ElementMaster& operator=(const Packet_ElementMaster& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Packet_ElementMaster& default_instance();

  void Swap(Packet_ElementMaster* other);

  // implements Message ----------------------------------------------

  Packet_ElementMaster* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Packet_ElementMaster& from);
  void MergeFrom(const Packet_ElementMaster& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Packet_ElementMaster_MasterLayout MasterLayout;

  // accessors -------------------------------------------------------

  // required int32 token = 1;
  inline bool has_token() const;
  inline void clear_token();
  static const int kTokenFieldNumber = 1;
  inline ::google::protobuf::int32 token() const;
  inline void set_token(::google::protobuf::int32 value);

  // repeated .TvWall.Packet.Session.LoginMasterAck.Server ser = 2;
  inline int ser_size() const;
  inline void clear_ser();
  static const int kSerFieldNumber = 2;
  inline const ::TvWall::Packet_Session_LoginMasterAck_Server& ser(int index) const;
  inline ::TvWall::Packet_Session_LoginMasterAck_Server* mutable_ser(int index);
  inline ::TvWall::Packet_Session_LoginMasterAck_Server* add_ser();
  inline const ::google::protobuf::RepeatedPtrField< ::TvWall::Packet_Session_LoginMasterAck_Server >&
      ser() const;
  inline ::google::protobuf::RepeatedPtrField< ::TvWall::Packet_Session_LoginMasterAck_Server >*
      mutable_ser();

  // required .TvWall.Packet.ElementMaster.MasterLayout masterlyout = 3;
  inline bool has_masterlyout() const;
  inline void clear_masterlyout();
  static const int kMasterlyoutFieldNumber = 3;
  inline const ::TvWall::Packet_ElementMaster_MasterLayout& masterlyout() const;
  inline ::TvWall::Packet_ElementMaster_MasterLayout* mutable_masterlyout();
  inline ::TvWall::Packet_ElementMaster_MasterLayout* release_masterlyout();
  inline void set_allocated_masterlyout(::TvWall::Packet_ElementMaster_MasterLayout* masterlyout);

  // @@protoc_insertion_point(class_scope:TvWall.Packet.ElementMaster)
 private:
  inline void set_has_token();
  inline void clear_has_token();
  inline void set_has_masterlyout();
  inline void clear_has_masterlyout();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::TvWall::Packet_Session_LoginMasterAck_Server > ser_;
  ::TvWall::Packet_ElementMaster_MasterLayout* masterlyout_;
  ::google::protobuf::int32 token_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_protobuf_2ftvWall_2eproto();
  friend void protobuf_AssignDesc_protobuf_2ftvWall_2eproto();
  friend void protobuf_ShutdownFile_protobuf_2ftvWall_2eproto();

  void InitAsDefaultInstance();
  static Packet_ElementMaster* default_instance_;
};
// -------------------------------------------------------------------

class Packet_Ctrl_ScreenSplitCtrl : public ::google::protobuf::Message {
 public:
  Packet_Ctrl_ScreenSplitCtrl();
  virtual ~Packet_Ctrl_ScreenSplitCtrl();

  Packet_Ctrl_ScreenSplitCtrl(const Packet_Ctrl_ScreenSplitCtrl& from);

  inline Packet_Ctrl_ScreenSplitCtrl& operator=(const Packet_Ctrl_ScreenSplitCtrl& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Packet_Ctrl_ScreenSplitCtrl& default_instance();

  void Swap(Packet_Ctrl_ScreenSplitCtrl* other);

  // implements Message ----------------------------------------------

  Packet_Ctrl_ScreenSplitCtrl* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Packet_Ctrl_ScreenSplitCtrl& from);
  void MergeFrom(const Packet_Ctrl_ScreenSplitCtrl& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 screenIndex = 2;
  inline bool has_screenindex() const;
  inline void clear_screenindex();
  static const int kScreenIndexFieldNumber = 2;
  inline ::google::protobuf::int32 screenindex() const;
  inline void set_screenindex(::google::protobuf::int32 value);

  // required int32 row = 3 [default = 1];
  inline bool has_row() const;
  inline void clear_row();
  static const int kRowFieldNumber = 3;
  inline ::google::protobuf::int32 row() const;
  inline void set_row(::google::protobuf::int32 value);

  // required int32 col = 4 [default = 1];
  inline bool has_col() const;
  inline void clear_col();
  static const int kColFieldNumber = 4;
  inline ::google::protobuf::int32 col() const;
  inline void set_col(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:TvWall.Packet.Ctrl.ScreenSplitCtrl)
 private:
  inline void set_has_screenindex();
  inline void clear_has_screenindex();
  inline void set_has_row();
  inline void clear_has_row();
  inline void set_has_col();
  inline void clear_has_col();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 screenindex_;
  ::google::protobuf::int32 row_;
  ::google::protobuf::int32 col_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_protobuf_2ftvWall_2eproto();
  friend void protobuf_AssignDesc_protobuf_2ftvWall_2eproto();
  friend void protobuf_ShutdownFile_protobuf_2ftvWall_2eproto();

  void InitAsDefaultInstance();
  static Packet_Ctrl_ScreenSplitCtrl* default_instance_;
};
// -------------------------------------------------------------------

class Packet_Ctrl_ViewCtrl_ViewGeomotryCtrl : public ::google::protobuf::Message {
 public:
  Packet_Ctrl_ViewCtrl_ViewGeomotryCtrl();
  virtual ~Packet_Ctrl_ViewCtrl_ViewGeomotryCtrl();

  Packet_Ctrl_ViewCtrl_ViewGeomotryCtrl(const Packet_Ctrl_ViewCtrl_ViewGeomotryCtrl& from);

  inline Packet_Ctrl_ViewCtrl_ViewGeomotryCtrl& operator=(const Packet_Ctrl_ViewCtrl_ViewGeomotryCtrl& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Packet_Ctrl_ViewCtrl_ViewGeomotryCtrl& default_instance();

  void Swap(Packet_Ctrl_ViewCtrl_ViewGeomotryCtrl* other);

  // implements Message ----------------------------------------------

  Packet_Ctrl_ViewCtrl_ViewGeomotryCtrl* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Packet_Ctrl_ViewCtrl_ViewGeomotryCtrl& from);
  void MergeFrom(const Packet_Ctrl_ViewCtrl_ViewGeomotryCtrl& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Packet_Ctrl_ViewCtrl_ViewGeomotryCtrl_ViewGeomotryCtrlType ViewGeomotryCtrlType;
  static const ViewGeomotryCtrlType CREATE = Packet_Ctrl_ViewCtrl_ViewGeomotryCtrl_ViewGeomotryCtrlType_CREATE;
  static const ViewGeomotryCtrlType WINDOW_CTRL = Packet_Ctrl_ViewCtrl_ViewGeomotryCtrl_ViewGeomotryCtrlType_WINDOW_CTRL;
  static const ViewGeomotryCtrlType REMOVE = Packet_Ctrl_ViewCtrl_ViewGeomotryCtrl_ViewGeomotryCtrlType_REMOVE;
  static const ViewGeomotryCtrlType SET_BORDER_WIDTH = Packet_Ctrl_ViewCtrl_ViewGeomotryCtrl_ViewGeomotryCtrlType_SET_BORDER_WIDTH;
  static const ViewGeomotryCtrlType SHOW_TITLE = Packet_Ctrl_ViewCtrl_ViewGeomotryCtrl_ViewGeomotryCtrlType_SHOW_TITLE;
  static inline bool ViewGeomotryCtrlType_IsValid(int value) {
    return Packet_Ctrl_ViewCtrl_ViewGeomotryCtrl_ViewGeomotryCtrlType_IsValid(value);
  }
  static const ViewGeomotryCtrlType ViewGeomotryCtrlType_MIN =
    Packet_Ctrl_ViewCtrl_ViewGeomotryCtrl_ViewGeomotryCtrlType_ViewGeomotryCtrlType_MIN;
  static const ViewGeomotryCtrlType ViewGeomotryCtrlType_MAX =
    Packet_Ctrl_ViewCtrl_ViewGeomotryCtrl_ViewGeomotryCtrlType_ViewGeomotryCtrlType_MAX;
  static const int ViewGeomotryCtrlType_ARRAYSIZE =
    Packet_Ctrl_ViewCtrl_ViewGeomotryCtrl_ViewGeomotryCtrlType_ViewGeomotryCtrlType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ViewGeomotryCtrlType_descriptor() {
    return Packet_Ctrl_ViewCtrl_ViewGeomotryCtrl_ViewGeomotryCtrlType_descriptor();
  }
  static inline const ::std::string& ViewGeomotryCtrlType_Name(ViewGeomotryCtrlType value) {
    return Packet_Ctrl_ViewCtrl_ViewGeomotryCtrl_ViewGeomotryCtrlType_Name(value);
  }
  static inline bool ViewGeomotryCtrlType_Parse(const ::std::string& name,
      ViewGeomotryCtrlType* value) {
    return Packet_Ctrl_ViewCtrl_ViewGeomotryCtrl_ViewGeomotryCtrlType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .TvWall.Packet.Ctrl.ViewCtrl.ViewGeomotryCtrl.ViewGeomotryCtrlType type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::TvWall::Packet_Ctrl_ViewCtrl_ViewGeomotryCtrl_ViewGeomotryCtrlType type() const;
  inline void set_type(::TvWall::Packet_Ctrl_ViewCtrl_ViewGeomotryCtrl_ViewGeomotryCtrlType value);

  // required .TvWall.Packet.ElementDat.View view = 2;
  inline bool has_view() const;
  inline void clear_view();
  static const int kViewFieldNumber = 2;
  inline const ::TvWall::Packet_ElementDat_View& view() const;
  inline ::TvWall::Packet_ElementDat_View* mutable_view();
  inline ::TvWall::Packet_ElementDat_View* release_view();
  inline void set_allocated_view(::TvWall::Packet_ElementDat_View* view);

  // @@protoc_insertion_point(class_scope:TvWall.Packet.Ctrl.ViewCtrl.ViewGeomotryCtrl)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_view();
  inline void clear_has_view();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TvWall::Packet_ElementDat_View* view_;
  int type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_protobuf_2ftvWall_2eproto();
  friend void protobuf_AssignDesc_protobuf_2ftvWall_2eproto();
  friend void protobuf_ShutdownFile_protobuf_2ftvWall_2eproto();

  void InitAsDefaultInstance();
  static Packet_Ctrl_ViewCtrl_ViewGeomotryCtrl* default_instance_;
};
// -------------------------------------------------------------------

class Packet_Ctrl_ViewCtrl_VideoCtrl : public ::google::protobuf::Message {
 public:
  Packet_Ctrl_ViewCtrl_VideoCtrl();
  virtual ~Packet_Ctrl_ViewCtrl_VideoCtrl();

  Packet_Ctrl_ViewCtrl_VideoCtrl(const Packet_Ctrl_ViewCtrl_VideoCtrl& from);

  inline Packet_Ctrl_ViewCtrl_VideoCtrl& operator=(const Packet_Ctrl_ViewCtrl_VideoCtrl& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Packet_Ctrl_ViewCtrl_VideoCtrl& default_instance();

  void Swap(Packet_Ctrl_ViewCtrl_VideoCtrl* other);

  // implements Message ----------------------------------------------

  Packet_Ctrl_ViewCtrl_VideoCtrl* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Packet_Ctrl_ViewCtrl_VideoCtrl& from);
  void MergeFrom(const Packet_Ctrl_ViewCtrl_VideoCtrl& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Packet_Ctrl_ViewCtrl_VideoCtrl_VideoCtrlType VideoCtrlType;
  static const VideoCtrlType CAMERA_ADD = Packet_Ctrl_ViewCtrl_VideoCtrl_VideoCtrlType_CAMERA_ADD;
  static const VideoCtrlType CAMERA_REMOVE = Packet_Ctrl_ViewCtrl_VideoCtrl_VideoCtrlType_CAMERA_REMOVE;
  static const VideoCtrlType POLL_INTERVAL = Packet_Ctrl_ViewCtrl_VideoCtrl_VideoCtrlType_POLL_INTERVAL;
  static const VideoCtrlType KEEP_STRETCH = Packet_Ctrl_ViewCtrl_VideoCtrl_VideoCtrlType_KEEP_STRETCH;
  static inline bool VideoCtrlType_IsValid(int value) {
    return Packet_Ctrl_ViewCtrl_VideoCtrl_VideoCtrlType_IsValid(value);
  }
  static const VideoCtrlType VideoCtrlType_MIN =
    Packet_Ctrl_ViewCtrl_VideoCtrl_VideoCtrlType_VideoCtrlType_MIN;
  static const VideoCtrlType VideoCtrlType_MAX =
    Packet_Ctrl_ViewCtrl_VideoCtrl_VideoCtrlType_VideoCtrlType_MAX;
  static const int VideoCtrlType_ARRAYSIZE =
    Packet_Ctrl_ViewCtrl_VideoCtrl_VideoCtrlType_VideoCtrlType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  VideoCtrlType_descriptor() {
    return Packet_Ctrl_ViewCtrl_VideoCtrl_VideoCtrlType_descriptor();
  }
  static inline const ::std::string& VideoCtrlType_Name(VideoCtrlType value) {
    return Packet_Ctrl_ViewCtrl_VideoCtrl_VideoCtrlType_Name(value);
  }
  static inline bool VideoCtrlType_Parse(const ::std::string& name,
      VideoCtrlType* value) {
    return Packet_Ctrl_ViewCtrl_VideoCtrl_VideoCtrlType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .TvWall.Packet.Ctrl.ViewCtrl.VideoCtrl.VideoCtrlType type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::TvWall::Packet_Ctrl_ViewCtrl_VideoCtrl_VideoCtrlType type() const;
  inline void set_type(::TvWall::Packet_Ctrl_ViewCtrl_VideoCtrl_VideoCtrlType value);

  // required int32 winId = 2;
  inline bool has_winid() const;
  inline void clear_winid();
  static const int kWinIdFieldNumber = 2;
  inline ::google::protobuf::int32 winid() const;
  inline void set_winid(::google::protobuf::int32 value);

  // repeated .TvWall.Guid cameraId = 3;
  inline int cameraid_size() const;
  inline void clear_cameraid();
  static const int kCameraIdFieldNumber = 3;
  inline const ::TvWall::Guid& cameraid(int index) const;
  inline ::TvWall::Guid* mutable_cameraid(int index);
  inline ::TvWall::Guid* add_cameraid();
  inline const ::google::protobuf::RepeatedPtrField< ::TvWall::Guid >&
      cameraid() const;
  inline ::google::protobuf::RepeatedPtrField< ::TvWall::Guid >*
      mutable_cameraid();

  // optional int32 pollInterval = 4;
  inline bool has_pollinterval() const;
  inline void clear_pollinterval();
  static const int kPollIntervalFieldNumber = 4;
  inline ::google::protobuf::int32 pollinterval() const;
  inline void set_pollinterval(::google::protobuf::int32 value);

  // optional bool keepStretch = 5;
  inline bool has_keepstretch() const;
  inline void clear_keepstretch();
  static const int kKeepStretchFieldNumber = 5;
  inline bool keepstretch() const;
  inline void set_keepstretch(bool value);

  // @@protoc_insertion_point(class_scope:TvWall.Packet.Ctrl.ViewCtrl.VideoCtrl)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_winid();
  inline void clear_has_winid();
  inline void set_has_pollinterval();
  inline void clear_has_pollinterval();
  inline void set_has_keepstretch();
  inline void clear_has_keepstretch();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int type_;
  ::google::protobuf::int32 winid_;
  ::google::protobuf::RepeatedPtrField< ::TvWall::Guid > cameraid_;
  ::google::protobuf::int32 pollinterval_;
  bool keepstretch_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_protobuf_2ftvWall_2eproto();
  friend void protobuf_AssignDesc_protobuf_2ftvWall_2eproto();
  friend void protobuf_ShutdownFile_protobuf_2ftvWall_2eproto();

  void InitAsDefaultInstance();
  static Packet_Ctrl_ViewCtrl_VideoCtrl* default_instance_;
};
// -------------------------------------------------------------------

class Packet_Ctrl_ViewCtrl_RecordCtrl : public ::google::protobuf::Message {
 public:
  Packet_Ctrl_ViewCtrl_RecordCtrl();
  virtual ~Packet_Ctrl_ViewCtrl_RecordCtrl();

  Packet_Ctrl_ViewCtrl_RecordCtrl(const Packet_Ctrl_ViewCtrl_RecordCtrl& from);

  inline Packet_Ctrl_ViewCtrl_RecordCtrl& operator=(const Packet_Ctrl_ViewCtrl_RecordCtrl& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Packet_Ctrl_ViewCtrl_RecordCtrl& default_instance();

  void Swap(Packet_Ctrl_ViewCtrl_RecordCtrl* other);

  // implements Message ----------------------------------------------

  Packet_Ctrl_ViewCtrl_RecordCtrl* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Packet_Ctrl_ViewCtrl_RecordCtrl& from);
  void MergeFrom(const Packet_Ctrl_ViewCtrl_RecordCtrl& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Packet_Ctrl_ViewCtrl_RecordCtrl_RecordCtrlType RecordCtrlType;
  static const RecordCtrlType RESET_START_TIME = Packet_Ctrl_ViewCtrl_RecordCtrl_RecordCtrlType_RESET_START_TIME;
  static const RecordCtrlType KEEP_STRETCH = Packet_Ctrl_ViewCtrl_RecordCtrl_RecordCtrlType_KEEP_STRETCH;
  static const RecordCtrlType SET_RATE = Packet_Ctrl_ViewCtrl_RecordCtrl_RecordCtrlType_SET_RATE;
  static const RecordCtrlType PAUSE = Packet_Ctrl_ViewCtrl_RecordCtrl_RecordCtrlType_PAUSE;
  static const RecordCtrlType SLOW = Packet_Ctrl_ViewCtrl_RecordCtrl_RecordCtrlType_SLOW;
  static const RecordCtrlType FAST = Packet_Ctrl_ViewCtrl_RecordCtrl_RecordCtrlType_FAST;
  static const RecordCtrlType BACK = Packet_Ctrl_ViewCtrl_RecordCtrl_RecordCtrlType_BACK;
  static const RecordCtrlType FORWARD = Packet_Ctrl_ViewCtrl_RecordCtrl_RecordCtrlType_FORWARD;
  static inline bool RecordCtrlType_IsValid(int value) {
    return Packet_Ctrl_ViewCtrl_RecordCtrl_RecordCtrlType_IsValid(value);
  }
  static const RecordCtrlType RecordCtrlType_MIN =
    Packet_Ctrl_ViewCtrl_RecordCtrl_RecordCtrlType_RecordCtrlType_MIN;
  static const RecordCtrlType RecordCtrlType_MAX =
    Packet_Ctrl_ViewCtrl_RecordCtrl_RecordCtrlType_RecordCtrlType_MAX;
  static const int RecordCtrlType_ARRAYSIZE =
    Packet_Ctrl_ViewCtrl_RecordCtrl_RecordCtrlType_RecordCtrlType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  RecordCtrlType_descriptor() {
    return Packet_Ctrl_ViewCtrl_RecordCtrl_RecordCtrlType_descriptor();
  }
  static inline const ::std::string& RecordCtrlType_Name(RecordCtrlType value) {
    return Packet_Ctrl_ViewCtrl_RecordCtrl_RecordCtrlType_Name(value);
  }
  static inline bool RecordCtrlType_Parse(const ::std::string& name,
      RecordCtrlType* value) {
    return Packet_Ctrl_ViewCtrl_RecordCtrl_RecordCtrlType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .TvWall.Packet.Ctrl.ViewCtrl.RecordCtrl.RecordCtrlType type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::TvWall::Packet_Ctrl_ViewCtrl_RecordCtrl_RecordCtrlType type() const;
  inline void set_type(::TvWall::Packet_Ctrl_ViewCtrl_RecordCtrl_RecordCtrlType value);

  // required int32 winId = 2;
  inline bool has_winid() const;
  inline void clear_winid();
  static const int kWinIdFieldNumber = 2;
  inline ::google::protobuf::int32 winid() const;
  inline void set_winid(::google::protobuf::int32 value);

  // required .TvWall.Guid cameraId = 3;
  inline bool has_cameraid() const;
  inline void clear_cameraid();
  static const int kCameraIdFieldNumber = 3;
  inline const ::TvWall::Guid& cameraid() const;
  inline ::TvWall::Guid* mutable_cameraid();
  inline ::TvWall::Guid* release_cameraid();
  inline void set_allocated_cameraid(::TvWall::Guid* cameraid);

  // optional uint64 startTime = 4;
  inline bool has_starttime() const;
  inline void clear_starttime();
  static const int kStartTimeFieldNumber = 4;
  inline ::google::protobuf::uint64 starttime() const;
  inline void set_starttime(::google::protobuf::uint64 value);

  // optional bool keepStretch = 5;
  inline bool has_keepstretch() const;
  inline void clear_keepstretch();
  static const int kKeepStretchFieldNumber = 5;
  inline bool keepstretch() const;
  inline void set_keepstretch(bool value);

  // optional int32 rate = 6;
  inline bool has_rate() const;
  inline void clear_rate();
  static const int kRateFieldNumber = 6;
  inline ::google::protobuf::int32 rate() const;
  inline void set_rate(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:TvWall.Packet.Ctrl.ViewCtrl.RecordCtrl)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_winid();
  inline void clear_has_winid();
  inline void set_has_cameraid();
  inline void clear_has_cameraid();
  inline void set_has_starttime();
  inline void clear_has_starttime();
  inline void set_has_keepstretch();
  inline void clear_has_keepstretch();
  inline void set_has_rate();
  inline void clear_has_rate();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int type_;
  ::google::protobuf::int32 winid_;
  ::TvWall::Guid* cameraid_;
  ::google::protobuf::uint64 starttime_;
  bool keepstretch_;
  ::google::protobuf::int32 rate_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_protobuf_2ftvWall_2eproto();
  friend void protobuf_AssignDesc_protobuf_2ftvWall_2eproto();
  friend void protobuf_ShutdownFile_protobuf_2ftvWall_2eproto();

  void InitAsDefaultInstance();
  static Packet_Ctrl_ViewCtrl_RecordCtrl* default_instance_;
};
// -------------------------------------------------------------------

class Packet_Ctrl_ViewCtrl_FlashCtrl : public ::google::protobuf::Message {
 public:
  Packet_Ctrl_ViewCtrl_FlashCtrl();
  virtual ~Packet_Ctrl_ViewCtrl_FlashCtrl();

  Packet_Ctrl_ViewCtrl_FlashCtrl(const Packet_Ctrl_ViewCtrl_FlashCtrl& from);

  inline Packet_Ctrl_ViewCtrl_FlashCtrl& operator=(const Packet_Ctrl_ViewCtrl_FlashCtrl& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Packet_Ctrl_ViewCtrl_FlashCtrl& default_instance();

  void Swap(Packet_Ctrl_ViewCtrl_FlashCtrl* other);

  // implements Message ----------------------------------------------

  Packet_Ctrl_ViewCtrl_FlashCtrl* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Packet_Ctrl_ViewCtrl_FlashCtrl& from);
  void MergeFrom(const Packet_Ctrl_ViewCtrl_FlashCtrl& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Packet_Ctrl_ViewCtrl_FlashCtrl_FlashCtrlType FlashCtrlType;
  static const FlashCtrlType SET_FLASH = Packet_Ctrl_ViewCtrl_FlashCtrl_FlashCtrlType_SET_FLASH;
  static inline bool FlashCtrlType_IsValid(int value) {
    return Packet_Ctrl_ViewCtrl_FlashCtrl_FlashCtrlType_IsValid(value);
  }
  static const FlashCtrlType FlashCtrlType_MIN =
    Packet_Ctrl_ViewCtrl_FlashCtrl_FlashCtrlType_FlashCtrlType_MIN;
  static const FlashCtrlType FlashCtrlType_MAX =
    Packet_Ctrl_ViewCtrl_FlashCtrl_FlashCtrlType_FlashCtrlType_MAX;
  static const int FlashCtrlType_ARRAYSIZE =
    Packet_Ctrl_ViewCtrl_FlashCtrl_FlashCtrlType_FlashCtrlType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  FlashCtrlType_descriptor() {
    return Packet_Ctrl_ViewCtrl_FlashCtrl_FlashCtrlType_descriptor();
  }
  static inline const ::std::string& FlashCtrlType_Name(FlashCtrlType value) {
    return Packet_Ctrl_ViewCtrl_FlashCtrl_FlashCtrlType_Name(value);
  }
  static inline bool FlashCtrlType_Parse(const ::std::string& name,
      FlashCtrlType* value) {
    return Packet_Ctrl_ViewCtrl_FlashCtrl_FlashCtrlType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .TvWall.Packet.Ctrl.ViewCtrl.FlashCtrl.FlashCtrlType type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::TvWall::Packet_Ctrl_ViewCtrl_FlashCtrl_FlashCtrlType type() const;
  inline void set_type(::TvWall::Packet_Ctrl_ViewCtrl_FlashCtrl_FlashCtrlType value);

  // required int32 winId = 2;
  inline bool has_winid() const;
  inline void clear_winid();
  static const int kWinIdFieldNumber = 2;
  inline ::google::protobuf::int32 winid() const;
  inline void set_winid(::google::protobuf::int32 value);

  // required string url = 3;
  inline bool has_url() const;
  inline void clear_url();
  static const int kUrlFieldNumber = 3;
  inline const ::std::string& url() const;
  inline void set_url(const ::std::string& value);
  inline void set_url(const char* value);
  inline void set_url(const char* value, size_t size);
  inline ::std::string* mutable_url();
  inline ::std::string* release_url();
  inline void set_allocated_url(::std::string* url);

  // @@protoc_insertion_point(class_scope:TvWall.Packet.Ctrl.ViewCtrl.FlashCtrl)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_winid();
  inline void clear_has_winid();
  inline void set_has_url();
  inline void clear_has_url();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int type_;
  ::google::protobuf::int32 winid_;
  ::std::string* url_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_protobuf_2ftvWall_2eproto();
  friend void protobuf_AssignDesc_protobuf_2ftvWall_2eproto();
  friend void protobuf_ShutdownFile_protobuf_2ftvWall_2eproto();

  void InitAsDefaultInstance();
  static Packet_Ctrl_ViewCtrl_FlashCtrl* default_instance_;
};
// -------------------------------------------------------------------

class Packet_Ctrl_ViewCtrl_HTMLCtrl : public ::google::protobuf::Message {
 public:
  Packet_Ctrl_ViewCtrl_HTMLCtrl();
  virtual ~Packet_Ctrl_ViewCtrl_HTMLCtrl();

  Packet_Ctrl_ViewCtrl_HTMLCtrl(const Packet_Ctrl_ViewCtrl_HTMLCtrl& from);

  inline Packet_Ctrl_ViewCtrl_HTMLCtrl& operator=(const Packet_Ctrl_ViewCtrl_HTMLCtrl& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Packet_Ctrl_ViewCtrl_HTMLCtrl& default_instance();

  void Swap(Packet_Ctrl_ViewCtrl_HTMLCtrl* other);

  // implements Message ----------------------------------------------

  Packet_Ctrl_ViewCtrl_HTMLCtrl* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Packet_Ctrl_ViewCtrl_HTMLCtrl& from);
  void MergeFrom(const Packet_Ctrl_ViewCtrl_HTMLCtrl& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Packet_Ctrl_ViewCtrl_HTMLCtrl_HTMLCtrlType HTMLCtrlType;
  static const HTMLCtrlType SET_HTML = Packet_Ctrl_ViewCtrl_HTMLCtrl_HTMLCtrlType_SET_HTML;
  static inline bool HTMLCtrlType_IsValid(int value) {
    return Packet_Ctrl_ViewCtrl_HTMLCtrl_HTMLCtrlType_IsValid(value);
  }
  static const HTMLCtrlType HTMLCtrlType_MIN =
    Packet_Ctrl_ViewCtrl_HTMLCtrl_HTMLCtrlType_HTMLCtrlType_MIN;
  static const HTMLCtrlType HTMLCtrlType_MAX =
    Packet_Ctrl_ViewCtrl_HTMLCtrl_HTMLCtrlType_HTMLCtrlType_MAX;
  static const int HTMLCtrlType_ARRAYSIZE =
    Packet_Ctrl_ViewCtrl_HTMLCtrl_HTMLCtrlType_HTMLCtrlType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  HTMLCtrlType_descriptor() {
    return Packet_Ctrl_ViewCtrl_HTMLCtrl_HTMLCtrlType_descriptor();
  }
  static inline const ::std::string& HTMLCtrlType_Name(HTMLCtrlType value) {
    return Packet_Ctrl_ViewCtrl_HTMLCtrl_HTMLCtrlType_Name(value);
  }
  static inline bool HTMLCtrlType_Parse(const ::std::string& name,
      HTMLCtrlType* value) {
    return Packet_Ctrl_ViewCtrl_HTMLCtrl_HTMLCtrlType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .TvWall.Packet.Ctrl.ViewCtrl.HTMLCtrl.HTMLCtrlType type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::TvWall::Packet_Ctrl_ViewCtrl_HTMLCtrl_HTMLCtrlType type() const;
  inline void set_type(::TvWall::Packet_Ctrl_ViewCtrl_HTMLCtrl_HTMLCtrlType value);

  // required int32 winId = 2;
  inline bool has_winid() const;
  inline void clear_winid();
  static const int kWinIdFieldNumber = 2;
  inline ::google::protobuf::int32 winid() const;
  inline void set_winid(::google::protobuf::int32 value);

  // required string url = 3;
  inline bool has_url() const;
  inline void clear_url();
  static const int kUrlFieldNumber = 3;
  inline const ::std::string& url() const;
  inline void set_url(const ::std::string& value);
  inline void set_url(const char* value);
  inline void set_url(const char* value, size_t size);
  inline ::std::string* mutable_url();
  inline ::std::string* release_url();
  inline void set_allocated_url(::std::string* url);

  // @@protoc_insertion_point(class_scope:TvWall.Packet.Ctrl.ViewCtrl.HTMLCtrl)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_winid();
  inline void clear_has_winid();
  inline void set_has_url();
  inline void clear_has_url();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int type_;
  ::google::protobuf::int32 winid_;
  ::std::string* url_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_protobuf_2ftvWall_2eproto();
  friend void protobuf_AssignDesc_protobuf_2ftvWall_2eproto();
  friend void protobuf_ShutdownFile_protobuf_2ftvWall_2eproto();

  void InitAsDefaultInstance();
  static Packet_Ctrl_ViewCtrl_HTMLCtrl* default_instance_;
};
// -------------------------------------------------------------------

class Packet_Ctrl_ViewCtrl_LocalMovieCtrl : public ::google::protobuf::Message {
 public:
  Packet_Ctrl_ViewCtrl_LocalMovieCtrl();
  virtual ~Packet_Ctrl_ViewCtrl_LocalMovieCtrl();

  Packet_Ctrl_ViewCtrl_LocalMovieCtrl(const Packet_Ctrl_ViewCtrl_LocalMovieCtrl& from);

  inline Packet_Ctrl_ViewCtrl_LocalMovieCtrl& operator=(const Packet_Ctrl_ViewCtrl_LocalMovieCtrl& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Packet_Ctrl_ViewCtrl_LocalMovieCtrl& default_instance();

  void Swap(Packet_Ctrl_ViewCtrl_LocalMovieCtrl* other);

  // implements Message ----------------------------------------------

  Packet_Ctrl_ViewCtrl_LocalMovieCtrl* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Packet_Ctrl_ViewCtrl_LocalMovieCtrl& from);
  void MergeFrom(const Packet_Ctrl_ViewCtrl_LocalMovieCtrl& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Packet_Ctrl_ViewCtrl_LocalMovieCtrl_LocalMovieType LocalMovieType;
  static const LocalMovieType SET_FILE = Packet_Ctrl_ViewCtrl_LocalMovieCtrl_LocalMovieType_SET_FILE;
  static const LocalMovieType SET_VOLUME = Packet_Ctrl_ViewCtrl_LocalMovieCtrl_LocalMovieType_SET_VOLUME;
  static const LocalMovieType SET_SLIDER = Packet_Ctrl_ViewCtrl_LocalMovieCtrl_LocalMovieType_SET_SLIDER;
  static const LocalMovieType PAUSE = Packet_Ctrl_ViewCtrl_LocalMovieCtrl_LocalMovieType_PAUSE;
  static const LocalMovieType STOP = Packet_Ctrl_ViewCtrl_LocalMovieCtrl_LocalMovieType_STOP;
  static inline bool LocalMovieType_IsValid(int value) {
    return Packet_Ctrl_ViewCtrl_LocalMovieCtrl_LocalMovieType_IsValid(value);
  }
  static const LocalMovieType LocalMovieType_MIN =
    Packet_Ctrl_ViewCtrl_LocalMovieCtrl_LocalMovieType_LocalMovieType_MIN;
  static const LocalMovieType LocalMovieType_MAX =
    Packet_Ctrl_ViewCtrl_LocalMovieCtrl_LocalMovieType_LocalMovieType_MAX;
  static const int LocalMovieType_ARRAYSIZE =
    Packet_Ctrl_ViewCtrl_LocalMovieCtrl_LocalMovieType_LocalMovieType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  LocalMovieType_descriptor() {
    return Packet_Ctrl_ViewCtrl_LocalMovieCtrl_LocalMovieType_descriptor();
  }
  static inline const ::std::string& LocalMovieType_Name(LocalMovieType value) {
    return Packet_Ctrl_ViewCtrl_LocalMovieCtrl_LocalMovieType_Name(value);
  }
  static inline bool LocalMovieType_Parse(const ::std::string& name,
      LocalMovieType* value) {
    return Packet_Ctrl_ViewCtrl_LocalMovieCtrl_LocalMovieType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .TvWall.Packet.Ctrl.ViewCtrl.LocalMovieCtrl.LocalMovieType type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::TvWall::Packet_Ctrl_ViewCtrl_LocalMovieCtrl_LocalMovieType type() const;
  inline void set_type(::TvWall::Packet_Ctrl_ViewCtrl_LocalMovieCtrl_LocalMovieType value);

  // required int32 winId = 2;
  inline bool has_winid() const;
  inline void clear_winid();
  static const int kWinIdFieldNumber = 2;
  inline ::google::protobuf::int32 winid() const;
  inline void set_winid(::google::protobuf::int32 value);

  // optional string url = 3;
  inline bool has_url() const;
  inline void clear_url();
  static const int kUrlFieldNumber = 3;
  inline const ::std::string& url() const;
  inline void set_url(const ::std::string& value);
  inline void set_url(const char* value);
  inline void set_url(const char* value, size_t size);
  inline ::std::string* mutable_url();
  inline ::std::string* release_url();
  inline void set_allocated_url(::std::string* url);

  // optional int32 volume = 4;
  inline bool has_volume() const;
  inline void clear_volume();
  static const int kVolumeFieldNumber = 4;
  inline ::google::protobuf::int32 volume() const;
  inline void set_volume(::google::protobuf::int32 value);

  // optional int64 timeStamp = 5;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimeStampFieldNumber = 5;
  inline ::google::protobuf::int64 timestamp() const;
  inline void set_timestamp(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:TvWall.Packet.Ctrl.ViewCtrl.LocalMovieCtrl)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_winid();
  inline void clear_has_winid();
  inline void set_has_url();
  inline void clear_has_url();
  inline void set_has_volume();
  inline void clear_has_volume();
  inline void set_has_timestamp();
  inline void clear_has_timestamp();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int type_;
  ::google::protobuf::int32 winid_;
  ::std::string* url_;
  ::google::protobuf::int64 timestamp_;
  ::google::protobuf::int32 volume_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_protobuf_2ftvWall_2eproto();
  friend void protobuf_AssignDesc_protobuf_2ftvWall_2eproto();
  friend void protobuf_ShutdownFile_protobuf_2ftvWall_2eproto();

  void InitAsDefaultInstance();
  static Packet_Ctrl_ViewCtrl_LocalMovieCtrl* default_instance_;
};
// -------------------------------------------------------------------

class Packet_Ctrl_ViewCtrl_TextCtrl : public ::google::protobuf::Message {
 public:
  Packet_Ctrl_ViewCtrl_TextCtrl();
  virtual ~Packet_Ctrl_ViewCtrl_TextCtrl();

  Packet_Ctrl_ViewCtrl_TextCtrl(const Packet_Ctrl_ViewCtrl_TextCtrl& from);

  inline Packet_Ctrl_ViewCtrl_TextCtrl& operator=(const Packet_Ctrl_ViewCtrl_TextCtrl& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Packet_Ctrl_ViewCtrl_TextCtrl& default_instance();

  void Swap(Packet_Ctrl_ViewCtrl_TextCtrl* other);

  // implements Message ----------------------------------------------

  Packet_Ctrl_ViewCtrl_TextCtrl* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Packet_Ctrl_ViewCtrl_TextCtrl& from);
  void MergeFrom(const Packet_Ctrl_ViewCtrl_TextCtrl& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Packet_Ctrl_ViewCtrl_TextCtrl_TextCtrlType TextCtrlType;
  static const TextCtrlType SET_TEXT = Packet_Ctrl_ViewCtrl_TextCtrl_TextCtrlType_SET_TEXT;
  static inline bool TextCtrlType_IsValid(int value) {
    return Packet_Ctrl_ViewCtrl_TextCtrl_TextCtrlType_IsValid(value);
  }
  static const TextCtrlType TextCtrlType_MIN =
    Packet_Ctrl_ViewCtrl_TextCtrl_TextCtrlType_TextCtrlType_MIN;
  static const TextCtrlType TextCtrlType_MAX =
    Packet_Ctrl_ViewCtrl_TextCtrl_TextCtrlType_TextCtrlType_MAX;
  static const int TextCtrlType_ARRAYSIZE =
    Packet_Ctrl_ViewCtrl_TextCtrl_TextCtrlType_TextCtrlType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  TextCtrlType_descriptor() {
    return Packet_Ctrl_ViewCtrl_TextCtrl_TextCtrlType_descriptor();
  }
  static inline const ::std::string& TextCtrlType_Name(TextCtrlType value) {
    return Packet_Ctrl_ViewCtrl_TextCtrl_TextCtrlType_Name(value);
  }
  static inline bool TextCtrlType_Parse(const ::std::string& name,
      TextCtrlType* value) {
    return Packet_Ctrl_ViewCtrl_TextCtrl_TextCtrlType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .TvWall.Packet.Ctrl.ViewCtrl.TextCtrl.TextCtrlType type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::TvWall::Packet_Ctrl_ViewCtrl_TextCtrl_TextCtrlType type() const;
  inline void set_type(::TvWall::Packet_Ctrl_ViewCtrl_TextCtrl_TextCtrlType value);

  // required int32 winId = 2;
  inline bool has_winid() const;
  inline void clear_winid();
  static const int kWinIdFieldNumber = 2;
  inline ::google::protobuf::int32 winid() const;
  inline void set_winid(::google::protobuf::int32 value);

  // optional string text = 3;
  inline bool has_text() const;
  inline void clear_text();
  static const int kTextFieldNumber = 3;
  inline const ::std::string& text() const;
  inline void set_text(const ::std::string& value);
  inline void set_text(const char* value);
  inline void set_text(const char* value, size_t size);
  inline ::std::string* mutable_text();
  inline ::std::string* release_text();
  inline void set_allocated_text(::std::string* text);

  // @@protoc_insertion_point(class_scope:TvWall.Packet.Ctrl.ViewCtrl.TextCtrl)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_winid();
  inline void clear_has_winid();
  inline void set_has_text();
  inline void clear_has_text();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int type_;
  ::google::protobuf::int32 winid_;
  ::std::string* text_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_protobuf_2ftvWall_2eproto();
  friend void protobuf_AssignDesc_protobuf_2ftvWall_2eproto();
  friend void protobuf_ShutdownFile_protobuf_2ftvWall_2eproto();

  void InitAsDefaultInstance();
  static Packet_Ctrl_ViewCtrl_TextCtrl* default_instance_;
};
// -------------------------------------------------------------------

class Packet_Ctrl_ViewCtrl_MapCtrl : public ::google::protobuf::Message {
 public:
  Packet_Ctrl_ViewCtrl_MapCtrl();
  virtual ~Packet_Ctrl_ViewCtrl_MapCtrl();

  Packet_Ctrl_ViewCtrl_MapCtrl(const Packet_Ctrl_ViewCtrl_MapCtrl& from);

  inline Packet_Ctrl_ViewCtrl_MapCtrl& operator=(const Packet_Ctrl_ViewCtrl_MapCtrl& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Packet_Ctrl_ViewCtrl_MapCtrl& default_instance();

  void Swap(Packet_Ctrl_ViewCtrl_MapCtrl* other);

  // implements Message ----------------------------------------------

  Packet_Ctrl_ViewCtrl_MapCtrl* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Packet_Ctrl_ViewCtrl_MapCtrl& from);
  void MergeFrom(const Packet_Ctrl_ViewCtrl_MapCtrl& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Packet_Ctrl_ViewCtrl_MapCtrl_MapCtrlType MapCtrlType;
  static const MapCtrlType SET_MAP = Packet_Ctrl_ViewCtrl_MapCtrl_MapCtrlType_SET_MAP;
  static inline bool MapCtrlType_IsValid(int value) {
    return Packet_Ctrl_ViewCtrl_MapCtrl_MapCtrlType_IsValid(value);
  }
  static const MapCtrlType MapCtrlType_MIN =
    Packet_Ctrl_ViewCtrl_MapCtrl_MapCtrlType_MapCtrlType_MIN;
  static const MapCtrlType MapCtrlType_MAX =
    Packet_Ctrl_ViewCtrl_MapCtrl_MapCtrlType_MapCtrlType_MAX;
  static const int MapCtrlType_ARRAYSIZE =
    Packet_Ctrl_ViewCtrl_MapCtrl_MapCtrlType_MapCtrlType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  MapCtrlType_descriptor() {
    return Packet_Ctrl_ViewCtrl_MapCtrl_MapCtrlType_descriptor();
  }
  static inline const ::std::string& MapCtrlType_Name(MapCtrlType value) {
    return Packet_Ctrl_ViewCtrl_MapCtrl_MapCtrlType_Name(value);
  }
  static inline bool MapCtrlType_Parse(const ::std::string& name,
      MapCtrlType* value) {
    return Packet_Ctrl_ViewCtrl_MapCtrl_MapCtrlType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .TvWall.Packet.Ctrl.ViewCtrl.MapCtrl.MapCtrlType type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::TvWall::Packet_Ctrl_ViewCtrl_MapCtrl_MapCtrlType type() const;
  inline void set_type(::TvWall::Packet_Ctrl_ViewCtrl_MapCtrl_MapCtrlType value);

  // required int32 winId = 2;
  inline bool has_winid() const;
  inline void clear_winid();
  static const int kWinIdFieldNumber = 2;
  inline ::google::protobuf::int32 winid() const;
  inline void set_winid(::google::protobuf::int32 value);

  // optional string url = 3;
  inline bool has_url() const;
  inline void clear_url();
  static const int kUrlFieldNumber = 3;
  inline const ::std::string& url() const;
  inline void set_url(const ::std::string& value);
  inline void set_url(const char* value);
  inline void set_url(const char* value, size_t size);
  inline ::std::string* mutable_url();
  inline ::std::string* release_url();
  inline void set_allocated_url(::std::string* url);

  // @@protoc_insertion_point(class_scope:TvWall.Packet.Ctrl.ViewCtrl.MapCtrl)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_winid();
  inline void clear_has_winid();
  inline void set_has_url();
  inline void clear_has_url();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int type_;
  ::google::protobuf::int32 winid_;
  ::std::string* url_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_protobuf_2ftvWall_2eproto();
  friend void protobuf_AssignDesc_protobuf_2ftvWall_2eproto();
  friend void protobuf_ShutdownFile_protobuf_2ftvWall_2eproto();

  void InitAsDefaultInstance();
  static Packet_Ctrl_ViewCtrl_MapCtrl* default_instance_;
};
// -------------------------------------------------------------------

class Packet_Ctrl_ViewCtrl_OthersCtrl : public ::google::protobuf::Message {
 public:
  Packet_Ctrl_ViewCtrl_OthersCtrl();
  virtual ~Packet_Ctrl_ViewCtrl_OthersCtrl();

  Packet_Ctrl_ViewCtrl_OthersCtrl(const Packet_Ctrl_ViewCtrl_OthersCtrl& from);

  inline Packet_Ctrl_ViewCtrl_OthersCtrl& operator=(const Packet_Ctrl_ViewCtrl_OthersCtrl& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Packet_Ctrl_ViewCtrl_OthersCtrl& default_instance();

  void Swap(Packet_Ctrl_ViewCtrl_OthersCtrl* other);

  // implements Message ----------------------------------------------

  Packet_Ctrl_ViewCtrl_OthersCtrl* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Packet_Ctrl_ViewCtrl_OthersCtrl& from);
  void MergeFrom(const Packet_Ctrl_ViewCtrl_OthersCtrl& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Packet_Ctrl_ViewCtrl_OthersCtrl_OthersCtrlType OthersCtrlType;
  static const OthersCtrlType OTHER_ADD = Packet_Ctrl_ViewCtrl_OthersCtrl_OthersCtrlType_OTHER_ADD;
  static inline bool OthersCtrlType_IsValid(int value) {
    return Packet_Ctrl_ViewCtrl_OthersCtrl_OthersCtrlType_IsValid(value);
  }
  static const OthersCtrlType OthersCtrlType_MIN =
    Packet_Ctrl_ViewCtrl_OthersCtrl_OthersCtrlType_OthersCtrlType_MIN;
  static const OthersCtrlType OthersCtrlType_MAX =
    Packet_Ctrl_ViewCtrl_OthersCtrl_OthersCtrlType_OthersCtrlType_MAX;
  static const int OthersCtrlType_ARRAYSIZE =
    Packet_Ctrl_ViewCtrl_OthersCtrl_OthersCtrlType_OthersCtrlType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  OthersCtrlType_descriptor() {
    return Packet_Ctrl_ViewCtrl_OthersCtrl_OthersCtrlType_descriptor();
  }
  static inline const ::std::string& OthersCtrlType_Name(OthersCtrlType value) {
    return Packet_Ctrl_ViewCtrl_OthersCtrl_OthersCtrlType_Name(value);
  }
  static inline bool OthersCtrlType_Parse(const ::std::string& name,
      OthersCtrlType* value) {
    return Packet_Ctrl_ViewCtrl_OthersCtrl_OthersCtrlType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .TvWall.Packet.Ctrl.ViewCtrl.OthersCtrl.OthersCtrlType type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::TvWall::Packet_Ctrl_ViewCtrl_OthersCtrl_OthersCtrlType type() const;
  inline void set_type(::TvWall::Packet_Ctrl_ViewCtrl_OthersCtrl_OthersCtrlType value);

  // required int32 winId = 2;
  inline bool has_winid() const;
  inline void clear_winid();
  static const int kWinIdFieldNumber = 2;
  inline ::google::protobuf::int32 winid() const;
  inline void set_winid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:TvWall.Packet.Ctrl.ViewCtrl.OthersCtrl)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_winid();
  inline void clear_has_winid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int type_;
  ::google::protobuf::int32 winid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_protobuf_2ftvWall_2eproto();
  friend void protobuf_AssignDesc_protobuf_2ftvWall_2eproto();
  friend void protobuf_ShutdownFile_protobuf_2ftvWall_2eproto();

  void InitAsDefaultInstance();
  static Packet_Ctrl_ViewCtrl_OthersCtrl* default_instance_;
};
// -------------------------------------------------------------------

class Packet_Ctrl_ViewCtrl : public ::google::protobuf::Message {
 public:
  Packet_Ctrl_ViewCtrl();
  virtual ~Packet_Ctrl_ViewCtrl();

  Packet_Ctrl_ViewCtrl(const Packet_Ctrl_ViewCtrl& from);

  inline Packet_Ctrl_ViewCtrl& operator=(const Packet_Ctrl_ViewCtrl& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Packet_Ctrl_ViewCtrl& default_instance();

  void Swap(Packet_Ctrl_ViewCtrl* other);

  // implements Message ----------------------------------------------

  Packet_Ctrl_ViewCtrl* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Packet_Ctrl_ViewCtrl& from);
  void MergeFrom(const Packet_Ctrl_ViewCtrl& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Packet_Ctrl_ViewCtrl_ViewGeomotryCtrl ViewGeomotryCtrl;
  typedef Packet_Ctrl_ViewCtrl_VideoCtrl VideoCtrl;
  typedef Packet_Ctrl_ViewCtrl_RecordCtrl RecordCtrl;
  typedef Packet_Ctrl_ViewCtrl_FlashCtrl FlashCtrl;
  typedef Packet_Ctrl_ViewCtrl_HTMLCtrl HTMLCtrl;
  typedef Packet_Ctrl_ViewCtrl_LocalMovieCtrl LocalMovieCtrl;
  typedef Packet_Ctrl_ViewCtrl_TextCtrl TextCtrl;
  typedef Packet_Ctrl_ViewCtrl_MapCtrl MapCtrl;
  typedef Packet_Ctrl_ViewCtrl_OthersCtrl OthersCtrl;

  // accessors -------------------------------------------------------

  // optional .TvWall.Packet.Ctrl.ViewCtrl.VideoCtrl videoCtrl = 1;
  inline bool has_videoctrl() const;
  inline void clear_videoctrl();
  static const int kVideoCtrlFieldNumber = 1;
  inline const ::TvWall::Packet_Ctrl_ViewCtrl_VideoCtrl& videoctrl() const;
  inline ::TvWall::Packet_Ctrl_ViewCtrl_VideoCtrl* mutable_videoctrl();
  inline ::TvWall::Packet_Ctrl_ViewCtrl_VideoCtrl* release_videoctrl();
  inline void set_allocated_videoctrl(::TvWall::Packet_Ctrl_ViewCtrl_VideoCtrl* videoctrl);

  // optional .TvWall.Packet.Ctrl.ViewCtrl.FlashCtrl flashCtrl = 2;
  inline bool has_flashctrl() const;
  inline void clear_flashctrl();
  static const int kFlashCtrlFieldNumber = 2;
  inline const ::TvWall::Packet_Ctrl_ViewCtrl_FlashCtrl& flashctrl() const;
  inline ::TvWall::Packet_Ctrl_ViewCtrl_FlashCtrl* mutable_flashctrl();
  inline ::TvWall::Packet_Ctrl_ViewCtrl_FlashCtrl* release_flashctrl();
  inline void set_allocated_flashctrl(::TvWall::Packet_Ctrl_ViewCtrl_FlashCtrl* flashctrl);

  // optional .TvWall.Packet.Ctrl.ViewCtrl.HTMLCtrl htmlCtrl = 3;
  inline bool has_htmlctrl() const;
  inline void clear_htmlctrl();
  static const int kHtmlCtrlFieldNumber = 3;
  inline const ::TvWall::Packet_Ctrl_ViewCtrl_HTMLCtrl& htmlctrl() const;
  inline ::TvWall::Packet_Ctrl_ViewCtrl_HTMLCtrl* mutable_htmlctrl();
  inline ::TvWall::Packet_Ctrl_ViewCtrl_HTMLCtrl* release_htmlctrl();
  inline void set_allocated_htmlctrl(::TvWall::Packet_Ctrl_ViewCtrl_HTMLCtrl* htmlctrl);

  // optional .TvWall.Packet.Ctrl.ViewCtrl.TextCtrl textCtrl = 4;
  inline bool has_textctrl() const;
  inline void clear_textctrl();
  static const int kTextCtrlFieldNumber = 4;
  inline const ::TvWall::Packet_Ctrl_ViewCtrl_TextCtrl& textctrl() const;
  inline ::TvWall::Packet_Ctrl_ViewCtrl_TextCtrl* mutable_textctrl();
  inline ::TvWall::Packet_Ctrl_ViewCtrl_TextCtrl* release_textctrl();
  inline void set_allocated_textctrl(::TvWall::Packet_Ctrl_ViewCtrl_TextCtrl* textctrl);

  // optional .TvWall.Packet.Ctrl.ViewCtrl.OthersCtrl othersCtrl = 5;
  inline bool has_othersctrl() const;
  inline void clear_othersctrl();
  static const int kOthersCtrlFieldNumber = 5;
  inline const ::TvWall::Packet_Ctrl_ViewCtrl_OthersCtrl& othersctrl() const;
  inline ::TvWall::Packet_Ctrl_ViewCtrl_OthersCtrl* mutable_othersctrl();
  inline ::TvWall::Packet_Ctrl_ViewCtrl_OthersCtrl* release_othersctrl();
  inline void set_allocated_othersctrl(::TvWall::Packet_Ctrl_ViewCtrl_OthersCtrl* othersctrl);

  // optional .TvWall.Packet.Ctrl.ViewCtrl.LocalMovieCtrl localMovie = 6;
  inline bool has_localmovie() const;
  inline void clear_localmovie();
  static const int kLocalMovieFieldNumber = 6;
  inline const ::TvWall::Packet_Ctrl_ViewCtrl_LocalMovieCtrl& localmovie() const;
  inline ::TvWall::Packet_Ctrl_ViewCtrl_LocalMovieCtrl* mutable_localmovie();
  inline ::TvWall::Packet_Ctrl_ViewCtrl_LocalMovieCtrl* release_localmovie();
  inline void set_allocated_localmovie(::TvWall::Packet_Ctrl_ViewCtrl_LocalMovieCtrl* localmovie);

  // optional .TvWall.Packet.Ctrl.ViewCtrl.ViewGeomotryCtrl viewGeomotryCtrl = 7;
  inline bool has_viewgeomotryctrl() const;
  inline void clear_viewgeomotryctrl();
  static const int kViewGeomotryCtrlFieldNumber = 7;
  inline const ::TvWall::Packet_Ctrl_ViewCtrl_ViewGeomotryCtrl& viewgeomotryctrl() const;
  inline ::TvWall::Packet_Ctrl_ViewCtrl_ViewGeomotryCtrl* mutable_viewgeomotryctrl();
  inline ::TvWall::Packet_Ctrl_ViewCtrl_ViewGeomotryCtrl* release_viewgeomotryctrl();
  inline void set_allocated_viewgeomotryctrl(::TvWall::Packet_Ctrl_ViewCtrl_ViewGeomotryCtrl* viewgeomotryctrl);

  // optional .TvWall.Packet.Ctrl.ViewCtrl.MapCtrl mapCtrl = 8;
  inline bool has_mapctrl() const;
  inline void clear_mapctrl();
  static const int kMapCtrlFieldNumber = 8;
  inline const ::TvWall::Packet_Ctrl_ViewCtrl_MapCtrl& mapctrl() const;
  inline ::TvWall::Packet_Ctrl_ViewCtrl_MapCtrl* mutable_mapctrl();
  inline ::TvWall::Packet_Ctrl_ViewCtrl_MapCtrl* release_mapctrl();
  inline void set_allocated_mapctrl(::TvWall::Packet_Ctrl_ViewCtrl_MapCtrl* mapctrl);

  // optional .TvWall.Packet.Ctrl.ViewCtrl.RecordCtrl recordCtrl = 9;
  inline bool has_recordctrl() const;
  inline void clear_recordctrl();
  static const int kRecordCtrlFieldNumber = 9;
  inline const ::TvWall::Packet_Ctrl_ViewCtrl_RecordCtrl& recordctrl() const;
  inline ::TvWall::Packet_Ctrl_ViewCtrl_RecordCtrl* mutable_recordctrl();
  inline ::TvWall::Packet_Ctrl_ViewCtrl_RecordCtrl* release_recordctrl();
  inline void set_allocated_recordctrl(::TvWall::Packet_Ctrl_ViewCtrl_RecordCtrl* recordctrl);

  // @@protoc_insertion_point(class_scope:TvWall.Packet.Ctrl.ViewCtrl)
 private:
  inline void set_has_videoctrl();
  inline void clear_has_videoctrl();
  inline void set_has_flashctrl();
  inline void clear_has_flashctrl();
  inline void set_has_htmlctrl();
  inline void clear_has_htmlctrl();
  inline void set_has_textctrl();
  inline void clear_has_textctrl();
  inline void set_has_othersctrl();
  inline void clear_has_othersctrl();
  inline void set_has_localmovie();
  inline void clear_has_localmovie();
  inline void set_has_viewgeomotryctrl();
  inline void clear_has_viewgeomotryctrl();
  inline void set_has_mapctrl();
  inline void clear_has_mapctrl();
  inline void set_has_recordctrl();
  inline void clear_has_recordctrl();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TvWall::Packet_Ctrl_ViewCtrl_VideoCtrl* videoctrl_;
  ::TvWall::Packet_Ctrl_ViewCtrl_FlashCtrl* flashctrl_;
  ::TvWall::Packet_Ctrl_ViewCtrl_HTMLCtrl* htmlctrl_;
  ::TvWall::Packet_Ctrl_ViewCtrl_TextCtrl* textctrl_;
  ::TvWall::Packet_Ctrl_ViewCtrl_OthersCtrl* othersctrl_;
  ::TvWall::Packet_Ctrl_ViewCtrl_LocalMovieCtrl* localmovie_;
  ::TvWall::Packet_Ctrl_ViewCtrl_ViewGeomotryCtrl* viewgeomotryctrl_;
  ::TvWall::Packet_Ctrl_ViewCtrl_MapCtrl* mapctrl_;
  ::TvWall::Packet_Ctrl_ViewCtrl_RecordCtrl* recordctrl_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];

  friend void  protobuf_AddDesc_protobuf_2ftvWall_2eproto();
  friend void protobuf_AssignDesc_protobuf_2ftvWall_2eproto();
  friend void protobuf_ShutdownFile_protobuf_2ftvWall_2eproto();

  void InitAsDefaultInstance();
  static Packet_Ctrl_ViewCtrl* default_instance_;
};
// -------------------------------------------------------------------

class Packet_Ctrl_CameraCtrl : public ::google::protobuf::Message {
 public:
  Packet_Ctrl_CameraCtrl();
  virtual ~Packet_Ctrl_CameraCtrl();

  Packet_Ctrl_CameraCtrl(const Packet_Ctrl_CameraCtrl& from);

  inline Packet_Ctrl_CameraCtrl& operator=(const Packet_Ctrl_CameraCtrl& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Packet_Ctrl_CameraCtrl& default_instance();

  void Swap(Packet_Ctrl_CameraCtrl* other);

  // implements Message ----------------------------------------------

  Packet_Ctrl_CameraCtrl* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Packet_Ctrl_CameraCtrl& from);
  void MergeFrom(const Packet_Ctrl_CameraCtrl& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Packet_Ctrl_CameraCtrl_PTZ_TYPE PTZ_TYPE;
  static const PTZ_TYPE LEFT = Packet_Ctrl_CameraCtrl_PTZ_TYPE_LEFT;
  static const PTZ_TYPE RIGHT = Packet_Ctrl_CameraCtrl_PTZ_TYPE_RIGHT;
  static const PTZ_TYPE UP = Packet_Ctrl_CameraCtrl_PTZ_TYPE_UP;
  static const PTZ_TYPE DOWN = Packet_Ctrl_CameraCtrl_PTZ_TYPE_DOWN;
  static inline bool PTZ_TYPE_IsValid(int value) {
    return Packet_Ctrl_CameraCtrl_PTZ_TYPE_IsValid(value);
  }
  static const PTZ_TYPE PTZ_TYPE_MIN =
    Packet_Ctrl_CameraCtrl_PTZ_TYPE_PTZ_TYPE_MIN;
  static const PTZ_TYPE PTZ_TYPE_MAX =
    Packet_Ctrl_CameraCtrl_PTZ_TYPE_PTZ_TYPE_MAX;
  static const int PTZ_TYPE_ARRAYSIZE =
    Packet_Ctrl_CameraCtrl_PTZ_TYPE_PTZ_TYPE_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  PTZ_TYPE_descriptor() {
    return Packet_Ctrl_CameraCtrl_PTZ_TYPE_descriptor();
  }
  static inline const ::std::string& PTZ_TYPE_Name(PTZ_TYPE value) {
    return Packet_Ctrl_CameraCtrl_PTZ_TYPE_Name(value);
  }
  static inline bool PTZ_TYPE_Parse(const ::std::string& name,
      PTZ_TYPE* value) {
    return Packet_Ctrl_CameraCtrl_PTZ_TYPE_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .TvWall.Packet.Ctrl.CameraCtrl.PTZ_TYPE type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::TvWall::Packet_Ctrl_CameraCtrl_PTZ_TYPE type() const;
  inline void set_type(::TvWall::Packet_Ctrl_CameraCtrl_PTZ_TYPE value);

  // required .TvWall.Guid cameraId = 2;
  inline bool has_cameraid() const;
  inline void clear_cameraid();
  static const int kCameraIdFieldNumber = 2;
  inline const ::TvWall::Guid& cameraid() const;
  inline ::TvWall::Guid* mutable_cameraid();
  inline ::TvWall::Guid* release_cameraid();
  inline void set_allocated_cameraid(::TvWall::Guid* cameraid);

  // @@protoc_insertion_point(class_scope:TvWall.Packet.Ctrl.CameraCtrl)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_cameraid();
  inline void clear_has_cameraid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TvWall::Guid* cameraid_;
  int type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_protobuf_2ftvWall_2eproto();
  friend void protobuf_AssignDesc_protobuf_2ftvWall_2eproto();
  friend void protobuf_ShutdownFile_protobuf_2ftvWall_2eproto();

  void InitAsDefaultInstance();
  static Packet_Ctrl_CameraCtrl* default_instance_;
};
// -------------------------------------------------------------------

class Packet_Ctrl_HotPointCtrl : public ::google::protobuf::Message {
 public:
  Packet_Ctrl_HotPointCtrl();
  virtual ~Packet_Ctrl_HotPointCtrl();

  Packet_Ctrl_HotPointCtrl(const Packet_Ctrl_HotPointCtrl& from);

  inline Packet_Ctrl_HotPointCtrl& operator=(const Packet_Ctrl_HotPointCtrl& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Packet_Ctrl_HotPointCtrl& default_instance();

  void Swap(Packet_Ctrl_HotPointCtrl* other);

  // implements Message ----------------------------------------------

  Packet_Ctrl_HotPointCtrl* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Packet_Ctrl_HotPointCtrl& from);
  void MergeFrom(const Packet_Ctrl_HotPointCtrl& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Packet_Ctrl_HotPointCtrl_HotPointCtrlType HotPointCtrlType;
  static const HotPointCtrlType CREATE = Packet_Ctrl_HotPointCtrl_HotPointCtrlType_CREATE;
  static const HotPointCtrlType REMOVE = Packet_Ctrl_HotPointCtrl_HotPointCtrlType_REMOVE;
  static const HotPointCtrlType RESET = Packet_Ctrl_HotPointCtrl_HotPointCtrlType_RESET;
  static const HotPointCtrlType RESET_SCREEN = Packet_Ctrl_HotPointCtrl_HotPointCtrlType_RESET_SCREEN;
  static inline bool HotPointCtrlType_IsValid(int value) {
    return Packet_Ctrl_HotPointCtrl_HotPointCtrlType_IsValid(value);
  }
  static const HotPointCtrlType HotPointCtrlType_MIN =
    Packet_Ctrl_HotPointCtrl_HotPointCtrlType_HotPointCtrlType_MIN;
  static const HotPointCtrlType HotPointCtrlType_MAX =
    Packet_Ctrl_HotPointCtrl_HotPointCtrlType_HotPointCtrlType_MAX;
  static const int HotPointCtrlType_ARRAYSIZE =
    Packet_Ctrl_HotPointCtrl_HotPointCtrlType_HotPointCtrlType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  HotPointCtrlType_descriptor() {
    return Packet_Ctrl_HotPointCtrl_HotPointCtrlType_descriptor();
  }
  static inline const ::std::string& HotPointCtrlType_Name(HotPointCtrlType value) {
    return Packet_Ctrl_HotPointCtrl_HotPointCtrlType_Name(value);
  }
  static inline bool HotPointCtrlType_Parse(const ::std::string& name,
      HotPointCtrlType* value) {
    return Packet_Ctrl_HotPointCtrl_HotPointCtrlType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .TvWall.Packet.Ctrl.HotPointCtrl.HotPointCtrlType type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::TvWall::Packet_Ctrl_HotPointCtrl_HotPointCtrlType type() const;
  inline void set_type(::TvWall::Packet_Ctrl_HotPointCtrl_HotPointCtrlType value);

  // optional .TvWall.Packet.ElementDat.HotPoint hotPoint = 2;
  inline bool has_hotpoint() const;
  inline void clear_hotpoint();
  static const int kHotPointFieldNumber = 2;
  inline const ::TvWall::Packet_ElementDat_HotPoint& hotpoint() const;
  inline ::TvWall::Packet_ElementDat_HotPoint* mutable_hotpoint();
  inline ::TvWall::Packet_ElementDat_HotPoint* release_hotpoint();
  inline void set_allocated_hotpoint(::TvWall::Packet_ElementDat_HotPoint* hotpoint);

  // @@protoc_insertion_point(class_scope:TvWall.Packet.Ctrl.HotPointCtrl)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_hotpoint();
  inline void clear_has_hotpoint();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TvWall::Packet_ElementDat_HotPoint* hotpoint_;
  int type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_protobuf_2ftvWall_2eproto();
  friend void protobuf_AssignDesc_protobuf_2ftvWall_2eproto();
  friend void protobuf_ShutdownFile_protobuf_2ftvWall_2eproto();

  void InitAsDefaultInstance();
  static Packet_Ctrl_HotPointCtrl* default_instance_;
};
// -------------------------------------------------------------------

class Packet_Ctrl_LayoutCtrl : public ::google::protobuf::Message {
 public:
  Packet_Ctrl_LayoutCtrl();
  virtual ~Packet_Ctrl_LayoutCtrl();

  Packet_Ctrl_LayoutCtrl(const Packet_Ctrl_LayoutCtrl& from);

  inline Packet_Ctrl_LayoutCtrl& operator=(const Packet_Ctrl_LayoutCtrl& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Packet_Ctrl_LayoutCtrl& default_instance();

  void Swap(Packet_Ctrl_LayoutCtrl* other);

  // implements Message ----------------------------------------------

  Packet_Ctrl_LayoutCtrl* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Packet_Ctrl_LayoutCtrl& from);
  void MergeFrom(const Packet_Ctrl_LayoutCtrl& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Packet_Ctrl_LayoutCtrl_LayoutCtrlType LayoutCtrlType;
  static const LayoutCtrlType SAVE_CURRENT = Packet_Ctrl_LayoutCtrl_LayoutCtrlType_SAVE_CURRENT;
  static const LayoutCtrlType DEL = Packet_Ctrl_LayoutCtrl_LayoutCtrlType_DEL;
  static const LayoutCtrlType USE = Packet_Ctrl_LayoutCtrl_LayoutCtrlType_USE;
  static inline bool LayoutCtrlType_IsValid(int value) {
    return Packet_Ctrl_LayoutCtrl_LayoutCtrlType_IsValid(value);
  }
  static const LayoutCtrlType LayoutCtrlType_MIN =
    Packet_Ctrl_LayoutCtrl_LayoutCtrlType_LayoutCtrlType_MIN;
  static const LayoutCtrlType LayoutCtrlType_MAX =
    Packet_Ctrl_LayoutCtrl_LayoutCtrlType_LayoutCtrlType_MAX;
  static const int LayoutCtrlType_ARRAYSIZE =
    Packet_Ctrl_LayoutCtrl_LayoutCtrlType_LayoutCtrlType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  LayoutCtrlType_descriptor() {
    return Packet_Ctrl_LayoutCtrl_LayoutCtrlType_descriptor();
  }
  static inline const ::std::string& LayoutCtrlType_Name(LayoutCtrlType value) {
    return Packet_Ctrl_LayoutCtrl_LayoutCtrlType_Name(value);
  }
  static inline bool LayoutCtrlType_Parse(const ::std::string& name,
      LayoutCtrlType* value) {
    return Packet_Ctrl_LayoutCtrl_LayoutCtrlType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required string lyoutName = 1;
  inline bool has_lyoutname() const;
  inline void clear_lyoutname();
  static const int kLyoutNameFieldNumber = 1;
  inline const ::std::string& lyoutname() const;
  inline void set_lyoutname(const ::std::string& value);
  inline void set_lyoutname(const char* value);
  inline void set_lyoutname(const char* value, size_t size);
  inline ::std::string* mutable_lyoutname();
  inline ::std::string* release_lyoutname();
  inline void set_allocated_lyoutname(::std::string* lyoutname);

  // required .TvWall.Packet.Ctrl.LayoutCtrl.LayoutCtrlType type = 3;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 3;
  inline ::TvWall::Packet_Ctrl_LayoutCtrl_LayoutCtrlType type() const;
  inline void set_type(::TvWall::Packet_Ctrl_LayoutCtrl_LayoutCtrlType value);

  // optional bool isalarm = 2;
  inline bool has_isalarm() const;
  inline void clear_isalarm();
  static const int kIsalarmFieldNumber = 2;
  inline bool isalarm() const;
  inline void set_isalarm(bool value);

  // optional int32 alarmInterval = 4;
  inline bool has_alarminterval() const;
  inline void clear_alarminterval();
  static const int kAlarmIntervalFieldNumber = 4;
  inline ::google::protobuf::int32 alarminterval() const;
  inline void set_alarminterval(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:TvWall.Packet.Ctrl.LayoutCtrl)
 private:
  inline void set_has_lyoutname();
  inline void clear_has_lyoutname();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_isalarm();
  inline void clear_has_isalarm();
  inline void set_has_alarminterval();
  inline void clear_has_alarminterval();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* lyoutname_;
  int type_;
  bool isalarm_;
  ::google::protobuf::int32 alarminterval_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_protobuf_2ftvWall_2eproto();
  friend void protobuf_AssignDesc_protobuf_2ftvWall_2eproto();
  friend void protobuf_ShutdownFile_protobuf_2ftvWall_2eproto();

  void InitAsDefaultInstance();
  static Packet_Ctrl_LayoutCtrl* default_instance_;
};
// -------------------------------------------------------------------

class Packet_Ctrl_LayoutLoopCtrl : public ::google::protobuf::Message {
 public:
  Packet_Ctrl_LayoutLoopCtrl();
  virtual ~Packet_Ctrl_LayoutLoopCtrl();

  Packet_Ctrl_LayoutLoopCtrl(const Packet_Ctrl_LayoutLoopCtrl& from);

  inline Packet_Ctrl_LayoutLoopCtrl& operator=(const Packet_Ctrl_LayoutLoopCtrl& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Packet_Ctrl_LayoutLoopCtrl& default_instance();

  void Swap(Packet_Ctrl_LayoutLoopCtrl* other);

  // implements Message ----------------------------------------------

  Packet_Ctrl_LayoutLoopCtrl* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Packet_Ctrl_LayoutLoopCtrl& from);
  void MergeFrom(const Packet_Ctrl_LayoutLoopCtrl& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Packet_Ctrl_LayoutLoopCtrl_LayoutLoopCtrlType LayoutLoopCtrlType;
  static const LayoutLoopCtrlType ADD = Packet_Ctrl_LayoutLoopCtrl_LayoutLoopCtrlType_ADD;
  static const LayoutLoopCtrlType REMOVE = Packet_Ctrl_LayoutLoopCtrl_LayoutLoopCtrlType_REMOVE;
  static const LayoutLoopCtrlType ADD_LAYOUT = Packet_Ctrl_LayoutLoopCtrl_LayoutLoopCtrlType_ADD_LAYOUT;
  static const LayoutLoopCtrlType USE = Packet_Ctrl_LayoutLoopCtrl_LayoutLoopCtrlType_USE;
  static const LayoutLoopCtrlType SET_LOOP = Packet_Ctrl_LayoutLoopCtrl_LayoutLoopCtrlType_SET_LOOP;
  static const LayoutLoopCtrlType STOP = Packet_Ctrl_LayoutLoopCtrl_LayoutLoopCtrlType_STOP;
  static inline bool LayoutLoopCtrlType_IsValid(int value) {
    return Packet_Ctrl_LayoutLoopCtrl_LayoutLoopCtrlType_IsValid(value);
  }
  static const LayoutLoopCtrlType LayoutLoopCtrlType_MIN =
    Packet_Ctrl_LayoutLoopCtrl_LayoutLoopCtrlType_LayoutLoopCtrlType_MIN;
  static const LayoutLoopCtrlType LayoutLoopCtrlType_MAX =
    Packet_Ctrl_LayoutLoopCtrl_LayoutLoopCtrlType_LayoutLoopCtrlType_MAX;
  static const int LayoutLoopCtrlType_ARRAYSIZE =
    Packet_Ctrl_LayoutLoopCtrl_LayoutLoopCtrlType_LayoutLoopCtrlType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  LayoutLoopCtrlType_descriptor() {
    return Packet_Ctrl_LayoutLoopCtrl_LayoutLoopCtrlType_descriptor();
  }
  static inline const ::std::string& LayoutLoopCtrlType_Name(LayoutLoopCtrlType value) {
    return Packet_Ctrl_LayoutLoopCtrl_LayoutLoopCtrlType_Name(value);
  }
  static inline bool LayoutLoopCtrlType_Parse(const ::std::string& name,
      LayoutLoopCtrlType* value) {
    return Packet_Ctrl_LayoutLoopCtrl_LayoutLoopCtrlType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required string lyoutLoopName = 1;
  inline bool has_lyoutloopname() const;
  inline void clear_lyoutloopname();
  static const int kLyoutLoopNameFieldNumber = 1;
  inline const ::std::string& lyoutloopname() const;
  inline void set_lyoutloopname(const ::std::string& value);
  inline void set_lyoutloopname(const char* value);
  inline void set_lyoutloopname(const char* value, size_t size);
  inline ::std::string* mutable_lyoutloopname();
  inline ::std::string* release_lyoutloopname();
  inline void set_allocated_lyoutloopname(::std::string* lyoutloopname);

  // required .TvWall.Packet.Ctrl.LayoutLoopCtrl.LayoutLoopCtrlType type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline ::TvWall::Packet_Ctrl_LayoutLoopCtrl_LayoutLoopCtrlType type() const;
  inline void set_type(::TvWall::Packet_Ctrl_LayoutLoopCtrl_LayoutLoopCtrlType value);

  // repeated string layoutName = 3;
  inline int layoutname_size() const;
  inline void clear_layoutname();
  static const int kLayoutNameFieldNumber = 3;
  inline const ::std::string& layoutname(int index) const;
  inline ::std::string* mutable_layoutname(int index);
  inline void set_layoutname(int index, const ::std::string& value);
  inline void set_layoutname(int index, const char* value);
  inline void set_layoutname(int index, const char* value, size_t size);
  inline ::std::string* add_layoutname();
  inline void add_layoutname(const ::std::string& value);
  inline void add_layoutname(const char* value);
  inline void add_layoutname(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& layoutname() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_layoutname();

  // optional uint32 loop = 4;
  inline bool has_loop() const;
  inline void clear_loop();
  static const int kLoopFieldNumber = 4;
  inline ::google::protobuf::uint32 loop() const;
  inline void set_loop(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:TvWall.Packet.Ctrl.LayoutLoopCtrl)
 private:
  inline void set_has_lyoutloopname();
  inline void clear_has_lyoutloopname();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_loop();
  inline void clear_has_loop();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* lyoutloopname_;
  ::google::protobuf::RepeatedPtrField< ::std::string> layoutname_;
  int type_;
  ::google::protobuf::uint32 loop_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_protobuf_2ftvWall_2eproto();
  friend void protobuf_AssignDesc_protobuf_2ftvWall_2eproto();
  friend void protobuf_ShutdownFile_protobuf_2ftvWall_2eproto();

  void InitAsDefaultInstance();
  static Packet_Ctrl_LayoutLoopCtrl* default_instance_;
};
// -------------------------------------------------------------------

class Packet_Ctrl_CtrlMaster_CtrlMasterLyout : public ::google::protobuf::Message {
 public:
  Packet_Ctrl_CtrlMaster_CtrlMasterLyout();
  virtual ~Packet_Ctrl_CtrlMaster_CtrlMasterLyout();

  Packet_Ctrl_CtrlMaster_CtrlMasterLyout(const Packet_Ctrl_CtrlMaster_CtrlMasterLyout& from);

  inline Packet_Ctrl_CtrlMaster_CtrlMasterLyout& operator=(const Packet_Ctrl_CtrlMaster_CtrlMasterLyout& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Packet_Ctrl_CtrlMaster_CtrlMasterLyout& default_instance();

  void Swap(Packet_Ctrl_CtrlMaster_CtrlMasterLyout* other);

  // implements Message ----------------------------------------------

  Packet_Ctrl_CtrlMaster_CtrlMasterLyout* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Packet_Ctrl_CtrlMaster_CtrlMasterLyout& from);
  void MergeFrom(const Packet_Ctrl_CtrlMaster_CtrlMasterLyout& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Packet_Ctrl_CtrlMaster_CtrlMasterLyout_CMLType CMLType;
  static const CMLType SAVE = Packet_Ctrl_CtrlMaster_CtrlMasterLyout_CMLType_SAVE;
  static const CMLType DEL = Packet_Ctrl_CtrlMaster_CtrlMasterLyout_CMLType_DEL;
  static inline bool CMLType_IsValid(int value) {
    return Packet_Ctrl_CtrlMaster_CtrlMasterLyout_CMLType_IsValid(value);
  }
  static const CMLType CMLType_MIN =
    Packet_Ctrl_CtrlMaster_CtrlMasterLyout_CMLType_CMLType_MIN;
  static const CMLType CMLType_MAX =
    Packet_Ctrl_CtrlMaster_CtrlMasterLyout_CMLType_CMLType_MAX;
  static const int CMLType_ARRAYSIZE =
    Packet_Ctrl_CtrlMaster_CtrlMasterLyout_CMLType_CMLType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  CMLType_descriptor() {
    return Packet_Ctrl_CtrlMaster_CtrlMasterLyout_CMLType_descriptor();
  }
  static inline const ::std::string& CMLType_Name(CMLType value) {
    return Packet_Ctrl_CtrlMaster_CtrlMasterLyout_CMLType_Name(value);
  }
  static inline bool CMLType_Parse(const ::std::string& name,
      CMLType* value) {
    return Packet_Ctrl_CtrlMaster_CtrlMasterLyout_CMLType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .TvWall.Packet.Ctrl.CtrlMaster.CtrlMasterLyout.CMLType type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::TvWall::Packet_Ctrl_CtrlMaster_CtrlMasterLyout_CMLType type() const;
  inline void set_type(::TvWall::Packet_Ctrl_CtrlMaster_CtrlMasterLyout_CMLType value);

  // required .TvWall.Packet.ElementMaster.MasterLayout.MasLayout masterLayout = 2;
  inline bool has_masterlayout() const;
  inline void clear_masterlayout();
  static const int kMasterLayoutFieldNumber = 2;
  inline const ::TvWall::Packet_ElementMaster_MasterLayout_MasLayout& masterlayout() const;
  inline ::TvWall::Packet_ElementMaster_MasterLayout_MasLayout* mutable_masterlayout();
  inline ::TvWall::Packet_ElementMaster_MasterLayout_MasLayout* release_masterlayout();
  inline void set_allocated_masterlayout(::TvWall::Packet_ElementMaster_MasterLayout_MasLayout* masterlayout);

  // @@protoc_insertion_point(class_scope:TvWall.Packet.Ctrl.CtrlMaster.CtrlMasterLyout)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_masterlayout();
  inline void clear_has_masterlayout();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TvWall::Packet_ElementMaster_MasterLayout_MasLayout* masterlayout_;
  int type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_protobuf_2ftvWall_2eproto();
  friend void protobuf_AssignDesc_protobuf_2ftvWall_2eproto();
  friend void protobuf_ShutdownFile_protobuf_2ftvWall_2eproto();

  void InitAsDefaultInstance();
  static Packet_Ctrl_CtrlMaster_CtrlMasterLyout* default_instance_;
};
// -------------------------------------------------------------------

class Packet_Ctrl_CtrlMaster : public ::google::protobuf::Message {
 public:
  Packet_Ctrl_CtrlMaster();
  virtual ~Packet_Ctrl_CtrlMaster();

  Packet_Ctrl_CtrlMaster(const Packet_Ctrl_CtrlMaster& from);

  inline Packet_Ctrl_CtrlMaster& operator=(const Packet_Ctrl_CtrlMaster& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Packet_Ctrl_CtrlMaster& default_instance();

  void Swap(Packet_Ctrl_CtrlMaster* other);

  // implements Message ----------------------------------------------

  Packet_Ctrl_CtrlMaster* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Packet_Ctrl_CtrlMaster& from);
  void MergeFrom(const Packet_Ctrl_CtrlMaster& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Packet_Ctrl_CtrlMaster_CtrlMasterLyout CtrlMasterLyout;

  // accessors -------------------------------------------------------

  // optional .TvWall.Packet.Ctrl.CtrlMaster.CtrlMasterLyout ctrlLyout = 1;
  inline bool has_ctrllyout() const;
  inline void clear_ctrllyout();
  static const int kCtrlLyoutFieldNumber = 1;
  inline const ::TvWall::Packet_Ctrl_CtrlMaster_CtrlMasterLyout& ctrllyout() const;
  inline ::TvWall::Packet_Ctrl_CtrlMaster_CtrlMasterLyout* mutable_ctrllyout();
  inline ::TvWall::Packet_Ctrl_CtrlMaster_CtrlMasterLyout* release_ctrllyout();
  inline void set_allocated_ctrllyout(::TvWall::Packet_Ctrl_CtrlMaster_CtrlMasterLyout* ctrllyout);

  // @@protoc_insertion_point(class_scope:TvWall.Packet.Ctrl.CtrlMaster)
 private:
  inline void set_has_ctrllyout();
  inline void clear_has_ctrllyout();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TvWall::Packet_Ctrl_CtrlMaster_CtrlMasterLyout* ctrllyout_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_protobuf_2ftvWall_2eproto();
  friend void protobuf_AssignDesc_protobuf_2ftvWall_2eproto();
  friend void protobuf_ShutdownFile_protobuf_2ftvWall_2eproto();

  void InitAsDefaultInstance();
  static Packet_Ctrl_CtrlMaster* default_instance_;
};
// -------------------------------------------------------------------

class Packet_Ctrl_MachineCtrl : public ::google::protobuf::Message {
 public:
  Packet_Ctrl_MachineCtrl();
  virtual ~Packet_Ctrl_MachineCtrl();

  Packet_Ctrl_MachineCtrl(const Packet_Ctrl_MachineCtrl& from);

  inline Packet_Ctrl_MachineCtrl& operator=(const Packet_Ctrl_MachineCtrl& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Packet_Ctrl_MachineCtrl& default_instance();

  void Swap(Packet_Ctrl_MachineCtrl* other);

  // implements Message ----------------------------------------------

  Packet_Ctrl_MachineCtrl* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Packet_Ctrl_MachineCtrl& from);
  void MergeFrom(const Packet_Ctrl_MachineCtrl& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Packet_Ctrl_MachineCtrl_MachineCtrlType MachineCtrlType;
  static const MachineCtrlType REBOOT = Packet_Ctrl_MachineCtrl_MachineCtrlType_REBOOT;
  static const MachineCtrlType SOFT_REBOOT = Packet_Ctrl_MachineCtrl_MachineCtrlType_SOFT_REBOOT;
  static const MachineCtrlType SET_SCREEN = Packet_Ctrl_MachineCtrl_MachineCtrlType_SET_SCREEN;
  static const MachineCtrlType POWEROFF = Packet_Ctrl_MachineCtrl_MachineCtrlType_POWEROFF;
  static const MachineCtrlType NET_HOST = Packet_Ctrl_MachineCtrl_MachineCtrlType_NET_HOST;
  static const MachineCtrlType NET_GATEWAY = Packet_Ctrl_MachineCtrl_MachineCtrlType_NET_GATEWAY;
  static const MachineCtrlType NET_INTERFACE = Packet_Ctrl_MachineCtrl_MachineCtrlType_NET_INTERFACE;
  static const MachineCtrlType NVR_ADD = Packet_Ctrl_MachineCtrl_MachineCtrlType_NVR_ADD;
  static const MachineCtrlType NVR_DEL = Packet_Ctrl_MachineCtrl_MachineCtrlType_NVR_DEL;
  static const MachineCtrlType FMP = Packet_Ctrl_MachineCtrl_MachineCtrlType_FMP;
  static const MachineCtrlType TVWALL_INDEX = Packet_Ctrl_MachineCtrl_MachineCtrlType_TVWALL_INDEX;
  static inline bool MachineCtrlType_IsValid(int value) {
    return Packet_Ctrl_MachineCtrl_MachineCtrlType_IsValid(value);
  }
  static const MachineCtrlType MachineCtrlType_MIN =
    Packet_Ctrl_MachineCtrl_MachineCtrlType_MachineCtrlType_MIN;
  static const MachineCtrlType MachineCtrlType_MAX =
    Packet_Ctrl_MachineCtrl_MachineCtrlType_MachineCtrlType_MAX;
  static const int MachineCtrlType_ARRAYSIZE =
    Packet_Ctrl_MachineCtrl_MachineCtrlType_MachineCtrlType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  MachineCtrlType_descriptor() {
    return Packet_Ctrl_MachineCtrl_MachineCtrlType_descriptor();
  }
  static inline const ::std::string& MachineCtrlType_Name(MachineCtrlType value) {
    return Packet_Ctrl_MachineCtrl_MachineCtrlType_Name(value);
  }
  static inline bool MachineCtrlType_Parse(const ::std::string& name,
      MachineCtrlType* value) {
    return Packet_Ctrl_MachineCtrl_MachineCtrlType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .TvWall.Packet.Ctrl.MachineCtrl.MachineCtrlType type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::TvWall::Packet_Ctrl_MachineCtrl_MachineCtrlType type() const;
  inline void set_type(::TvWall::Packet_Ctrl_MachineCtrl_MachineCtrlType value);

  // optional string screenMode = 2;
  inline bool has_screenmode() const;
  inline void clear_screenmode();
  static const int kScreenModeFieldNumber = 2;
  inline const ::std::string& screenmode() const;
  inline void set_screenmode(const ::std::string& value);
  inline void set_screenmode(const char* value);
  inline void set_screenmode(const char* value, size_t size);
  inline ::std::string* mutable_screenmode();
  inline ::std::string* release_screenmode();
  inline void set_allocated_screenmode(::std::string* screenmode);

  // optional .TvWall.NetInterface netInterface = 3;
  inline bool has_netinterface() const;
  inline void clear_netinterface();
  static const int kNetInterfaceFieldNumber = 3;
  inline const ::TvWall::NetInterface& netinterface() const;
  inline ::TvWall::NetInterface* mutable_netinterface();
  inline ::TvWall::NetInterface* release_netinterface();
  inline void set_allocated_netinterface(::TvWall::NetInterface* netinterface);

  // optional .TvWall.Network network = 4;
  inline bool has_network() const;
  inline void clear_network();
  static const int kNetworkFieldNumber = 4;
  inline const ::TvWall::Network& network() const;
  inline ::TvWall::Network* mutable_network();
  inline ::TvWall::Network* release_network();
  inline void set_allocated_network(::TvWall::Network* network);

  // optional .TvWall.NVR nvr = 5;
  inline bool has_nvr() const;
  inline void clear_nvr();
  static const int kNvrFieldNumber = 5;
  inline const ::TvWall::NVR& nvr() const;
  inline ::TvWall::NVR* mutable_nvr();
  inline ::TvWall::NVR* release_nvr();
  inline void set_allocated_nvr(::TvWall::NVR* nvr);

  // optional .TvWall.FMP fmp = 6;
  inline bool has_fmp() const;
  inline void clear_fmp();
  static const int kFmpFieldNumber = 6;
  inline const ::TvWall::FMP& fmp() const;
  inline ::TvWall::FMP* mutable_fmp();
  inline ::TvWall::FMP* release_fmp();
  inline void set_allocated_fmp(::TvWall::FMP* fmp);

  // optional int32 tvwallindex = 7;
  inline bool has_tvwallindex() const;
  inline void clear_tvwallindex();
  static const int kTvwallindexFieldNumber = 7;
  inline ::google::protobuf::int32 tvwallindex() const;
  inline void set_tvwallindex(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:TvWall.Packet.Ctrl.MachineCtrl)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_screenmode();
  inline void clear_has_screenmode();
  inline void set_has_netinterface();
  inline void clear_has_netinterface();
  inline void set_has_network();
  inline void clear_has_network();
  inline void set_has_nvr();
  inline void clear_has_nvr();
  inline void set_has_fmp();
  inline void clear_has_fmp();
  inline void set_has_tvwallindex();
  inline void clear_has_tvwallindex();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* screenmode_;
  ::TvWall::NetInterface* netinterface_;
  ::TvWall::Network* network_;
  int type_;
  ::google::protobuf::int32 tvwallindex_;
  ::TvWall::NVR* nvr_;
  ::TvWall::FMP* fmp_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_protobuf_2ftvWall_2eproto();
  friend void protobuf_AssignDesc_protobuf_2ftvWall_2eproto();
  friend void protobuf_ShutdownFile_protobuf_2ftvWall_2eproto();

  void InitAsDefaultInstance();
  static Packet_Ctrl_MachineCtrl* default_instance_;
};
// -------------------------------------------------------------------

class Packet_Ctrl_KeyCtrl : public ::google::protobuf::Message {
 public:
  Packet_Ctrl_KeyCtrl();
  virtual ~Packet_Ctrl_KeyCtrl();

  Packet_Ctrl_KeyCtrl(const Packet_Ctrl_KeyCtrl& from);

  inline Packet_Ctrl_KeyCtrl& operator=(const Packet_Ctrl_KeyCtrl& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Packet_Ctrl_KeyCtrl& default_instance();

  void Swap(Packet_Ctrl_KeyCtrl* other);

  // implements Message ----------------------------------------------

  Packet_Ctrl_KeyCtrl* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Packet_Ctrl_KeyCtrl& from);
  void MergeFrom(const Packet_Ctrl_KeyCtrl& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Packet_Ctrl_KeyCtrl_KeyType KeyType;
  static const KeyType KeyPress = Packet_Ctrl_KeyCtrl_KeyType_KeyPress;
  static const KeyType KeyRelease = Packet_Ctrl_KeyCtrl_KeyType_KeyRelease;
  static const KeyType ShortcutOverride = Packet_Ctrl_KeyCtrl_KeyType_ShortcutOverride;
  static inline bool KeyType_IsValid(int value) {
    return Packet_Ctrl_KeyCtrl_KeyType_IsValid(value);
  }
  static const KeyType KeyType_MIN =
    Packet_Ctrl_KeyCtrl_KeyType_KeyType_MIN;
  static const KeyType KeyType_MAX =
    Packet_Ctrl_KeyCtrl_KeyType_KeyType_MAX;
  static const int KeyType_ARRAYSIZE =
    Packet_Ctrl_KeyCtrl_KeyType_KeyType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  KeyType_descriptor() {
    return Packet_Ctrl_KeyCtrl_KeyType_descriptor();
  }
  static inline const ::std::string& KeyType_Name(KeyType value) {
    return Packet_Ctrl_KeyCtrl_KeyType_Name(value);
  }
  static inline bool KeyType_Parse(const ::std::string& name,
      KeyType* value) {
    return Packet_Ctrl_KeyCtrl_KeyType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .TvWall.Packet.Ctrl.KeyCtrl.KeyType type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::TvWall::Packet_Ctrl_KeyCtrl_KeyType type() const;
  inline void set_type(::TvWall::Packet_Ctrl_KeyCtrl_KeyType value);

  // required int32 key = 2;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 2;
  inline ::google::protobuf::int32 key() const;
  inline void set_key(::google::protobuf::int32 value);

  // required int32 modifiers = 3;
  inline bool has_modifiers() const;
  inline void clear_modifiers();
  static const int kModifiersFieldNumber = 3;
  inline ::google::protobuf::int32 modifiers() const;
  inline void set_modifiers(::google::protobuf::int32 value);

  // optional string text = 4;
  inline bool has_text() const;
  inline void clear_text();
  static const int kTextFieldNumber = 4;
  inline const ::std::string& text() const;
  inline void set_text(const ::std::string& value);
  inline void set_text(const char* value);
  inline void set_text(const char* value, size_t size);
  inline ::std::string* mutable_text();
  inline ::std::string* release_text();
  inline void set_allocated_text(::std::string* text);

  // optional bool autoRepeat = 5;
  inline bool has_autorepeat() const;
  inline void clear_autorepeat();
  static const int kAutoRepeatFieldNumber = 5;
  inline bool autorepeat() const;
  inline void set_autorepeat(bool value);

  // optional int32 count = 6;
  inline bool has_count() const;
  inline void clear_count();
  static const int kCountFieldNumber = 6;
  inline ::google::protobuf::int32 count() const;
  inline void set_count(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:TvWall.Packet.Ctrl.KeyCtrl)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_key();
  inline void clear_has_key();
  inline void set_has_modifiers();
  inline void clear_has_modifiers();
  inline void set_has_text();
  inline void clear_has_text();
  inline void set_has_autorepeat();
  inline void clear_has_autorepeat();
  inline void set_has_count();
  inline void clear_has_count();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int type_;
  ::google::protobuf::int32 key_;
  ::std::string* text_;
  ::google::protobuf::int32 modifiers_;
  bool autorepeat_;
  ::google::protobuf::int32 count_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_protobuf_2ftvWall_2eproto();
  friend void protobuf_AssignDesc_protobuf_2ftvWall_2eproto();
  friend void protobuf_ShutdownFile_protobuf_2ftvWall_2eproto();

  void InitAsDefaultInstance();
  static Packet_Ctrl_KeyCtrl* default_instance_;
};
// -------------------------------------------------------------------

class Packet_Ctrl_KeyCmdCtrl : public ::google::protobuf::Message {
 public:
  Packet_Ctrl_KeyCmdCtrl();
  virtual ~Packet_Ctrl_KeyCmdCtrl();

  Packet_Ctrl_KeyCmdCtrl(const Packet_Ctrl_KeyCmdCtrl& from);

  inline Packet_Ctrl_KeyCmdCtrl& operator=(const Packet_Ctrl_KeyCmdCtrl& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Packet_Ctrl_KeyCmdCtrl& default_instance();

  void Swap(Packet_Ctrl_KeyCmdCtrl* other);

  // implements Message ----------------------------------------------

  Packet_Ctrl_KeyCmdCtrl* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Packet_Ctrl_KeyCmdCtrl& from);
  void MergeFrom(const Packet_Ctrl_KeyCmdCtrl& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Packet_Ctrl_KeyCmdCtrl_KeyCmdType KeyCmdType;
  static const KeyCmdType Media = Packet_Ctrl_KeyCmdCtrl_KeyCmdType_Media;
  static const KeyCmdType Ptz = Packet_Ctrl_KeyCmdCtrl_KeyCmdType_Ptz;
  static const KeyCmdType Preset = Packet_Ctrl_KeyCmdCtrl_KeyCmdType_Preset;
  static const KeyCmdType tour = Packet_Ctrl_KeyCmdCtrl_KeyCmdType_tour;
  static inline bool KeyCmdType_IsValid(int value) {
    return Packet_Ctrl_KeyCmdCtrl_KeyCmdType_IsValid(value);
  }
  static const KeyCmdType KeyCmdType_MIN =
    Packet_Ctrl_KeyCmdCtrl_KeyCmdType_KeyCmdType_MIN;
  static const KeyCmdType KeyCmdType_MAX =
    Packet_Ctrl_KeyCmdCtrl_KeyCmdType_KeyCmdType_MAX;
  static const int KeyCmdType_ARRAYSIZE =
    Packet_Ctrl_KeyCmdCtrl_KeyCmdType_KeyCmdType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  KeyCmdType_descriptor() {
    return Packet_Ctrl_KeyCmdCtrl_KeyCmdType_descriptor();
  }
  static inline const ::std::string& KeyCmdType_Name(KeyCmdType value) {
    return Packet_Ctrl_KeyCmdCtrl_KeyCmdType_Name(value);
  }
  static inline bool KeyCmdType_Parse(const ::std::string& name,
      KeyCmdType* value) {
    return Packet_Ctrl_KeyCmdCtrl_KeyCmdType_Parse(name, value);
  }

  typedef Packet_Ctrl_KeyCmdCtrl_KeyType KeyType;
  static const KeyType KeyPress = Packet_Ctrl_KeyCmdCtrl_KeyType_KeyPress;
  static const KeyType KeyRelease = Packet_Ctrl_KeyCmdCtrl_KeyType_KeyRelease;
  static inline bool KeyType_IsValid(int value) {
    return Packet_Ctrl_KeyCmdCtrl_KeyType_IsValid(value);
  }
  static const KeyType KeyType_MIN =
    Packet_Ctrl_KeyCmdCtrl_KeyType_KeyType_MIN;
  static const KeyType KeyType_MAX =
    Packet_Ctrl_KeyCmdCtrl_KeyType_KeyType_MAX;
  static const int KeyType_ARRAYSIZE =
    Packet_Ctrl_KeyCmdCtrl_KeyType_KeyType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  KeyType_descriptor() {
    return Packet_Ctrl_KeyCmdCtrl_KeyType_descriptor();
  }
  static inline const ::std::string& KeyType_Name(KeyType value) {
    return Packet_Ctrl_KeyCmdCtrl_KeyType_Name(value);
  }
  static inline bool KeyType_Parse(const ::std::string& name,
      KeyType* value) {
    return Packet_Ctrl_KeyCmdCtrl_KeyType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .TvWall.Packet.Ctrl.KeyCmdCtrl.KeyCmdType type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::TvWall::Packet_Ctrl_KeyCmdCtrl_KeyCmdType type() const;
  inline void set_type(::TvWall::Packet_Ctrl_KeyCmdCtrl_KeyCmdType value);

  // optional int32 screenIdx = 2;
  inline bool has_screenidx() const;
  inline void clear_screenidx();
  static const int kScreenIdxFieldNumber = 2;
  inline ::google::protobuf::int32 screenidx() const;
  inline void set_screenidx(::google::protobuf::int32 value);

  // optional int32 camPosIdx = 3;
  inline bool has_camposidx() const;
  inline void clear_camposidx();
  static const int kCamPosIdxFieldNumber = 3;
  inline ::google::protobuf::int32 camposidx() const;
  inline void set_camposidx(::google::protobuf::int32 value);

  // optional int32 key = 4;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 4;
  inline ::google::protobuf::int32 key() const;
  inline void set_key(::google::protobuf::int32 value);

  // optional .TvWall.Packet.Ctrl.KeyCmdCtrl.KeyType keyType = 5;
  inline bool has_keytype() const;
  inline void clear_keytype();
  static const int kKeyTypeFieldNumber = 5;
  inline ::TvWall::Packet_Ctrl_KeyCmdCtrl_KeyType keytype() const;
  inline void set_keytype(::TvWall::Packet_Ctrl_KeyCmdCtrl_KeyType value);

  // optional string text = 6;
  inline bool has_text() const;
  inline void clear_text();
  static const int kTextFieldNumber = 6;
  inline const ::std::string& text() const;
  inline void set_text(const ::std::string& value);
  inline void set_text(const char* value);
  inline void set_text(const char* value, size_t size);
  inline ::std::string* mutable_text();
  inline ::std::string* release_text();
  inline void set_allocated_text(::std::string* text);

  // optional string cam_guid = 7;
  inline bool has_cam_guid() const;
  inline void clear_cam_guid();
  static const int kCamGuidFieldNumber = 7;
  inline const ::std::string& cam_guid() const;
  inline void set_cam_guid(const ::std::string& value);
  inline void set_cam_guid(const char* value);
  inline void set_cam_guid(const char* value, size_t size);
  inline ::std::string* mutable_cam_guid();
  inline ::std::string* release_cam_guid();
  inline void set_allocated_cam_guid(::std::string* cam_guid);

  // @@protoc_insertion_point(class_scope:TvWall.Packet.Ctrl.KeyCmdCtrl)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_screenidx();
  inline void clear_has_screenidx();
  inline void set_has_camposidx();
  inline void clear_has_camposidx();
  inline void set_has_key();
  inline void clear_has_key();
  inline void set_has_keytype();
  inline void clear_has_keytype();
  inline void set_has_text();
  inline void clear_has_text();
  inline void set_has_cam_guid();
  inline void clear_has_cam_guid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int type_;
  ::google::protobuf::int32 screenidx_;
  ::google::protobuf::int32 camposidx_;
  ::google::protobuf::int32 key_;
  ::std::string* text_;
  ::std::string* cam_guid_;
  int keytype_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_protobuf_2ftvWall_2eproto();
  friend void protobuf_AssignDesc_protobuf_2ftvWall_2eproto();
  friend void protobuf_ShutdownFile_protobuf_2ftvWall_2eproto();

  void InitAsDefaultInstance();
  static Packet_Ctrl_KeyCmdCtrl* default_instance_;
};
// -------------------------------------------------------------------

class Packet_Ctrl_AlarmCtrl : public ::google::protobuf::Message {
 public:
  Packet_Ctrl_AlarmCtrl();
  virtual ~Packet_Ctrl_AlarmCtrl();

  Packet_Ctrl_AlarmCtrl(const Packet_Ctrl_AlarmCtrl& from);

  inline Packet_Ctrl_AlarmCtrl& operator=(const Packet_Ctrl_AlarmCtrl& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Packet_Ctrl_AlarmCtrl& default_instance();

  void Swap(Packet_Ctrl_AlarmCtrl* other);

  // implements Message ----------------------------------------------

  Packet_Ctrl_AlarmCtrl* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Packet_Ctrl_AlarmCtrl& from);
  void MergeFrom(const Packet_Ctrl_AlarmCtrl& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string alarmSource = 1;
  inline bool has_alarmsource() const;
  inline void clear_alarmsource();
  static const int kAlarmSourceFieldNumber = 1;
  inline const ::std::string& alarmsource() const;
  inline void set_alarmsource(const ::std::string& value);
  inline void set_alarmsource(const char* value);
  inline void set_alarmsource(const char* value, size_t size);
  inline ::std::string* mutable_alarmsource();
  inline ::std::string* release_alarmsource();
  inline void set_allocated_alarmsource(::std::string* alarmsource);

  // required bool alarmClear = 2;
  inline bool has_alarmclear() const;
  inline void clear_alarmclear();
  static const int kAlarmClearFieldNumber = 2;
  inline bool alarmclear() const;
  inline void set_alarmclear(bool value);

  // @@protoc_insertion_point(class_scope:TvWall.Packet.Ctrl.AlarmCtrl)
 private:
  inline void set_has_alarmsource();
  inline void clear_has_alarmsource();
  inline void set_has_alarmclear();
  inline void clear_has_alarmclear();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* alarmsource_;
  bool alarmclear_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_protobuf_2ftvWall_2eproto();
  friend void protobuf_AssignDesc_protobuf_2ftvWall_2eproto();
  friend void protobuf_ShutdownFile_protobuf_2ftvWall_2eproto();

  void InitAsDefaultInstance();
  static Packet_Ctrl_AlarmCtrl* default_instance_;
};
// -------------------------------------------------------------------

class Packet_Ctrl_SyncClockCtrl : public ::google::protobuf::Message {
 public:
  Packet_Ctrl_SyncClockCtrl();
  virtual ~Packet_Ctrl_SyncClockCtrl();

  Packet_Ctrl_SyncClockCtrl(const Packet_Ctrl_SyncClockCtrl& from);

  inline Packet_Ctrl_SyncClockCtrl& operator=(const Packet_Ctrl_SyncClockCtrl& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Packet_Ctrl_SyncClockCtrl& default_instance();

  void Swap(Packet_Ctrl_SyncClockCtrl* other);

  // implements Message ----------------------------------------------

  Packet_Ctrl_SyncClockCtrl* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Packet_Ctrl_SyncClockCtrl& from);
  void MergeFrom(const Packet_Ctrl_SyncClockCtrl& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Packet_Ctrl_SyncClockCtrl_SyncType SyncType;
  static const SyncType SyncClock = Packet_Ctrl_SyncClockCtrl_SyncType_SyncClock;
  static const SyncType SyncFirstCam = Packet_Ctrl_SyncClockCtrl_SyncType_SyncFirstCam;
  static inline bool SyncType_IsValid(int value) {
    return Packet_Ctrl_SyncClockCtrl_SyncType_IsValid(value);
  }
  static const SyncType SyncType_MIN =
    Packet_Ctrl_SyncClockCtrl_SyncType_SyncType_MIN;
  static const SyncType SyncType_MAX =
    Packet_Ctrl_SyncClockCtrl_SyncType_SyncType_MAX;
  static const int SyncType_ARRAYSIZE =
    Packet_Ctrl_SyncClockCtrl_SyncType_SyncType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  SyncType_descriptor() {
    return Packet_Ctrl_SyncClockCtrl_SyncType_descriptor();
  }
  static inline const ::std::string& SyncType_Name(SyncType value) {
    return Packet_Ctrl_SyncClockCtrl_SyncType_Name(value);
  }
  static inline bool SyncType_Parse(const ::std::string& name,
      SyncType* value) {
    return Packet_Ctrl_SyncClockCtrl_SyncType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional int32 clock = 1;
  inline bool has_clock() const;
  inline void clear_clock();
  static const int kClockFieldNumber = 1;
  inline ::google::protobuf::int32 clock() const;
  inline void set_clock(::google::protobuf::int32 value);

  // optional .TvWall.Packet.Ctrl.SyncClockCtrl.SyncType type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline ::TvWall::Packet_Ctrl_SyncClockCtrl_SyncType type() const;
  inline void set_type(::TvWall::Packet_Ctrl_SyncClockCtrl_SyncType value);

  // @@protoc_insertion_point(class_scope:TvWall.Packet.Ctrl.SyncClockCtrl)
 private:
  inline void set_has_clock();
  inline void clear_has_clock();
  inline void set_has_type();
  inline void clear_has_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 clock_;
  int type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_protobuf_2ftvWall_2eproto();
  friend void protobuf_AssignDesc_protobuf_2ftvWall_2eproto();
  friend void protobuf_ShutdownFile_protobuf_2ftvWall_2eproto();

  void InitAsDefaultInstance();
  static Packet_Ctrl_SyncClockCtrl* default_instance_;
};
// -------------------------------------------------------------------

class Packet_Ctrl_TextContextCtrl : public ::google::protobuf::Message {
 public:
  Packet_Ctrl_TextContextCtrl();
  virtual ~Packet_Ctrl_TextContextCtrl();

  Packet_Ctrl_TextContextCtrl(const Packet_Ctrl_TextContextCtrl& from);

  inline Packet_Ctrl_TextContextCtrl& operator=(const Packet_Ctrl_TextContextCtrl& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Packet_Ctrl_TextContextCtrl& default_instance();

  void Swap(Packet_Ctrl_TextContextCtrl* other);

  // implements Message ----------------------------------------------

  Packet_Ctrl_TextContextCtrl* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Packet_Ctrl_TextContextCtrl& from);
  void MergeFrom(const Packet_Ctrl_TextContextCtrl& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Packet_Ctrl_TextContextCtrl_TextContextType TextContextType;
  static const TextContextType TextChanged = Packet_Ctrl_TextContextCtrl_TextContextType_TextChanged;
  static inline bool TextContextType_IsValid(int value) {
    return Packet_Ctrl_TextContextCtrl_TextContextType_IsValid(value);
  }
  static const TextContextType TextContextType_MIN =
    Packet_Ctrl_TextContextCtrl_TextContextType_TextContextType_MIN;
  static const TextContextType TextContextType_MAX =
    Packet_Ctrl_TextContextCtrl_TextContextType_TextContextType_MAX;
  static const int TextContextType_ARRAYSIZE =
    Packet_Ctrl_TextContextCtrl_TextContextType_TextContextType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  TextContextType_descriptor() {
    return Packet_Ctrl_TextContextCtrl_TextContextType_descriptor();
  }
  static inline const ::std::string& TextContextType_Name(TextContextType value) {
    return Packet_Ctrl_TextContextCtrl_TextContextType_Name(value);
  }
  static inline bool TextContextType_Parse(const ::std::string& name,
      TextContextType* value) {
    return Packet_Ctrl_TextContextCtrl_TextContextType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .TvWall.Packet.Ctrl.TextContextCtrl.TextContextType type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::TvWall::Packet_Ctrl_TextContextCtrl_TextContextType type() const;
  inline void set_type(::TvWall::Packet_Ctrl_TextContextCtrl_TextContextType value);

  // required string oldText = 2;
  inline bool has_oldtext() const;
  inline void clear_oldtext();
  static const int kOldTextFieldNumber = 2;
  inline const ::std::string& oldtext() const;
  inline void set_oldtext(const ::std::string& value);
  inline void set_oldtext(const char* value);
  inline void set_oldtext(const char* value, size_t size);
  inline ::std::string* mutable_oldtext();
  inline ::std::string* release_oldtext();
  inline void set_allocated_oldtext(::std::string* oldtext);

  // required string newText = 3;
  inline bool has_newtext() const;
  inline void clear_newtext();
  static const int kNewTextFieldNumber = 3;
  inline const ::std::string& newtext() const;
  inline void set_newtext(const ::std::string& value);
  inline void set_newtext(const char* value);
  inline void set_newtext(const char* value, size_t size);
  inline ::std::string* mutable_newtext();
  inline ::std::string* release_newtext();
  inline void set_allocated_newtext(::std::string* newtext);

  // @@protoc_insertion_point(class_scope:TvWall.Packet.Ctrl.TextContextCtrl)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_oldtext();
  inline void clear_has_oldtext();
  inline void set_has_newtext();
  inline void clear_has_newtext();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* oldtext_;
  ::std::string* newtext_;
  int type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_protobuf_2ftvWall_2eproto();
  friend void protobuf_AssignDesc_protobuf_2ftvWall_2eproto();
  friend void protobuf_ShutdownFile_protobuf_2ftvWall_2eproto();

  void InitAsDefaultInstance();
  static Packet_Ctrl_TextContextCtrl* default_instance_;
};
// -------------------------------------------------------------------

class Packet_Ctrl_GroupLoopCtrl : public ::google::protobuf::Message {
 public:
  Packet_Ctrl_GroupLoopCtrl();
  virtual ~Packet_Ctrl_GroupLoopCtrl();

  Packet_Ctrl_GroupLoopCtrl(const Packet_Ctrl_GroupLoopCtrl& from);

  inline Packet_Ctrl_GroupLoopCtrl& operator=(const Packet_Ctrl_GroupLoopCtrl& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Packet_Ctrl_GroupLoopCtrl& default_instance();

  void Swap(Packet_Ctrl_GroupLoopCtrl* other);

  // implements Message ----------------------------------------------

  Packet_Ctrl_GroupLoopCtrl* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Packet_Ctrl_GroupLoopCtrl& from);
  void MergeFrom(const Packet_Ctrl_GroupLoopCtrl& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Packet_Ctrl_GroupLoopCtrl_GroupLoopCtrlType GroupLoopCtrlType;
  static const GroupLoopCtrlType ALL = Packet_Ctrl_GroupLoopCtrl_GroupLoopCtrlType_ALL;
  static const GroupLoopCtrlType FOCUS_AREA = Packet_Ctrl_GroupLoopCtrl_GroupLoopCtrlType_FOCUS_AREA;
  static const GroupLoopCtrlType RESET_VIEWS = Packet_Ctrl_GroupLoopCtrl_GroupLoopCtrlType_RESET_VIEWS;
  static const GroupLoopCtrlType LOOP_TIME = Packet_Ctrl_GroupLoopCtrl_GroupLoopCtrlType_LOOP_TIME;
  static const GroupLoopCtrlType ACTIVED = Packet_Ctrl_GroupLoopCtrl_GroupLoopCtrlType_ACTIVED;
  static inline bool GroupLoopCtrlType_IsValid(int value) {
    return Packet_Ctrl_GroupLoopCtrl_GroupLoopCtrlType_IsValid(value);
  }
  static const GroupLoopCtrlType GroupLoopCtrlType_MIN =
    Packet_Ctrl_GroupLoopCtrl_GroupLoopCtrlType_GroupLoopCtrlType_MIN;
  static const GroupLoopCtrlType GroupLoopCtrlType_MAX =
    Packet_Ctrl_GroupLoopCtrl_GroupLoopCtrlType_GroupLoopCtrlType_MAX;
  static const int GroupLoopCtrlType_ARRAYSIZE =
    Packet_Ctrl_GroupLoopCtrl_GroupLoopCtrlType_GroupLoopCtrlType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  GroupLoopCtrlType_descriptor() {
    return Packet_Ctrl_GroupLoopCtrl_GroupLoopCtrlType_descriptor();
  }
  static inline const ::std::string& GroupLoopCtrlType_Name(GroupLoopCtrlType value) {
    return Packet_Ctrl_GroupLoopCtrl_GroupLoopCtrlType_Name(value);
  }
  static inline bool GroupLoopCtrlType_Parse(const ::std::string& name,
      GroupLoopCtrlType* value) {
    return Packet_Ctrl_GroupLoopCtrl_GroupLoopCtrlType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .TvWall.Packet.Ctrl.GroupLoopCtrl.GroupLoopCtrlType type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::TvWall::Packet_Ctrl_GroupLoopCtrl_GroupLoopCtrlType type() const;
  inline void set_type(::TvWall::Packet_Ctrl_GroupLoopCtrl_GroupLoopCtrlType value);

  // required .TvWall.Packet.ElementDat.GroupLoop groupLoop = 2;
  inline bool has_grouploop() const;
  inline void clear_grouploop();
  static const int kGroupLoopFieldNumber = 2;
  inline const ::TvWall::Packet_ElementDat_GroupLoop& grouploop() const;
  inline ::TvWall::Packet_ElementDat_GroupLoop* mutable_grouploop();
  inline ::TvWall::Packet_ElementDat_GroupLoop* release_grouploop();
  inline void set_allocated_grouploop(::TvWall::Packet_ElementDat_GroupLoop* grouploop);

  // @@protoc_insertion_point(class_scope:TvWall.Packet.Ctrl.GroupLoopCtrl)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_grouploop();
  inline void clear_has_grouploop();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TvWall::Packet_ElementDat_GroupLoop* grouploop_;
  int type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_protobuf_2ftvWall_2eproto();
  friend void protobuf_AssignDesc_protobuf_2ftvWall_2eproto();
  friend void protobuf_ShutdownFile_protobuf_2ftvWall_2eproto();

  void InitAsDefaultInstance();
  static Packet_Ctrl_GroupLoopCtrl* default_instance_;
};
// -------------------------------------------------------------------

class Packet_Ctrl : public ::google::protobuf::Message {
 public:
  Packet_Ctrl();
  virtual ~Packet_Ctrl();

  Packet_Ctrl(const Packet_Ctrl& from);

  inline Packet_Ctrl& operator=(const Packet_Ctrl& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Packet_Ctrl& default_instance();

  void Swap(Packet_Ctrl* other);

  // implements Message ----------------------------------------------

  Packet_Ctrl* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Packet_Ctrl& from);
  void MergeFrom(const Packet_Ctrl& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Packet_Ctrl_ScreenSplitCtrl ScreenSplitCtrl;
  typedef Packet_Ctrl_ViewCtrl ViewCtrl;
  typedef Packet_Ctrl_CameraCtrl CameraCtrl;
  typedef Packet_Ctrl_HotPointCtrl HotPointCtrl;
  typedef Packet_Ctrl_LayoutCtrl LayoutCtrl;
  typedef Packet_Ctrl_LayoutLoopCtrl LayoutLoopCtrl;
  typedef Packet_Ctrl_CtrlMaster CtrlMaster;
  typedef Packet_Ctrl_MachineCtrl MachineCtrl;
  typedef Packet_Ctrl_KeyCtrl KeyCtrl;
  typedef Packet_Ctrl_KeyCmdCtrl KeyCmdCtrl;
  typedef Packet_Ctrl_AlarmCtrl AlarmCtrl;
  typedef Packet_Ctrl_SyncClockCtrl SyncClockCtrl;
  typedef Packet_Ctrl_TextContextCtrl TextContextCtrl;
  typedef Packet_Ctrl_GroupLoopCtrl GroupLoopCtrl;

  // accessors -------------------------------------------------------

  // optional .TvWall.Packet.Ctrl.ViewCtrl viewCtrl = 1;
  inline bool has_viewctrl() const;
  inline void clear_viewctrl();
  static const int kViewCtrlFieldNumber = 1;
  inline const ::TvWall::Packet_Ctrl_ViewCtrl& viewctrl() const;
  inline ::TvWall::Packet_Ctrl_ViewCtrl* mutable_viewctrl();
  inline ::TvWall::Packet_Ctrl_ViewCtrl* release_viewctrl();
  inline void set_allocated_viewctrl(::TvWall::Packet_Ctrl_ViewCtrl* viewctrl);

  // optional .TvWall.Packet.Ctrl.CameraCtrl cameraCtrl = 2;
  inline bool has_cameractrl() const;
  inline void clear_cameractrl();
  static const int kCameraCtrlFieldNumber = 2;
  inline const ::TvWall::Packet_Ctrl_CameraCtrl& cameractrl() const;
  inline ::TvWall::Packet_Ctrl_CameraCtrl* mutable_cameractrl();
  inline ::TvWall::Packet_Ctrl_CameraCtrl* release_cameractrl();
  inline void set_allocated_cameractrl(::TvWall::Packet_Ctrl_CameraCtrl* cameractrl);

  // optional .TvWall.Packet.Ctrl.HotPointCtrl hotPointCtrl = 3;
  inline bool has_hotpointctrl() const;
  inline void clear_hotpointctrl();
  static const int kHotPointCtrlFieldNumber = 3;
  inline const ::TvWall::Packet_Ctrl_HotPointCtrl& hotpointctrl() const;
  inline ::TvWall::Packet_Ctrl_HotPointCtrl* mutable_hotpointctrl();
  inline ::TvWall::Packet_Ctrl_HotPointCtrl* release_hotpointctrl();
  inline void set_allocated_hotpointctrl(::TvWall::Packet_Ctrl_HotPointCtrl* hotpointctrl);

  // optional .TvWall.Packet.Ctrl.LayoutCtrl lyoutCtrl = 4;
  inline bool has_lyoutctrl() const;
  inline void clear_lyoutctrl();
  static const int kLyoutCtrlFieldNumber = 4;
  inline const ::TvWall::Packet_Ctrl_LayoutCtrl& lyoutctrl() const;
  inline ::TvWall::Packet_Ctrl_LayoutCtrl* mutable_lyoutctrl();
  inline ::TvWall::Packet_Ctrl_LayoutCtrl* release_lyoutctrl();
  inline void set_allocated_lyoutctrl(::TvWall::Packet_Ctrl_LayoutCtrl* lyoutctrl);

  // optional .TvWall.Packet.Ctrl.CtrlMaster masterCtrl = 5;
  inline bool has_masterctrl() const;
  inline void clear_masterctrl();
  static const int kMasterCtrlFieldNumber = 5;
  inline const ::TvWall::Packet_Ctrl_CtrlMaster& masterctrl() const;
  inline ::TvWall::Packet_Ctrl_CtrlMaster* mutable_masterctrl();
  inline ::TvWall::Packet_Ctrl_CtrlMaster* release_masterctrl();
  inline void set_allocated_masterctrl(::TvWall::Packet_Ctrl_CtrlMaster* masterctrl);

  // optional .TvWall.Packet.Ctrl.ScreenSplitCtrl screenCtrl = 6;
  inline bool has_screenctrl() const;
  inline void clear_screenctrl();
  static const int kScreenCtrlFieldNumber = 6;
  inline const ::TvWall::Packet_Ctrl_ScreenSplitCtrl& screenctrl() const;
  inline ::TvWall::Packet_Ctrl_ScreenSplitCtrl* mutable_screenctrl();
  inline ::TvWall::Packet_Ctrl_ScreenSplitCtrl* release_screenctrl();
  inline void set_allocated_screenctrl(::TvWall::Packet_Ctrl_ScreenSplitCtrl* screenctrl);

  // optional .TvWall.Packet.Ctrl.LayoutLoopCtrl lyoutLoopCtrl = 7;
  inline bool has_lyoutloopctrl() const;
  inline void clear_lyoutloopctrl();
  static const int kLyoutLoopCtrlFieldNumber = 7;
  inline const ::TvWall::Packet_Ctrl_LayoutLoopCtrl& lyoutloopctrl() const;
  inline ::TvWall::Packet_Ctrl_LayoutLoopCtrl* mutable_lyoutloopctrl();
  inline ::TvWall::Packet_Ctrl_LayoutLoopCtrl* release_lyoutloopctrl();
  inline void set_allocated_lyoutloopctrl(::TvWall::Packet_Ctrl_LayoutLoopCtrl* lyoutloopctrl);

  // optional .TvWall.Packet.Ctrl.MachineCtrl machineCtrl = 8;
  inline bool has_machinectrl() const;
  inline void clear_machinectrl();
  static const int kMachineCtrlFieldNumber = 8;
  inline const ::TvWall::Packet_Ctrl_MachineCtrl& machinectrl() const;
  inline ::TvWall::Packet_Ctrl_MachineCtrl* mutable_machinectrl();
  inline ::TvWall::Packet_Ctrl_MachineCtrl* release_machinectrl();
  inline void set_allocated_machinectrl(::TvWall::Packet_Ctrl_MachineCtrl* machinectrl);

  // optional .TvWall.Packet.Ctrl.KeyCtrl keyCtrl = 9;
  inline bool has_keyctrl() const;
  inline void clear_keyctrl();
  static const int kKeyCtrlFieldNumber = 9;
  inline const ::TvWall::Packet_Ctrl_KeyCtrl& keyctrl() const;
  inline ::TvWall::Packet_Ctrl_KeyCtrl* mutable_keyctrl();
  inline ::TvWall::Packet_Ctrl_KeyCtrl* release_keyctrl();
  inline void set_allocated_keyctrl(::TvWall::Packet_Ctrl_KeyCtrl* keyctrl);

  // optional .TvWall.Packet.Ctrl.KeyCmdCtrl keyCmdCtrl = 10;
  inline bool has_keycmdctrl() const;
  inline void clear_keycmdctrl();
  static const int kKeyCmdCtrlFieldNumber = 10;
  inline const ::TvWall::Packet_Ctrl_KeyCmdCtrl& keycmdctrl() const;
  inline ::TvWall::Packet_Ctrl_KeyCmdCtrl* mutable_keycmdctrl();
  inline ::TvWall::Packet_Ctrl_KeyCmdCtrl* release_keycmdctrl();
  inline void set_allocated_keycmdctrl(::TvWall::Packet_Ctrl_KeyCmdCtrl* keycmdctrl);

  // optional .TvWall.Packet.Ctrl.AlarmCtrl alarmCtrl = 11;
  inline bool has_alarmctrl() const;
  inline void clear_alarmctrl();
  static const int kAlarmCtrlFieldNumber = 11;
  inline const ::TvWall::Packet_Ctrl_AlarmCtrl& alarmctrl() const;
  inline ::TvWall::Packet_Ctrl_AlarmCtrl* mutable_alarmctrl();
  inline ::TvWall::Packet_Ctrl_AlarmCtrl* release_alarmctrl();
  inline void set_allocated_alarmctrl(::TvWall::Packet_Ctrl_AlarmCtrl* alarmctrl);

  // optional .TvWall.Packet.Ctrl.SyncClockCtrl syncCtrl = 12;
  inline bool has_syncctrl() const;
  inline void clear_syncctrl();
  static const int kSyncCtrlFieldNumber = 12;
  inline const ::TvWall::Packet_Ctrl_SyncClockCtrl& syncctrl() const;
  inline ::TvWall::Packet_Ctrl_SyncClockCtrl* mutable_syncctrl();
  inline ::TvWall::Packet_Ctrl_SyncClockCtrl* release_syncctrl();
  inline void set_allocated_syncctrl(::TvWall::Packet_Ctrl_SyncClockCtrl* syncctrl);

  // optional .TvWall.Packet.Ctrl.TextContextCtrl txtContextCtrl = 13;
  inline bool has_txtcontextctrl() const;
  inline void clear_txtcontextctrl();
  static const int kTxtContextCtrlFieldNumber = 13;
  inline const ::TvWall::Packet_Ctrl_TextContextCtrl& txtcontextctrl() const;
  inline ::TvWall::Packet_Ctrl_TextContextCtrl* mutable_txtcontextctrl();
  inline ::TvWall::Packet_Ctrl_TextContextCtrl* release_txtcontextctrl();
  inline void set_allocated_txtcontextctrl(::TvWall::Packet_Ctrl_TextContextCtrl* txtcontextctrl);

  // optional .TvWall.Packet.Ctrl.GroupLoopCtrl groupLoopCtrl = 14;
  inline bool has_grouploopctrl() const;
  inline void clear_grouploopctrl();
  static const int kGroupLoopCtrlFieldNumber = 14;
  inline const ::TvWall::Packet_Ctrl_GroupLoopCtrl& grouploopctrl() const;
  inline ::TvWall::Packet_Ctrl_GroupLoopCtrl* mutable_grouploopctrl();
  inline ::TvWall::Packet_Ctrl_GroupLoopCtrl* release_grouploopctrl();
  inline void set_allocated_grouploopctrl(::TvWall::Packet_Ctrl_GroupLoopCtrl* grouploopctrl);

  // @@protoc_insertion_point(class_scope:TvWall.Packet.Ctrl)
 private:
  inline void set_has_viewctrl();
  inline void clear_has_viewctrl();
  inline void set_has_cameractrl();
  inline void clear_has_cameractrl();
  inline void set_has_hotpointctrl();
  inline void clear_has_hotpointctrl();
  inline void set_has_lyoutctrl();
  inline void clear_has_lyoutctrl();
  inline void set_has_masterctrl();
  inline void clear_has_masterctrl();
  inline void set_has_screenctrl();
  inline void clear_has_screenctrl();
  inline void set_has_lyoutloopctrl();
  inline void clear_has_lyoutloopctrl();
  inline void set_has_machinectrl();
  inline void clear_has_machinectrl();
  inline void set_has_keyctrl();
  inline void clear_has_keyctrl();
  inline void set_has_keycmdctrl();
  inline void clear_has_keycmdctrl();
  inline void set_has_alarmctrl();
  inline void clear_has_alarmctrl();
  inline void set_has_syncctrl();
  inline void clear_has_syncctrl();
  inline void set_has_txtcontextctrl();
  inline void clear_has_txtcontextctrl();
  inline void set_has_grouploopctrl();
  inline void clear_has_grouploopctrl();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TvWall::Packet_Ctrl_ViewCtrl* viewctrl_;
  ::TvWall::Packet_Ctrl_CameraCtrl* cameractrl_;
  ::TvWall::Packet_Ctrl_HotPointCtrl* hotpointctrl_;
  ::TvWall::Packet_Ctrl_LayoutCtrl* lyoutctrl_;
  ::TvWall::Packet_Ctrl_CtrlMaster* masterctrl_;
  ::TvWall::Packet_Ctrl_ScreenSplitCtrl* screenctrl_;
  ::TvWall::Packet_Ctrl_LayoutLoopCtrl* lyoutloopctrl_;
  ::TvWall::Packet_Ctrl_MachineCtrl* machinectrl_;
  ::TvWall::Packet_Ctrl_KeyCtrl* keyctrl_;
  ::TvWall::Packet_Ctrl_KeyCmdCtrl* keycmdctrl_;
  ::TvWall::Packet_Ctrl_AlarmCtrl* alarmctrl_;
  ::TvWall::Packet_Ctrl_SyncClockCtrl* syncctrl_;
  ::TvWall::Packet_Ctrl_TextContextCtrl* txtcontextctrl_;
  ::TvWall::Packet_Ctrl_GroupLoopCtrl* grouploopctrl_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(14 + 31) / 32];

  friend void  protobuf_AddDesc_protobuf_2ftvWall_2eproto();
  friend void protobuf_AssignDesc_protobuf_2ftvWall_2eproto();
  friend void protobuf_ShutdownFile_protobuf_2ftvWall_2eproto();

  void InitAsDefaultInstance();
  static Packet_Ctrl* default_instance_;
};
// -------------------------------------------------------------------

class Packet_RequireSession_ClientRequire : public ::google::protobuf::Message {
 public:
  Packet_RequireSession_ClientRequire();
  virtual ~Packet_RequireSession_ClientRequire();

  Packet_RequireSession_ClientRequire(const Packet_RequireSession_ClientRequire& from);

  inline Packet_RequireSession_ClientRequire& operator=(const Packet_RequireSession_ClientRequire& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Packet_RequireSession_ClientRequire& default_instance();

  void Swap(Packet_RequireSession_ClientRequire* other);

  // implements Message ----------------------------------------------

  Packet_RequireSession_ClientRequire* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Packet_RequireSession_ClientRequire& from);
  void MergeFrom(const Packet_RequireSession_ClientRequire& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TvWall.Packet.RequireSession.ClientRequireType type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::TvWall::Packet_RequireSession_ClientRequireType type() const;
  inline void set_type(::TvWall::Packet_RequireSession_ClientRequireType value);

  // @@protoc_insertion_point(class_scope:TvWall.Packet.RequireSession.ClientRequire)
 private:
  inline void set_has_type();
  inline void clear_has_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_protobuf_2ftvWall_2eproto();
  friend void protobuf_AssignDesc_protobuf_2ftvWall_2eproto();
  friend void protobuf_ShutdownFile_protobuf_2ftvWall_2eproto();

  void InitAsDefaultInstance();
  static Packet_RequireSession_ClientRequire* default_instance_;
};
// -------------------------------------------------------------------

class Packet_RequireSession_ClientRequireAck : public ::google::protobuf::Message {
 public:
  Packet_RequireSession_ClientRequireAck();
  virtual ~Packet_RequireSession_ClientRequireAck();

  Packet_RequireSession_ClientRequireAck(const Packet_RequireSession_ClientRequireAck& from);

  inline Packet_RequireSession_ClientRequireAck& operator=(const Packet_RequireSession_ClientRequireAck& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Packet_RequireSession_ClientRequireAck& default_instance();

  void Swap(Packet_RequireSession_ClientRequireAck* other);

  // implements Message ----------------------------------------------

  Packet_RequireSession_ClientRequireAck* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Packet_RequireSession_ClientRequireAck& from);
  void MergeFrom(const Packet_RequireSession_ClientRequireAck& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TvWall.Packet.RequireSession.ClientRequireType type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::TvWall::Packet_RequireSession_ClientRequireType type() const;
  inline void set_type(::TvWall::Packet_RequireSession_ClientRequireType value);

  // required .TvWall.Packet.ElementDat elementData = 2;
  inline bool has_elementdata() const;
  inline void clear_elementdata();
  static const int kElementDataFieldNumber = 2;
  inline const ::TvWall::Packet_ElementDat& elementdata() const;
  inline ::TvWall::Packet_ElementDat* mutable_elementdata();
  inline ::TvWall::Packet_ElementDat* release_elementdata();
  inline void set_allocated_elementdata(::TvWall::Packet_ElementDat* elementdata);

  // @@protoc_insertion_point(class_scope:TvWall.Packet.RequireSession.ClientRequireAck)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_elementdata();
  inline void clear_has_elementdata();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TvWall::Packet_ElementDat* elementdata_;
  int type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_protobuf_2ftvWall_2eproto();
  friend void protobuf_AssignDesc_protobuf_2ftvWall_2eproto();
  friend void protobuf_ShutdownFile_protobuf_2ftvWall_2eproto();

  void InitAsDefaultInstance();
  static Packet_RequireSession_ClientRequireAck* default_instance_;
};
// -------------------------------------------------------------------

class Packet_RequireSession_LocalMovieSession : public ::google::protobuf::Message {
 public:
  Packet_RequireSession_LocalMovieSession();
  virtual ~Packet_RequireSession_LocalMovieSession();

  Packet_RequireSession_LocalMovieSession(const Packet_RequireSession_LocalMovieSession& from);

  inline Packet_RequireSession_LocalMovieSession& operator=(const Packet_RequireSession_LocalMovieSession& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Packet_RequireSession_LocalMovieSession& default_instance();

  void Swap(Packet_RequireSession_LocalMovieSession* other);

  // implements Message ----------------------------------------------

  Packet_RequireSession_LocalMovieSession* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Packet_RequireSession_LocalMovieSession& from);
  void MergeFrom(const Packet_RequireSession_LocalMovieSession& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 winId = 1;
  inline bool has_winid() const;
  inline void clear_winid();
  static const int kWinIdFieldNumber = 1;
  inline ::google::protobuf::int32 winid() const;
  inline void set_winid(::google::protobuf::int32 value);

  // required bool needAlwaysAck = 2;
  inline bool has_needalwaysack() const;
  inline void clear_needalwaysack();
  static const int kNeedAlwaysAckFieldNumber = 2;
  inline bool needalwaysack() const;
  inline void set_needalwaysack(bool value);

  // @@protoc_insertion_point(class_scope:TvWall.Packet.RequireSession.LocalMovieSession)
 private:
  inline void set_has_winid();
  inline void clear_has_winid();
  inline void set_has_needalwaysack();
  inline void clear_has_needalwaysack();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 winid_;
  bool needalwaysack_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_protobuf_2ftvWall_2eproto();
  friend void protobuf_AssignDesc_protobuf_2ftvWall_2eproto();
  friend void protobuf_ShutdownFile_protobuf_2ftvWall_2eproto();

  void InitAsDefaultInstance();
  static Packet_RequireSession_LocalMovieSession* default_instance_;
};
// -------------------------------------------------------------------

class Packet_RequireSession_LocalMovieSessionAck : public ::google::protobuf::Message {
 public:
  Packet_RequireSession_LocalMovieSessionAck();
  virtual ~Packet_RequireSession_LocalMovieSessionAck();

  Packet_RequireSession_LocalMovieSessionAck(const Packet_RequireSession_LocalMovieSessionAck& from);

  inline Packet_RequireSession_LocalMovieSessionAck& operator=(const Packet_RequireSession_LocalMovieSessionAck& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Packet_RequireSession_LocalMovieSessionAck& default_instance();

  void Swap(Packet_RequireSession_LocalMovieSessionAck* other);

  // implements Message ----------------------------------------------

  Packet_RequireSession_LocalMovieSessionAck* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Packet_RequireSession_LocalMovieSessionAck& from);
  void MergeFrom(const Packet_RequireSession_LocalMovieSessionAck& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Packet_RequireSession_LocalMovieSessionAck_MovieStat MovieStat;
  static const MovieStat STOP = Packet_RequireSession_LocalMovieSessionAck_MovieStat_STOP;
  static const MovieStat PLAY = Packet_RequireSession_LocalMovieSessionAck_MovieStat_PLAY;
  static const MovieStat PAUSE = Packet_RequireSession_LocalMovieSessionAck_MovieStat_PAUSE;
  static inline bool MovieStat_IsValid(int value) {
    return Packet_RequireSession_LocalMovieSessionAck_MovieStat_IsValid(value);
  }
  static const MovieStat MovieStat_MIN =
    Packet_RequireSession_LocalMovieSessionAck_MovieStat_MovieStat_MIN;
  static const MovieStat MovieStat_MAX =
    Packet_RequireSession_LocalMovieSessionAck_MovieStat_MovieStat_MAX;
  static const int MovieStat_ARRAYSIZE =
    Packet_RequireSession_LocalMovieSessionAck_MovieStat_MovieStat_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  MovieStat_descriptor() {
    return Packet_RequireSession_LocalMovieSessionAck_MovieStat_descriptor();
  }
  static inline const ::std::string& MovieStat_Name(MovieStat value) {
    return Packet_RequireSession_LocalMovieSessionAck_MovieStat_Name(value);
  }
  static inline bool MovieStat_Parse(const ::std::string& name,
      MovieStat* value) {
    return Packet_RequireSession_LocalMovieSessionAck_MovieStat_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required int32 winId = 1;
  inline bool has_winid() const;
  inline void clear_winid();
  static const int kWinIdFieldNumber = 1;
  inline ::google::protobuf::int32 winid() const;
  inline void set_winid(::google::protobuf::int32 value);

  // optional string url = 2;
  inline bool has_url() const;
  inline void clear_url();
  static const int kUrlFieldNumber = 2;
  inline const ::std::string& url() const;
  inline void set_url(const ::std::string& value);
  inline void set_url(const char* value);
  inline void set_url(const char* value, size_t size);
  inline ::std::string* mutable_url();
  inline ::std::string* release_url();
  inline void set_allocated_url(::std::string* url);

  // optional int32 volume = 3;
  inline bool has_volume() const;
  inline void clear_volume();
  static const int kVolumeFieldNumber = 3;
  inline ::google::protobuf::int32 volume() const;
  inline void set_volume(::google::protobuf::int32 value);

  // optional int64 timeStamp = 4;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimeStampFieldNumber = 4;
  inline ::google::protobuf::int64 timestamp() const;
  inline void set_timestamp(::google::protobuf::int64 value);

  // required .TvWall.Packet.RequireSession.LocalMovieSessionAck.MovieStat movieStat = 5;
  inline bool has_moviestat() const;
  inline void clear_moviestat();
  static const int kMovieStatFieldNumber = 5;
  inline ::TvWall::Packet_RequireSession_LocalMovieSessionAck_MovieStat moviestat() const;
  inline void set_moviestat(::TvWall::Packet_RequireSession_LocalMovieSessionAck_MovieStat value);

  // @@protoc_insertion_point(class_scope:TvWall.Packet.RequireSession.LocalMovieSessionAck)
 private:
  inline void set_has_winid();
  inline void clear_has_winid();
  inline void set_has_url();
  inline void clear_has_url();
  inline void set_has_volume();
  inline void clear_has_volume();
  inline void set_has_timestamp();
  inline void clear_has_timestamp();
  inline void set_has_moviestat();
  inline void clear_has_moviestat();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* url_;
  ::google::protobuf::int32 winid_;
  ::google::protobuf::int32 volume_;
  ::google::protobuf::int64 timestamp_;
  int moviestat_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_protobuf_2ftvWall_2eproto();
  friend void protobuf_AssignDesc_protobuf_2ftvWall_2eproto();
  friend void protobuf_ShutdownFile_protobuf_2ftvWall_2eproto();

  void InitAsDefaultInstance();
  static Packet_RequireSession_LocalMovieSessionAck* default_instance_;
};
// -------------------------------------------------------------------

class Packet_RequireSession_RecordRequire : public ::google::protobuf::Message {
 public:
  Packet_RequireSession_RecordRequire();
  virtual ~Packet_RequireSession_RecordRequire();

  Packet_RequireSession_RecordRequire(const Packet_RequireSession_RecordRequire& from);

  inline Packet_RequireSession_RecordRequire& operator=(const Packet_RequireSession_RecordRequire& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Packet_RequireSession_RecordRequire& default_instance();

  void Swap(Packet_RequireSession_RecordRequire* other);

  // implements Message ----------------------------------------------

  Packet_RequireSession_RecordRequire* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Packet_RequireSession_RecordRequire& from);
  void MergeFrom(const Packet_RequireSession_RecordRequire& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Packet_RequireSession_RecordRequire_RecordRequireType RecordRequireType;
  static const RecordRequireType CURRENT_TIME = Packet_RequireSession_RecordRequire_RecordRequireType_CURRENT_TIME;
  static inline bool RecordRequireType_IsValid(int value) {
    return Packet_RequireSession_RecordRequire_RecordRequireType_IsValid(value);
  }
  static const RecordRequireType RecordRequireType_MIN =
    Packet_RequireSession_RecordRequire_RecordRequireType_RecordRequireType_MIN;
  static const RecordRequireType RecordRequireType_MAX =
    Packet_RequireSession_RecordRequire_RecordRequireType_RecordRequireType_MAX;
  static const int RecordRequireType_ARRAYSIZE =
    Packet_RequireSession_RecordRequire_RecordRequireType_RecordRequireType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  RecordRequireType_descriptor() {
    return Packet_RequireSession_RecordRequire_RecordRequireType_descriptor();
  }
  static inline const ::std::string& RecordRequireType_Name(RecordRequireType value) {
    return Packet_RequireSession_RecordRequire_RecordRequireType_Name(value);
  }
  static inline bool RecordRequireType_Parse(const ::std::string& name,
      RecordRequireType* value) {
    return Packet_RequireSession_RecordRequire_RecordRequireType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .TvWall.Packet.RequireSession.RecordRequire.RecordRequireType type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::TvWall::Packet_RequireSession_RecordRequire_RecordRequireType type() const;
  inline void set_type(::TvWall::Packet_RequireSession_RecordRequire_RecordRequireType value);

  // required int32 winId = 2;
  inline bool has_winid() const;
  inline void clear_winid();
  static const int kWinIdFieldNumber = 2;
  inline ::google::protobuf::int32 winid() const;
  inline void set_winid(::google::protobuf::int32 value);

  // required .TvWall.Guid CameraId = 3;
  inline bool has_cameraid() const;
  inline void clear_cameraid();
  static const int kCameraIdFieldNumber = 3;
  inline const ::TvWall::Guid& cameraid() const;
  inline ::TvWall::Guid* mutable_cameraid();
  inline ::TvWall::Guid* release_cameraid();
  inline void set_allocated_cameraid(::TvWall::Guid* cameraid);

  // @@protoc_insertion_point(class_scope:TvWall.Packet.RequireSession.RecordRequire)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_winid();
  inline void clear_has_winid();
  inline void set_has_cameraid();
  inline void clear_has_cameraid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int type_;
  ::google::protobuf::int32 winid_;
  ::TvWall::Guid* cameraid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_protobuf_2ftvWall_2eproto();
  friend void protobuf_AssignDesc_protobuf_2ftvWall_2eproto();
  friend void protobuf_ShutdownFile_protobuf_2ftvWall_2eproto();

  void InitAsDefaultInstance();
  static Packet_RequireSession_RecordRequire* default_instance_;
};
// -------------------------------------------------------------------

class Packet_RequireSession_RecordRequireAck : public ::google::protobuf::Message {
 public:
  Packet_RequireSession_RecordRequireAck();
  virtual ~Packet_RequireSession_RecordRequireAck();

  Packet_RequireSession_RecordRequireAck(const Packet_RequireSession_RecordRequireAck& from);

  inline Packet_RequireSession_RecordRequireAck& operator=(const Packet_RequireSession_RecordRequireAck& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Packet_RequireSession_RecordRequireAck& default_instance();

  void Swap(Packet_RequireSession_RecordRequireAck* other);

  // implements Message ----------------------------------------------

  Packet_RequireSession_RecordRequireAck* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Packet_RequireSession_RecordRequireAck& from);
  void MergeFrom(const Packet_RequireSession_RecordRequireAck& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 winId = 1;
  inline bool has_winid() const;
  inline void clear_winid();
  static const int kWinIdFieldNumber = 1;
  inline ::google::protobuf::int32 winid() const;
  inline void set_winid(::google::protobuf::int32 value);

  // required .TvWall.Guid CameraId = 2;
  inline bool has_cameraid() const;
  inline void clear_cameraid();
  static const int kCameraIdFieldNumber = 2;
  inline const ::TvWall::Guid& cameraid() const;
  inline ::TvWall::Guid* mutable_cameraid();
  inline ::TvWall::Guid* release_cameraid();
  inline void set_allocated_cameraid(::TvWall::Guid* cameraid);

  // optional uint64 currentTime = 3;
  inline bool has_currenttime() const;
  inline void clear_currenttime();
  static const int kCurrentTimeFieldNumber = 3;
  inline ::google::protobuf::uint64 currenttime() const;
  inline void set_currenttime(::google::protobuf::uint64 value);

  // optional int32 vary = 4;
  inline bool has_vary() const;
  inline void clear_vary();
  static const int kVaryFieldNumber = 4;
  inline ::google::protobuf::int32 vary() const;
  inline void set_vary(::google::protobuf::int32 value);

  // optional bool isPause = 5;
  inline bool has_ispause() const;
  inline void clear_ispause();
  static const int kIsPauseFieldNumber = 5;
  inline bool ispause() const;
  inline void set_ispause(bool value);

  // @@protoc_insertion_point(class_scope:TvWall.Packet.RequireSession.RecordRequireAck)
 private:
  inline void set_has_winid();
  inline void clear_has_winid();
  inline void set_has_cameraid();
  inline void clear_has_cameraid();
  inline void set_has_currenttime();
  inline void clear_has_currenttime();
  inline void set_has_vary();
  inline void clear_has_vary();
  inline void set_has_ispause();
  inline void clear_has_ispause();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TvWall::Guid* cameraid_;
  ::google::protobuf::int32 winid_;
  ::google::protobuf::int32 vary_;
  ::google::protobuf::uint64 currenttime_;
  bool ispause_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_protobuf_2ftvWall_2eproto();
  friend void protobuf_AssignDesc_protobuf_2ftvWall_2eproto();
  friend void protobuf_ShutdownFile_protobuf_2ftvWall_2eproto();

  void InitAsDefaultInstance();
  static Packet_RequireSession_RecordRequireAck* default_instance_;
};
// -------------------------------------------------------------------

class Packet_RequireSession_NetRequire : public ::google::protobuf::Message {
 public:
  Packet_RequireSession_NetRequire();
  virtual ~Packet_RequireSession_NetRequire();

  Packet_RequireSession_NetRequire(const Packet_RequireSession_NetRequire& from);

  inline Packet_RequireSession_NetRequire& operator=(const Packet_RequireSession_NetRequire& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Packet_RequireSession_NetRequire& default_instance();

  void Swap(Packet_RequireSession_NetRequire* other);

  // implements Message ----------------------------------------------

  Packet_RequireSession_NetRequire* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Packet_RequireSession_NetRequire& from);
  void MergeFrom(const Packet_RequireSession_NetRequire& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:TvWall.Packet.RequireSession.NetRequire)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_protobuf_2ftvWall_2eproto();
  friend void protobuf_AssignDesc_protobuf_2ftvWall_2eproto();
  friend void protobuf_ShutdownFile_protobuf_2ftvWall_2eproto();

  void InitAsDefaultInstance();
  static Packet_RequireSession_NetRequire* default_instance_;
};
// -------------------------------------------------------------------

class Packet_RequireSession_NetRequireAck : public ::google::protobuf::Message {
 public:
  Packet_RequireSession_NetRequireAck();
  virtual ~Packet_RequireSession_NetRequireAck();

  Packet_RequireSession_NetRequireAck(const Packet_RequireSession_NetRequireAck& from);

  inline Packet_RequireSession_NetRequireAck& operator=(const Packet_RequireSession_NetRequireAck& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Packet_RequireSession_NetRequireAck& default_instance();

  void Swap(Packet_RequireSession_NetRequireAck* other);

  // implements Message ----------------------------------------------

  Packet_RequireSession_NetRequireAck* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Packet_RequireSession_NetRequireAck& from);
  void MergeFrom(const Packet_RequireSession_NetRequireAck& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .TvWall.Network net = 1;
  inline bool has_net() const;
  inline void clear_net();
  static const int kNetFieldNumber = 1;
  inline const ::TvWall::Network& net() const;
  inline ::TvWall::Network* mutable_net();
  inline ::TvWall::Network* release_net();
  inline void set_allocated_net(::TvWall::Network* net);

  // @@protoc_insertion_point(class_scope:TvWall.Packet.RequireSession.NetRequireAck)
 private:
  inline void set_has_net();
  inline void clear_has_net();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TvWall::Network* net_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_protobuf_2ftvWall_2eproto();
  friend void protobuf_AssignDesc_protobuf_2ftvWall_2eproto();
  friend void protobuf_ShutdownFile_protobuf_2ftvWall_2eproto();

  void InitAsDefaultInstance();
  static Packet_RequireSession_NetRequireAck* default_instance_;
};
// -------------------------------------------------------------------

class Packet_RequireSession : public ::google::protobuf::Message {
 public:
  Packet_RequireSession();
  virtual ~Packet_RequireSession();

  Packet_RequireSession(const Packet_RequireSession& from);

  inline Packet_RequireSession& operator=(const Packet_RequireSession& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Packet_RequireSession& default_instance();

  void Swap(Packet_RequireSession* other);

  // implements Message ----------------------------------------------

  Packet_RequireSession* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Packet_RequireSession& from);
  void MergeFrom(const Packet_RequireSession& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Packet_RequireSession_ClientRequire ClientRequire;
  typedef Packet_RequireSession_ClientRequireAck ClientRequireAck;
  typedef Packet_RequireSession_LocalMovieSession LocalMovieSession;
  typedef Packet_RequireSession_LocalMovieSessionAck LocalMovieSessionAck;
  typedef Packet_RequireSession_RecordRequire RecordRequire;
  typedef Packet_RequireSession_RecordRequireAck RecordRequireAck;
  typedef Packet_RequireSession_NetRequire NetRequire;
  typedef Packet_RequireSession_NetRequireAck NetRequireAck;

  typedef Packet_RequireSession_ClientRequireType ClientRequireType;
  static const ClientRequireType SCREEN = Packet_RequireSession_ClientRequireType_SCREEN;
  static const ClientRequireType VIEW = Packet_RequireSession_ClientRequireType_VIEW;
  static const ClientRequireType CAMERA = Packet_RequireSession_ClientRequireType_CAMERA;
  static const ClientRequireType HOT_POINT = Packet_RequireSession_ClientRequireType_HOT_POINT;
  static const ClientRequireType FOCUS_POINT = Packet_RequireSession_ClientRequireType_FOCUS_POINT;
  static const ClientRequireType LOCAL_MOVIE = Packet_RequireSession_ClientRequireType_LOCAL_MOVIE;
  static const ClientRequireType FLASH = Packet_RequireSession_ClientRequireType_FLASH;
  static const ClientRequireType LAYOUT = Packet_RequireSession_ClientRequireType_LAYOUT;
  static const ClientRequireType RECORDINFO = Packet_RequireSession_ClientRequireType_RECORDINFO;
  static const ClientRequireType MAPINFO = Packet_RequireSession_ClientRequireType_MAPINFO;
  static const ClientRequireType LAYOUTLOOP = Packet_RequireSession_ClientRequireType_LAYOUTLOOP;
  static const ClientRequireType NVR_LIST = Packet_RequireSession_ClientRequireType_NVR_LIST;
  static const ClientRequireType FMP = Packet_RequireSession_ClientRequireType_FMP;
  static const ClientRequireType ALL = Packet_RequireSession_ClientRequireType_ALL;
  static inline bool ClientRequireType_IsValid(int value) {
    return Packet_RequireSession_ClientRequireType_IsValid(value);
  }
  static const ClientRequireType ClientRequireType_MIN =
    Packet_RequireSession_ClientRequireType_ClientRequireType_MIN;
  static const ClientRequireType ClientRequireType_MAX =
    Packet_RequireSession_ClientRequireType_ClientRequireType_MAX;
  static const int ClientRequireType_ARRAYSIZE =
    Packet_RequireSession_ClientRequireType_ClientRequireType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ClientRequireType_descriptor() {
    return Packet_RequireSession_ClientRequireType_descriptor();
  }
  static inline const ::std::string& ClientRequireType_Name(ClientRequireType value) {
    return Packet_RequireSession_ClientRequireType_Name(value);
  }
  static inline bool ClientRequireType_Parse(const ::std::string& name,
      ClientRequireType* value) {
    return Packet_RequireSession_ClientRequireType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .TvWall.Packet.RequireSession.ClientRequire clientRequire = 1;
  inline bool has_clientrequire() const;
  inline void clear_clientrequire();
  static const int kClientRequireFieldNumber = 1;
  inline const ::TvWall::Packet_RequireSession_ClientRequire& clientrequire() const;
  inline ::TvWall::Packet_RequireSession_ClientRequire* mutable_clientrequire();
  inline ::TvWall::Packet_RequireSession_ClientRequire* release_clientrequire();
  inline void set_allocated_clientrequire(::TvWall::Packet_RequireSession_ClientRequire* clientrequire);

  // optional .TvWall.Packet.RequireSession.ClientRequireAck clientRequireAck = 2;
  inline bool has_clientrequireack() const;
  inline void clear_clientrequireack();
  static const int kClientRequireAckFieldNumber = 2;
  inline const ::TvWall::Packet_RequireSession_ClientRequireAck& clientrequireack() const;
  inline ::TvWall::Packet_RequireSession_ClientRequireAck* mutable_clientrequireack();
  inline ::TvWall::Packet_RequireSession_ClientRequireAck* release_clientrequireack();
  inline void set_allocated_clientrequireack(::TvWall::Packet_RequireSession_ClientRequireAck* clientrequireack);

  // optional .TvWall.Packet.RequireSession.LocalMovieSession lms = 3;
  inline bool has_lms() const;
  inline void clear_lms();
  static const int kLmsFieldNumber = 3;
  inline const ::TvWall::Packet_RequireSession_LocalMovieSession& lms() const;
  inline ::TvWall::Packet_RequireSession_LocalMovieSession* mutable_lms();
  inline ::TvWall::Packet_RequireSession_LocalMovieSession* release_lms();
  inline void set_allocated_lms(::TvWall::Packet_RequireSession_LocalMovieSession* lms);

  // optional .TvWall.Packet.RequireSession.LocalMovieSessionAck lmsAck = 4;
  inline bool has_lmsack() const;
  inline void clear_lmsack();
  static const int kLmsAckFieldNumber = 4;
  inline const ::TvWall::Packet_RequireSession_LocalMovieSessionAck& lmsack() const;
  inline ::TvWall::Packet_RequireSession_LocalMovieSessionAck* mutable_lmsack();
  inline ::TvWall::Packet_RequireSession_LocalMovieSessionAck* release_lmsack();
  inline void set_allocated_lmsack(::TvWall::Packet_RequireSession_LocalMovieSessionAck* lmsack);

  // optional .TvWall.Packet.RequireSession.RecordRequire recordRequire = 5;
  inline bool has_recordrequire() const;
  inline void clear_recordrequire();
  static const int kRecordRequireFieldNumber = 5;
  inline const ::TvWall::Packet_RequireSession_RecordRequire& recordrequire() const;
  inline ::TvWall::Packet_RequireSession_RecordRequire* mutable_recordrequire();
  inline ::TvWall::Packet_RequireSession_RecordRequire* release_recordrequire();
  inline void set_allocated_recordrequire(::TvWall::Packet_RequireSession_RecordRequire* recordrequire);

  // optional .TvWall.Packet.RequireSession.RecordRequireAck recordRequireAck = 6;
  inline bool has_recordrequireack() const;
  inline void clear_recordrequireack();
  static const int kRecordRequireAckFieldNumber = 6;
  inline const ::TvWall::Packet_RequireSession_RecordRequireAck& recordrequireack() const;
  inline ::TvWall::Packet_RequireSession_RecordRequireAck* mutable_recordrequireack();
  inline ::TvWall::Packet_RequireSession_RecordRequireAck* release_recordrequireack();
  inline void set_allocated_recordrequireack(::TvWall::Packet_RequireSession_RecordRequireAck* recordrequireack);

  // optional .TvWall.Packet.RequireSession.NetRequire netRequire = 7;
  inline bool has_netrequire() const;
  inline void clear_netrequire();
  static const int kNetRequireFieldNumber = 7;
  inline const ::TvWall::Packet_RequireSession_NetRequire& netrequire() const;
  inline ::TvWall::Packet_RequireSession_NetRequire* mutable_netrequire();
  inline ::TvWall::Packet_RequireSession_NetRequire* release_netrequire();
  inline void set_allocated_netrequire(::TvWall::Packet_RequireSession_NetRequire* netrequire);

  // optional .TvWall.Packet.RequireSession.NetRequireAck netRequireAck = 8;
  inline bool has_netrequireack() const;
  inline void clear_netrequireack();
  static const int kNetRequireAckFieldNumber = 8;
  inline const ::TvWall::Packet_RequireSession_NetRequireAck& netrequireack() const;
  inline ::TvWall::Packet_RequireSession_NetRequireAck* mutable_netrequireack();
  inline ::TvWall::Packet_RequireSession_NetRequireAck* release_netrequireack();
  inline void set_allocated_netrequireack(::TvWall::Packet_RequireSession_NetRequireAck* netrequireack);

  // @@protoc_insertion_point(class_scope:TvWall.Packet.RequireSession)
 private:
  inline void set_has_clientrequire();
  inline void clear_has_clientrequire();
  inline void set_has_clientrequireack();
  inline void clear_has_clientrequireack();
  inline void set_has_lms();
  inline void clear_has_lms();
  inline void set_has_lmsack();
  inline void clear_has_lmsack();
  inline void set_has_recordrequire();
  inline void clear_has_recordrequire();
  inline void set_has_recordrequireack();
  inline void clear_has_recordrequireack();
  inline void set_has_netrequire();
  inline void clear_has_netrequire();
  inline void set_has_netrequireack();
  inline void clear_has_netrequireack();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TvWall::Packet_RequireSession_ClientRequire* clientrequire_;
  ::TvWall::Packet_RequireSession_ClientRequireAck* clientrequireack_;
  ::TvWall::Packet_RequireSession_LocalMovieSession* lms_;
  ::TvWall::Packet_RequireSession_LocalMovieSessionAck* lmsack_;
  ::TvWall::Packet_RequireSession_RecordRequire* recordrequire_;
  ::TvWall::Packet_RequireSession_RecordRequireAck* recordrequireack_;
  ::TvWall::Packet_RequireSession_NetRequire* netrequire_;
  ::TvWall::Packet_RequireSession_NetRequireAck* netrequireack_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  friend void  protobuf_AddDesc_protobuf_2ftvWall_2eproto();
  friend void protobuf_AssignDesc_protobuf_2ftvWall_2eproto();
  friend void protobuf_ShutdownFile_protobuf_2ftvWall_2eproto();

  void InitAsDefaultInstance();
  static Packet_RequireSession* default_instance_;
};
// -------------------------------------------------------------------

class Packet_Notice_Stat_ScreenSpliStat : public ::google::protobuf::Message {
 public:
  Packet_Notice_Stat_ScreenSpliStat();
  virtual ~Packet_Notice_Stat_ScreenSpliStat();

  Packet_Notice_Stat_ScreenSpliStat(const Packet_Notice_Stat_ScreenSpliStat& from);

  inline Packet_Notice_Stat_ScreenSpliStat& operator=(const Packet_Notice_Stat_ScreenSpliStat& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Packet_Notice_Stat_ScreenSpliStat& default_instance();

  void Swap(Packet_Notice_Stat_ScreenSpliStat* other);

  // implements Message ----------------------------------------------

  Packet_Notice_Stat_ScreenSpliStat* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Packet_Notice_Stat_ScreenSpliStat& from);
  void MergeFrom(const Packet_Notice_Stat_ScreenSpliStat& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 screenIndex = 2;
  inline bool has_screenindex() const;
  inline void clear_screenindex();
  static const int kScreenIndexFieldNumber = 2;
  inline ::google::protobuf::int32 screenindex() const;
  inline void set_screenindex(::google::protobuf::int32 value);

  // required int32 row = 3;
  inline bool has_row() const;
  inline void clear_row();
  static const int kRowFieldNumber = 3;
  inline ::google::protobuf::int32 row() const;
  inline void set_row(::google::protobuf::int32 value);

  // required int32 col = 4;
  inline bool has_col() const;
  inline void clear_col();
  static const int kColFieldNumber = 4;
  inline ::google::protobuf::int32 col() const;
  inline void set_col(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:TvWall.Packet.Notice.Stat.ScreenSpliStat)
 private:
  inline void set_has_screenindex();
  inline void clear_has_screenindex();
  inline void set_has_row();
  inline void clear_has_row();
  inline void set_has_col();
  inline void clear_has_col();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 screenindex_;
  ::google::protobuf::int32 row_;
  ::google::protobuf::int32 col_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_protobuf_2ftvWall_2eproto();
  friend void protobuf_AssignDesc_protobuf_2ftvWall_2eproto();
  friend void protobuf_ShutdownFile_protobuf_2ftvWall_2eproto();

  void InitAsDefaultInstance();
  static Packet_Notice_Stat_ScreenSpliStat* default_instance_;
};
// -------------------------------------------------------------------

class Packet_Notice_Stat_ViewStat_ViewGeomotryStat : public ::google::protobuf::Message {
 public:
  Packet_Notice_Stat_ViewStat_ViewGeomotryStat();
  virtual ~Packet_Notice_Stat_ViewStat_ViewGeomotryStat();

  Packet_Notice_Stat_ViewStat_ViewGeomotryStat(const Packet_Notice_Stat_ViewStat_ViewGeomotryStat& from);

  inline Packet_Notice_Stat_ViewStat_ViewGeomotryStat& operator=(const Packet_Notice_Stat_ViewStat_ViewGeomotryStat& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Packet_Notice_Stat_ViewStat_ViewGeomotryStat& default_instance();

  void Swap(Packet_Notice_Stat_ViewStat_ViewGeomotryStat* other);

  // implements Message ----------------------------------------------

  Packet_Notice_Stat_ViewStat_ViewGeomotryStat* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Packet_Notice_Stat_ViewStat_ViewGeomotryStat& from);
  void MergeFrom(const Packet_Notice_Stat_ViewStat_ViewGeomotryStat& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Packet_Notice_Stat_ViewStat_ViewGeomotryStat_ViewGeomotryStatType ViewGeomotryStatType;
  static const ViewGeomotryStatType CREATE = Packet_Notice_Stat_ViewStat_ViewGeomotryStat_ViewGeomotryStatType_CREATE;
  static const ViewGeomotryStatType WINDOW_CTRL = Packet_Notice_Stat_ViewStat_ViewGeomotryStat_ViewGeomotryStatType_WINDOW_CTRL;
  static const ViewGeomotryStatType REMOVE = Packet_Notice_Stat_ViewStat_ViewGeomotryStat_ViewGeomotryStatType_REMOVE;
  static const ViewGeomotryStatType SET_BORDER_WIDTH = Packet_Notice_Stat_ViewStat_ViewGeomotryStat_ViewGeomotryStatType_SET_BORDER_WIDTH;
  static const ViewGeomotryStatType SHOW_TITLE = Packet_Notice_Stat_ViewStat_ViewGeomotryStat_ViewGeomotryStatType_SHOW_TITLE;
  static inline bool ViewGeomotryStatType_IsValid(int value) {
    return Packet_Notice_Stat_ViewStat_ViewGeomotryStat_ViewGeomotryStatType_IsValid(value);
  }
  static const ViewGeomotryStatType ViewGeomotryStatType_MIN =
    Packet_Notice_Stat_ViewStat_ViewGeomotryStat_ViewGeomotryStatType_ViewGeomotryStatType_MIN;
  static const ViewGeomotryStatType ViewGeomotryStatType_MAX =
    Packet_Notice_Stat_ViewStat_ViewGeomotryStat_ViewGeomotryStatType_ViewGeomotryStatType_MAX;
  static const int ViewGeomotryStatType_ARRAYSIZE =
    Packet_Notice_Stat_ViewStat_ViewGeomotryStat_ViewGeomotryStatType_ViewGeomotryStatType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ViewGeomotryStatType_descriptor() {
    return Packet_Notice_Stat_ViewStat_ViewGeomotryStat_ViewGeomotryStatType_descriptor();
  }
  static inline const ::std::string& ViewGeomotryStatType_Name(ViewGeomotryStatType value) {
    return Packet_Notice_Stat_ViewStat_ViewGeomotryStat_ViewGeomotryStatType_Name(value);
  }
  static inline bool ViewGeomotryStatType_Parse(const ::std::string& name,
      ViewGeomotryStatType* value) {
    return Packet_Notice_Stat_ViewStat_ViewGeomotryStat_ViewGeomotryStatType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .TvWall.Packet.Notice.Stat.ViewStat.ViewGeomotryStat.ViewGeomotryStatType type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::TvWall::Packet_Notice_Stat_ViewStat_ViewGeomotryStat_ViewGeomotryStatType type() const;
  inline void set_type(::TvWall::Packet_Notice_Stat_ViewStat_ViewGeomotryStat_ViewGeomotryStatType value);

  // required .TvWall.Packet.ElementDat.View view = 2;
  inline bool has_view() const;
  inline void clear_view();
  static const int kViewFieldNumber = 2;
  inline const ::TvWall::Packet_ElementDat_View& view() const;
  inline ::TvWall::Packet_ElementDat_View* mutable_view();
  inline ::TvWall::Packet_ElementDat_View* release_view();
  inline void set_allocated_view(::TvWall::Packet_ElementDat_View* view);

  // optional string url = 3;
  inline bool has_url() const;
  inline void clear_url();
  static const int kUrlFieldNumber = 3;
  inline const ::std::string& url() const;
  inline void set_url(const ::std::string& value);
  inline void set_url(const char* value);
  inline void set_url(const char* value, size_t size);
  inline ::std::string* mutable_url();
  inline ::std::string* release_url();
  inline void set_allocated_url(::std::string* url);

  // @@protoc_insertion_point(class_scope:TvWall.Packet.Notice.Stat.ViewStat.ViewGeomotryStat)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_view();
  inline void clear_has_view();
  inline void set_has_url();
  inline void clear_has_url();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TvWall::Packet_ElementDat_View* view_;
  ::std::string* url_;
  int type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_protobuf_2ftvWall_2eproto();
  friend void protobuf_AssignDesc_protobuf_2ftvWall_2eproto();
  friend void protobuf_ShutdownFile_protobuf_2ftvWall_2eproto();

  void InitAsDefaultInstance();
  static Packet_Notice_Stat_ViewStat_ViewGeomotryStat* default_instance_;
};
// -------------------------------------------------------------------

class Packet_Notice_Stat_ViewStat_VideoStat : public ::google::protobuf::Message {
 public:
  Packet_Notice_Stat_ViewStat_VideoStat();
  virtual ~Packet_Notice_Stat_ViewStat_VideoStat();

  Packet_Notice_Stat_ViewStat_VideoStat(const Packet_Notice_Stat_ViewStat_VideoStat& from);

  inline Packet_Notice_Stat_ViewStat_VideoStat& operator=(const Packet_Notice_Stat_ViewStat_VideoStat& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Packet_Notice_Stat_ViewStat_VideoStat& default_instance();

  void Swap(Packet_Notice_Stat_ViewStat_VideoStat* other);

  // implements Message ----------------------------------------------

  Packet_Notice_Stat_ViewStat_VideoStat* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Packet_Notice_Stat_ViewStat_VideoStat& from);
  void MergeFrom(const Packet_Notice_Stat_ViewStat_VideoStat& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Packet_Notice_Stat_ViewStat_VideoStat_VideoStatType VideoStatType;
  static const VideoStatType CAMERA_ADD = Packet_Notice_Stat_ViewStat_VideoStat_VideoStatType_CAMERA_ADD;
  static const VideoStatType CAMERA_REMOVE = Packet_Notice_Stat_ViewStat_VideoStat_VideoStatType_CAMERA_REMOVE;
  static const VideoStatType POLL_INTERVAL = Packet_Notice_Stat_ViewStat_VideoStat_VideoStatType_POLL_INTERVAL;
  static const VideoStatType KEEP_STRETCH = Packet_Notice_Stat_ViewStat_VideoStat_VideoStatType_KEEP_STRETCH;
  static inline bool VideoStatType_IsValid(int value) {
    return Packet_Notice_Stat_ViewStat_VideoStat_VideoStatType_IsValid(value);
  }
  static const VideoStatType VideoStatType_MIN =
    Packet_Notice_Stat_ViewStat_VideoStat_VideoStatType_VideoStatType_MIN;
  static const VideoStatType VideoStatType_MAX =
    Packet_Notice_Stat_ViewStat_VideoStat_VideoStatType_VideoStatType_MAX;
  static const int VideoStatType_ARRAYSIZE =
    Packet_Notice_Stat_ViewStat_VideoStat_VideoStatType_VideoStatType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  VideoStatType_descriptor() {
    return Packet_Notice_Stat_ViewStat_VideoStat_VideoStatType_descriptor();
  }
  static inline const ::std::string& VideoStatType_Name(VideoStatType value) {
    return Packet_Notice_Stat_ViewStat_VideoStat_VideoStatType_Name(value);
  }
  static inline bool VideoStatType_Parse(const ::std::string& name,
      VideoStatType* value) {
    return Packet_Notice_Stat_ViewStat_VideoStat_VideoStatType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .TvWall.Packet.Notice.Stat.ViewStat.VideoStat.VideoStatType type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::TvWall::Packet_Notice_Stat_ViewStat_VideoStat_VideoStatType type() const;
  inline void set_type(::TvWall::Packet_Notice_Stat_ViewStat_VideoStat_VideoStatType value);

  // required int32 winId = 2;
  inline bool has_winid() const;
  inline void clear_winid();
  static const int kWinIdFieldNumber = 2;
  inline ::google::protobuf::int32 winid() const;
  inline void set_winid(::google::protobuf::int32 value);

  // repeated .TvWall.Guid cameraId = 3;
  inline int cameraid_size() const;
  inline void clear_cameraid();
  static const int kCameraIdFieldNumber = 3;
  inline const ::TvWall::Guid& cameraid(int index) const;
  inline ::TvWall::Guid* mutable_cameraid(int index);
  inline ::TvWall::Guid* add_cameraid();
  inline const ::google::protobuf::RepeatedPtrField< ::TvWall::Guid >&
      cameraid() const;
  inline ::google::protobuf::RepeatedPtrField< ::TvWall::Guid >*
      mutable_cameraid();

  // optional int32 pollInterval = 4;
  inline bool has_pollinterval() const;
  inline void clear_pollinterval();
  static const int kPollIntervalFieldNumber = 4;
  inline ::google::protobuf::int32 pollinterval() const;
  inline void set_pollinterval(::google::protobuf::int32 value);

  // optional bool keepStretch = 5;
  inline bool has_keepstretch() const;
  inline void clear_keepstretch();
  static const int kKeepStretchFieldNumber = 5;
  inline bool keepstretch() const;
  inline void set_keepstretch(bool value);

  // repeated .TvWall.Guid cameraIddy = 6;
  inline int cameraiddy_size() const;
  inline void clear_cameraiddy();
  static const int kCameraIddyFieldNumber = 6;
  inline const ::TvWall::Guid& cameraiddy(int index) const;
  inline ::TvWall::Guid* mutable_cameraiddy(int index);
  inline ::TvWall::Guid* add_cameraiddy();
  inline const ::google::protobuf::RepeatedPtrField< ::TvWall::Guid >&
      cameraiddy() const;
  inline ::google::protobuf::RepeatedPtrField< ::TvWall::Guid >*
      mutable_cameraiddy();

  // @@protoc_insertion_point(class_scope:TvWall.Packet.Notice.Stat.ViewStat.VideoStat)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_winid();
  inline void clear_has_winid();
  inline void set_has_pollinterval();
  inline void clear_has_pollinterval();
  inline void set_has_keepstretch();
  inline void clear_has_keepstretch();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int type_;
  ::google::protobuf::int32 winid_;
  ::google::protobuf::RepeatedPtrField< ::TvWall::Guid > cameraid_;
  ::google::protobuf::int32 pollinterval_;
  bool keepstretch_;
  ::google::protobuf::RepeatedPtrField< ::TvWall::Guid > cameraiddy_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_protobuf_2ftvWall_2eproto();
  friend void protobuf_AssignDesc_protobuf_2ftvWall_2eproto();
  friend void protobuf_ShutdownFile_protobuf_2ftvWall_2eproto();

  void InitAsDefaultInstance();
  static Packet_Notice_Stat_ViewStat_VideoStat* default_instance_;
};
// -------------------------------------------------------------------

class Packet_Notice_Stat_ViewStat_RecordStat : public ::google::protobuf::Message {
 public:
  Packet_Notice_Stat_ViewStat_RecordStat();
  virtual ~Packet_Notice_Stat_ViewStat_RecordStat();

  Packet_Notice_Stat_ViewStat_RecordStat(const Packet_Notice_Stat_ViewStat_RecordStat& from);

  inline Packet_Notice_Stat_ViewStat_RecordStat& operator=(const Packet_Notice_Stat_ViewStat_RecordStat& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Packet_Notice_Stat_ViewStat_RecordStat& default_instance();

  void Swap(Packet_Notice_Stat_ViewStat_RecordStat* other);

  // implements Message ----------------------------------------------

  Packet_Notice_Stat_ViewStat_RecordStat* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Packet_Notice_Stat_ViewStat_RecordStat& from);
  void MergeFrom(const Packet_Notice_Stat_ViewStat_RecordStat& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Packet_Notice_Stat_ViewStat_RecordStat_RecordStatType RecordStatType;
  static const RecordStatType RESET_START_TIME = Packet_Notice_Stat_ViewStat_RecordStat_RecordStatType_RESET_START_TIME;
  static const RecordStatType KEEP_STRETCH = Packet_Notice_Stat_ViewStat_RecordStat_RecordStatType_KEEP_STRETCH;
  static const RecordStatType SET_RATE = Packet_Notice_Stat_ViewStat_RecordStat_RecordStatType_SET_RATE;
  static const RecordStatType PAUSE = Packet_Notice_Stat_ViewStat_RecordStat_RecordStatType_PAUSE;
  static const RecordStatType SLOW = Packet_Notice_Stat_ViewStat_RecordStat_RecordStatType_SLOW;
  static const RecordStatType FAST = Packet_Notice_Stat_ViewStat_RecordStat_RecordStatType_FAST;
  static const RecordStatType BACK = Packet_Notice_Stat_ViewStat_RecordStat_RecordStatType_BACK;
  static const RecordStatType FORWARD = Packet_Notice_Stat_ViewStat_RecordStat_RecordStatType_FORWARD;
  static inline bool RecordStatType_IsValid(int value) {
    return Packet_Notice_Stat_ViewStat_RecordStat_RecordStatType_IsValid(value);
  }
  static const RecordStatType RecordStatType_MIN =
    Packet_Notice_Stat_ViewStat_RecordStat_RecordStatType_RecordStatType_MIN;
  static const RecordStatType RecordStatType_MAX =
    Packet_Notice_Stat_ViewStat_RecordStat_RecordStatType_RecordStatType_MAX;
  static const int RecordStatType_ARRAYSIZE =
    Packet_Notice_Stat_ViewStat_RecordStat_RecordStatType_RecordStatType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  RecordStatType_descriptor() {
    return Packet_Notice_Stat_ViewStat_RecordStat_RecordStatType_descriptor();
  }
  static inline const ::std::string& RecordStatType_Name(RecordStatType value) {
    return Packet_Notice_Stat_ViewStat_RecordStat_RecordStatType_Name(value);
  }
  static inline bool RecordStatType_Parse(const ::std::string& name,
      RecordStatType* value) {
    return Packet_Notice_Stat_ViewStat_RecordStat_RecordStatType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .TvWall.Packet.Notice.Stat.ViewStat.RecordStat.RecordStatType type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::TvWall::Packet_Notice_Stat_ViewStat_RecordStat_RecordStatType type() const;
  inline void set_type(::TvWall::Packet_Notice_Stat_ViewStat_RecordStat_RecordStatType value);

  // required int32 winId = 2;
  inline bool has_winid() const;
  inline void clear_winid();
  static const int kWinIdFieldNumber = 2;
  inline ::google::protobuf::int32 winid() const;
  inline void set_winid(::google::protobuf::int32 value);

  // required .TvWall.Guid cameraId = 3;
  inline bool has_cameraid() const;
  inline void clear_cameraid();
  static const int kCameraIdFieldNumber = 3;
  inline const ::TvWall::Guid& cameraid() const;
  inline ::TvWall::Guid* mutable_cameraid();
  inline ::TvWall::Guid* release_cameraid();
  inline void set_allocated_cameraid(::TvWall::Guid* cameraid);

  // optional uint64 startTime = 4;
  inline bool has_starttime() const;
  inline void clear_starttime();
  static const int kStartTimeFieldNumber = 4;
  inline ::google::protobuf::uint64 starttime() const;
  inline void set_starttime(::google::protobuf::uint64 value);

  // optional bool keepStretch = 5;
  inline bool has_keepstretch() const;
  inline void clear_keepstretch();
  static const int kKeepStretchFieldNumber = 5;
  inline bool keepstretch() const;
  inline void set_keepstretch(bool value);

  // optional int32 rate = 6;
  inline bool has_rate() const;
  inline void clear_rate();
  static const int kRateFieldNumber = 6;
  inline ::google::protobuf::int32 rate() const;
  inline void set_rate(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:TvWall.Packet.Notice.Stat.ViewStat.RecordStat)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_winid();
  inline void clear_has_winid();
  inline void set_has_cameraid();
  inline void clear_has_cameraid();
  inline void set_has_starttime();
  inline void clear_has_starttime();
  inline void set_has_keepstretch();
  inline void clear_has_keepstretch();
  inline void set_has_rate();
  inline void clear_has_rate();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int type_;
  ::google::protobuf::int32 winid_;
  ::TvWall::Guid* cameraid_;
  ::google::protobuf::uint64 starttime_;
  bool keepstretch_;
  ::google::protobuf::int32 rate_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_protobuf_2ftvWall_2eproto();
  friend void protobuf_AssignDesc_protobuf_2ftvWall_2eproto();
  friend void protobuf_ShutdownFile_protobuf_2ftvWall_2eproto();

  void InitAsDefaultInstance();
  static Packet_Notice_Stat_ViewStat_RecordStat* default_instance_;
};
// -------------------------------------------------------------------

class Packet_Notice_Stat_ViewStat_LocalMovieStat : public ::google::protobuf::Message {
 public:
  Packet_Notice_Stat_ViewStat_LocalMovieStat();
  virtual ~Packet_Notice_Stat_ViewStat_LocalMovieStat();

  Packet_Notice_Stat_ViewStat_LocalMovieStat(const Packet_Notice_Stat_ViewStat_LocalMovieStat& from);

  inline Packet_Notice_Stat_ViewStat_LocalMovieStat& operator=(const Packet_Notice_Stat_ViewStat_LocalMovieStat& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Packet_Notice_Stat_ViewStat_LocalMovieStat& default_instance();

  void Swap(Packet_Notice_Stat_ViewStat_LocalMovieStat* other);

  // implements Message ----------------------------------------------

  Packet_Notice_Stat_ViewStat_LocalMovieStat* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Packet_Notice_Stat_ViewStat_LocalMovieStat& from);
  void MergeFrom(const Packet_Notice_Stat_ViewStat_LocalMovieStat& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Packet_Notice_Stat_ViewStat_LocalMovieStat_LocalMovieType LocalMovieType;
  static const LocalMovieType SET_FILE = Packet_Notice_Stat_ViewStat_LocalMovieStat_LocalMovieType_SET_FILE;
  static const LocalMovieType SET_VOLUME = Packet_Notice_Stat_ViewStat_LocalMovieStat_LocalMovieType_SET_VOLUME;
  static const LocalMovieType SET_SLIDER = Packet_Notice_Stat_ViewStat_LocalMovieStat_LocalMovieType_SET_SLIDER;
  static const LocalMovieType PAUSE = Packet_Notice_Stat_ViewStat_LocalMovieStat_LocalMovieType_PAUSE;
  static const LocalMovieType STOP = Packet_Notice_Stat_ViewStat_LocalMovieStat_LocalMovieType_STOP;
  static inline bool LocalMovieType_IsValid(int value) {
    return Packet_Notice_Stat_ViewStat_LocalMovieStat_LocalMovieType_IsValid(value);
  }
  static const LocalMovieType LocalMovieType_MIN =
    Packet_Notice_Stat_ViewStat_LocalMovieStat_LocalMovieType_LocalMovieType_MIN;
  static const LocalMovieType LocalMovieType_MAX =
    Packet_Notice_Stat_ViewStat_LocalMovieStat_LocalMovieType_LocalMovieType_MAX;
  static const int LocalMovieType_ARRAYSIZE =
    Packet_Notice_Stat_ViewStat_LocalMovieStat_LocalMovieType_LocalMovieType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  LocalMovieType_descriptor() {
    return Packet_Notice_Stat_ViewStat_LocalMovieStat_LocalMovieType_descriptor();
  }
  static inline const ::std::string& LocalMovieType_Name(LocalMovieType value) {
    return Packet_Notice_Stat_ViewStat_LocalMovieStat_LocalMovieType_Name(value);
  }
  static inline bool LocalMovieType_Parse(const ::std::string& name,
      LocalMovieType* value) {
    return Packet_Notice_Stat_ViewStat_LocalMovieStat_LocalMovieType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .TvWall.Packet.Notice.Stat.ViewStat.LocalMovieStat.LocalMovieType type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::TvWall::Packet_Notice_Stat_ViewStat_LocalMovieStat_LocalMovieType type() const;
  inline void set_type(::TvWall::Packet_Notice_Stat_ViewStat_LocalMovieStat_LocalMovieType value);

  // required int32 winId = 2;
  inline bool has_winid() const;
  inline void clear_winid();
  static const int kWinIdFieldNumber = 2;
  inline ::google::protobuf::int32 winid() const;
  inline void set_winid(::google::protobuf::int32 value);

  // optional string url = 3;
  inline bool has_url() const;
  inline void clear_url();
  static const int kUrlFieldNumber = 3;
  inline const ::std::string& url() const;
  inline void set_url(const ::std::string& value);
  inline void set_url(const char* value);
  inline void set_url(const char* value, size_t size);
  inline ::std::string* mutable_url();
  inline ::std::string* release_url();
  inline void set_allocated_url(::std::string* url);

  // optional int32 volume = 4;
  inline bool has_volume() const;
  inline void clear_volume();
  static const int kVolumeFieldNumber = 4;
  inline ::google::protobuf::int32 volume() const;
  inline void set_volume(::google::protobuf::int32 value);

  // optional int64 timeStamp = 5;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimeStampFieldNumber = 5;
  inline ::google::protobuf::int64 timestamp() const;
  inline void set_timestamp(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:TvWall.Packet.Notice.Stat.ViewStat.LocalMovieStat)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_winid();
  inline void clear_has_winid();
  inline void set_has_url();
  inline void clear_has_url();
  inline void set_has_volume();
  inline void clear_has_volume();
  inline void set_has_timestamp();
  inline void clear_has_timestamp();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int type_;
  ::google::protobuf::int32 winid_;
  ::std::string* url_;
  ::google::protobuf::int64 timestamp_;
  ::google::protobuf::int32 volume_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_protobuf_2ftvWall_2eproto();
  friend void protobuf_AssignDesc_protobuf_2ftvWall_2eproto();
  friend void protobuf_ShutdownFile_protobuf_2ftvWall_2eproto();

  void InitAsDefaultInstance();
  static Packet_Notice_Stat_ViewStat_LocalMovieStat* default_instance_;
};
// -------------------------------------------------------------------

class Packet_Notice_Stat_ViewStat_FlashStat : public ::google::protobuf::Message {
 public:
  Packet_Notice_Stat_ViewStat_FlashStat();
  virtual ~Packet_Notice_Stat_ViewStat_FlashStat();

  Packet_Notice_Stat_ViewStat_FlashStat(const Packet_Notice_Stat_ViewStat_FlashStat& from);

  inline Packet_Notice_Stat_ViewStat_FlashStat& operator=(const Packet_Notice_Stat_ViewStat_FlashStat& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Packet_Notice_Stat_ViewStat_FlashStat& default_instance();

  void Swap(Packet_Notice_Stat_ViewStat_FlashStat* other);

  // implements Message ----------------------------------------------

  Packet_Notice_Stat_ViewStat_FlashStat* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Packet_Notice_Stat_ViewStat_FlashStat& from);
  void MergeFrom(const Packet_Notice_Stat_ViewStat_FlashStat& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Packet_Notice_Stat_ViewStat_FlashStat_FlashStatType FlashStatType;
  static const FlashStatType SET_FLASH = Packet_Notice_Stat_ViewStat_FlashStat_FlashStatType_SET_FLASH;
  static inline bool FlashStatType_IsValid(int value) {
    return Packet_Notice_Stat_ViewStat_FlashStat_FlashStatType_IsValid(value);
  }
  static const FlashStatType FlashStatType_MIN =
    Packet_Notice_Stat_ViewStat_FlashStat_FlashStatType_FlashStatType_MIN;
  static const FlashStatType FlashStatType_MAX =
    Packet_Notice_Stat_ViewStat_FlashStat_FlashStatType_FlashStatType_MAX;
  static const int FlashStatType_ARRAYSIZE =
    Packet_Notice_Stat_ViewStat_FlashStat_FlashStatType_FlashStatType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  FlashStatType_descriptor() {
    return Packet_Notice_Stat_ViewStat_FlashStat_FlashStatType_descriptor();
  }
  static inline const ::std::string& FlashStatType_Name(FlashStatType value) {
    return Packet_Notice_Stat_ViewStat_FlashStat_FlashStatType_Name(value);
  }
  static inline bool FlashStatType_Parse(const ::std::string& name,
      FlashStatType* value) {
    return Packet_Notice_Stat_ViewStat_FlashStat_FlashStatType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .TvWall.Packet.Notice.Stat.ViewStat.FlashStat.FlashStatType type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::TvWall::Packet_Notice_Stat_ViewStat_FlashStat_FlashStatType type() const;
  inline void set_type(::TvWall::Packet_Notice_Stat_ViewStat_FlashStat_FlashStatType value);

  // required int32 winId = 2;
  inline bool has_winid() const;
  inline void clear_winid();
  static const int kWinIdFieldNumber = 2;
  inline ::google::protobuf::int32 winid() const;
  inline void set_winid(::google::protobuf::int32 value);

  // required string url = 3;
  inline bool has_url() const;
  inline void clear_url();
  static const int kUrlFieldNumber = 3;
  inline const ::std::string& url() const;
  inline void set_url(const ::std::string& value);
  inline void set_url(const char* value);
  inline void set_url(const char* value, size_t size);
  inline ::std::string* mutable_url();
  inline ::std::string* release_url();
  inline void set_allocated_url(::std::string* url);

  // @@protoc_insertion_point(class_scope:TvWall.Packet.Notice.Stat.ViewStat.FlashStat)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_winid();
  inline void clear_has_winid();
  inline void set_has_url();
  inline void clear_has_url();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int type_;
  ::google::protobuf::int32 winid_;
  ::std::string* url_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_protobuf_2ftvWall_2eproto();
  friend void protobuf_AssignDesc_protobuf_2ftvWall_2eproto();
  friend void protobuf_ShutdownFile_protobuf_2ftvWall_2eproto();

  void InitAsDefaultInstance();
  static Packet_Notice_Stat_ViewStat_FlashStat* default_instance_;
};
// -------------------------------------------------------------------

class Packet_Notice_Stat_ViewStat_HTMLStat : public ::google::protobuf::Message {
 public:
  Packet_Notice_Stat_ViewStat_HTMLStat();
  virtual ~Packet_Notice_Stat_ViewStat_HTMLStat();

  Packet_Notice_Stat_ViewStat_HTMLStat(const Packet_Notice_Stat_ViewStat_HTMLStat& from);

  inline Packet_Notice_Stat_ViewStat_HTMLStat& operator=(const Packet_Notice_Stat_ViewStat_HTMLStat& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Packet_Notice_Stat_ViewStat_HTMLStat& default_instance();

  void Swap(Packet_Notice_Stat_ViewStat_HTMLStat* other);

  // implements Message ----------------------------------------------

  Packet_Notice_Stat_ViewStat_HTMLStat* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Packet_Notice_Stat_ViewStat_HTMLStat& from);
  void MergeFrom(const Packet_Notice_Stat_ViewStat_HTMLStat& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Packet_Notice_Stat_ViewStat_HTMLStat_HTMLStatType HTMLStatType;
  static const HTMLStatType SET_HTML = Packet_Notice_Stat_ViewStat_HTMLStat_HTMLStatType_SET_HTML;
  static inline bool HTMLStatType_IsValid(int value) {
    return Packet_Notice_Stat_ViewStat_HTMLStat_HTMLStatType_IsValid(value);
  }
  static const HTMLStatType HTMLStatType_MIN =
    Packet_Notice_Stat_ViewStat_HTMLStat_HTMLStatType_HTMLStatType_MIN;
  static const HTMLStatType HTMLStatType_MAX =
    Packet_Notice_Stat_ViewStat_HTMLStat_HTMLStatType_HTMLStatType_MAX;
  static const int HTMLStatType_ARRAYSIZE =
    Packet_Notice_Stat_ViewStat_HTMLStat_HTMLStatType_HTMLStatType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  HTMLStatType_descriptor() {
    return Packet_Notice_Stat_ViewStat_HTMLStat_HTMLStatType_descriptor();
  }
  static inline const ::std::string& HTMLStatType_Name(HTMLStatType value) {
    return Packet_Notice_Stat_ViewStat_HTMLStat_HTMLStatType_Name(value);
  }
  static inline bool HTMLStatType_Parse(const ::std::string& name,
      HTMLStatType* value) {
    return Packet_Notice_Stat_ViewStat_HTMLStat_HTMLStatType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .TvWall.Packet.Notice.Stat.ViewStat.HTMLStat.HTMLStatType type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::TvWall::Packet_Notice_Stat_ViewStat_HTMLStat_HTMLStatType type() const;
  inline void set_type(::TvWall::Packet_Notice_Stat_ViewStat_HTMLStat_HTMLStatType value);

  // required int32 winId = 2;
  inline bool has_winid() const;
  inline void clear_winid();
  static const int kWinIdFieldNumber = 2;
  inline ::google::protobuf::int32 winid() const;
  inline void set_winid(::google::protobuf::int32 value);

  // required string url = 3;
  inline bool has_url() const;
  inline void clear_url();
  static const int kUrlFieldNumber = 3;
  inline const ::std::string& url() const;
  inline void set_url(const ::std::string& value);
  inline void set_url(const char* value);
  inline void set_url(const char* value, size_t size);
  inline ::std::string* mutable_url();
  inline ::std::string* release_url();
  inline void set_allocated_url(::std::string* url);

  // @@protoc_insertion_point(class_scope:TvWall.Packet.Notice.Stat.ViewStat.HTMLStat)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_winid();
  inline void clear_has_winid();
  inline void set_has_url();
  inline void clear_has_url();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int type_;
  ::google::protobuf::int32 winid_;
  ::std::string* url_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_protobuf_2ftvWall_2eproto();
  friend void protobuf_AssignDesc_protobuf_2ftvWall_2eproto();
  friend void protobuf_ShutdownFile_protobuf_2ftvWall_2eproto();

  void InitAsDefaultInstance();
  static Packet_Notice_Stat_ViewStat_HTMLStat* default_instance_;
};
// -------------------------------------------------------------------

class Packet_Notice_Stat_ViewStat_TextStat : public ::google::protobuf::Message {
 public:
  Packet_Notice_Stat_ViewStat_TextStat();
  virtual ~Packet_Notice_Stat_ViewStat_TextStat();

  Packet_Notice_Stat_ViewStat_TextStat(const Packet_Notice_Stat_ViewStat_TextStat& from);

  inline Packet_Notice_Stat_ViewStat_TextStat& operator=(const Packet_Notice_Stat_ViewStat_TextStat& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Packet_Notice_Stat_ViewStat_TextStat& default_instance();

  void Swap(Packet_Notice_Stat_ViewStat_TextStat* other);

  // implements Message ----------------------------------------------

  Packet_Notice_Stat_ViewStat_TextStat* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Packet_Notice_Stat_ViewStat_TextStat& from);
  void MergeFrom(const Packet_Notice_Stat_ViewStat_TextStat& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Packet_Notice_Stat_ViewStat_TextStat_TextStatType TextStatType;
  static const TextStatType SET_TEXT = Packet_Notice_Stat_ViewStat_TextStat_TextStatType_SET_TEXT;
  static inline bool TextStatType_IsValid(int value) {
    return Packet_Notice_Stat_ViewStat_TextStat_TextStatType_IsValid(value);
  }
  static const TextStatType TextStatType_MIN =
    Packet_Notice_Stat_ViewStat_TextStat_TextStatType_TextStatType_MIN;
  static const TextStatType TextStatType_MAX =
    Packet_Notice_Stat_ViewStat_TextStat_TextStatType_TextStatType_MAX;
  static const int TextStatType_ARRAYSIZE =
    Packet_Notice_Stat_ViewStat_TextStat_TextStatType_TextStatType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  TextStatType_descriptor() {
    return Packet_Notice_Stat_ViewStat_TextStat_TextStatType_descriptor();
  }
  static inline const ::std::string& TextStatType_Name(TextStatType value) {
    return Packet_Notice_Stat_ViewStat_TextStat_TextStatType_Name(value);
  }
  static inline bool TextStatType_Parse(const ::std::string& name,
      TextStatType* value) {
    return Packet_Notice_Stat_ViewStat_TextStat_TextStatType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .TvWall.Packet.Notice.Stat.ViewStat.TextStat.TextStatType type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::TvWall::Packet_Notice_Stat_ViewStat_TextStat_TextStatType type() const;
  inline void set_type(::TvWall::Packet_Notice_Stat_ViewStat_TextStat_TextStatType value);

  // required int32 winId = 2;
  inline bool has_winid() const;
  inline void clear_winid();
  static const int kWinIdFieldNumber = 2;
  inline ::google::protobuf::int32 winid() const;
  inline void set_winid(::google::protobuf::int32 value);

  // optional string text = 3;
  inline bool has_text() const;
  inline void clear_text();
  static const int kTextFieldNumber = 3;
  inline const ::std::string& text() const;
  inline void set_text(const ::std::string& value);
  inline void set_text(const char* value);
  inline void set_text(const char* value, size_t size);
  inline ::std::string* mutable_text();
  inline ::std::string* release_text();
  inline void set_allocated_text(::std::string* text);

  // @@protoc_insertion_point(class_scope:TvWall.Packet.Notice.Stat.ViewStat.TextStat)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_winid();
  inline void clear_has_winid();
  inline void set_has_text();
  inline void clear_has_text();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int type_;
  ::google::protobuf::int32 winid_;
  ::std::string* text_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_protobuf_2ftvWall_2eproto();
  friend void protobuf_AssignDesc_protobuf_2ftvWall_2eproto();
  friend void protobuf_ShutdownFile_protobuf_2ftvWall_2eproto();

  void InitAsDefaultInstance();
  static Packet_Notice_Stat_ViewStat_TextStat* default_instance_;
};
// -------------------------------------------------------------------

class Packet_Notice_Stat_ViewStat_MapStat : public ::google::protobuf::Message {
 public:
  Packet_Notice_Stat_ViewStat_MapStat();
  virtual ~Packet_Notice_Stat_ViewStat_MapStat();

  Packet_Notice_Stat_ViewStat_MapStat(const Packet_Notice_Stat_ViewStat_MapStat& from);

  inline Packet_Notice_Stat_ViewStat_MapStat& operator=(const Packet_Notice_Stat_ViewStat_MapStat& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Packet_Notice_Stat_ViewStat_MapStat& default_instance();

  void Swap(Packet_Notice_Stat_ViewStat_MapStat* other);

  // implements Message ----------------------------------------------

  Packet_Notice_Stat_ViewStat_MapStat* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Packet_Notice_Stat_ViewStat_MapStat& from);
  void MergeFrom(const Packet_Notice_Stat_ViewStat_MapStat& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Packet_Notice_Stat_ViewStat_MapStat_MapCtrlType MapCtrlType;
  static const MapCtrlType SET_MAP = Packet_Notice_Stat_ViewStat_MapStat_MapCtrlType_SET_MAP;
  static inline bool MapCtrlType_IsValid(int value) {
    return Packet_Notice_Stat_ViewStat_MapStat_MapCtrlType_IsValid(value);
  }
  static const MapCtrlType MapCtrlType_MIN =
    Packet_Notice_Stat_ViewStat_MapStat_MapCtrlType_MapCtrlType_MIN;
  static const MapCtrlType MapCtrlType_MAX =
    Packet_Notice_Stat_ViewStat_MapStat_MapCtrlType_MapCtrlType_MAX;
  static const int MapCtrlType_ARRAYSIZE =
    Packet_Notice_Stat_ViewStat_MapStat_MapCtrlType_MapCtrlType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  MapCtrlType_descriptor() {
    return Packet_Notice_Stat_ViewStat_MapStat_MapCtrlType_descriptor();
  }
  static inline const ::std::string& MapCtrlType_Name(MapCtrlType value) {
    return Packet_Notice_Stat_ViewStat_MapStat_MapCtrlType_Name(value);
  }
  static inline bool MapCtrlType_Parse(const ::std::string& name,
      MapCtrlType* value) {
    return Packet_Notice_Stat_ViewStat_MapStat_MapCtrlType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .TvWall.Packet.Notice.Stat.ViewStat.MapStat.MapCtrlType type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::TvWall::Packet_Notice_Stat_ViewStat_MapStat_MapCtrlType type() const;
  inline void set_type(::TvWall::Packet_Notice_Stat_ViewStat_MapStat_MapCtrlType value);

  // required int32 winId = 2;
  inline bool has_winid() const;
  inline void clear_winid();
  static const int kWinIdFieldNumber = 2;
  inline ::google::protobuf::int32 winid() const;
  inline void set_winid(::google::protobuf::int32 value);

  // optional string url = 3;
  inline bool has_url() const;
  inline void clear_url();
  static const int kUrlFieldNumber = 3;
  inline const ::std::string& url() const;
  inline void set_url(const ::std::string& value);
  inline void set_url(const char* value);
  inline void set_url(const char* value, size_t size);
  inline ::std::string* mutable_url();
  inline ::std::string* release_url();
  inline void set_allocated_url(::std::string* url);

  // @@protoc_insertion_point(class_scope:TvWall.Packet.Notice.Stat.ViewStat.MapStat)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_winid();
  inline void clear_has_winid();
  inline void set_has_url();
  inline void clear_has_url();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int type_;
  ::google::protobuf::int32 winid_;
  ::std::string* url_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_protobuf_2ftvWall_2eproto();
  friend void protobuf_AssignDesc_protobuf_2ftvWall_2eproto();
  friend void protobuf_ShutdownFile_protobuf_2ftvWall_2eproto();

  void InitAsDefaultInstance();
  static Packet_Notice_Stat_ViewStat_MapStat* default_instance_;
};
// -------------------------------------------------------------------

class Packet_Notice_Stat_ViewStat_OthersStat : public ::google::protobuf::Message {
 public:
  Packet_Notice_Stat_ViewStat_OthersStat();
  virtual ~Packet_Notice_Stat_ViewStat_OthersStat();

  Packet_Notice_Stat_ViewStat_OthersStat(const Packet_Notice_Stat_ViewStat_OthersStat& from);

  inline Packet_Notice_Stat_ViewStat_OthersStat& operator=(const Packet_Notice_Stat_ViewStat_OthersStat& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Packet_Notice_Stat_ViewStat_OthersStat& default_instance();

  void Swap(Packet_Notice_Stat_ViewStat_OthersStat* other);

  // implements Message ----------------------------------------------

  Packet_Notice_Stat_ViewStat_OthersStat* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Packet_Notice_Stat_ViewStat_OthersStat& from);
  void MergeFrom(const Packet_Notice_Stat_ViewStat_OthersStat& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Packet_Notice_Stat_ViewStat_OthersStat_OthersStatType OthersStatType;
  static const OthersStatType OTHER_ADD = Packet_Notice_Stat_ViewStat_OthersStat_OthersStatType_OTHER_ADD;
  static const OthersStatType SERVER_NAME = Packet_Notice_Stat_ViewStat_OthersStat_OthersStatType_SERVER_NAME;
  static inline bool OthersStatType_IsValid(int value) {
    return Packet_Notice_Stat_ViewStat_OthersStat_OthersStatType_IsValid(value);
  }
  static const OthersStatType OthersStatType_MIN =
    Packet_Notice_Stat_ViewStat_OthersStat_OthersStatType_OthersStatType_MIN;
  static const OthersStatType OthersStatType_MAX =
    Packet_Notice_Stat_ViewStat_OthersStat_OthersStatType_OthersStatType_MAX;
  static const int OthersStatType_ARRAYSIZE =
    Packet_Notice_Stat_ViewStat_OthersStat_OthersStatType_OthersStatType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  OthersStatType_descriptor() {
    return Packet_Notice_Stat_ViewStat_OthersStat_OthersStatType_descriptor();
  }
  static inline const ::std::string& OthersStatType_Name(OthersStatType value) {
    return Packet_Notice_Stat_ViewStat_OthersStat_OthersStatType_Name(value);
  }
  static inline bool OthersStatType_Parse(const ::std::string& name,
      OthersStatType* value) {
    return Packet_Notice_Stat_ViewStat_OthersStat_OthersStatType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .TvWall.Packet.Notice.Stat.ViewStat.OthersStat.OthersStatType type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::TvWall::Packet_Notice_Stat_ViewStat_OthersStat_OthersStatType type() const;
  inline void set_type(::TvWall::Packet_Notice_Stat_ViewStat_OthersStat_OthersStatType value);

  // required int32 winId = 2;
  inline bool has_winid() const;
  inline void clear_winid();
  static const int kWinIdFieldNumber = 2;
  inline ::google::protobuf::int32 winid() const;
  inline void set_winid(::google::protobuf::int32 value);

  // optional string serName = 3;
  inline bool has_sername() const;
  inline void clear_sername();
  static const int kSerNameFieldNumber = 3;
  inline const ::std::string& sername() const;
  inline void set_sername(const ::std::string& value);
  inline void set_sername(const char* value);
  inline void set_sername(const char* value, size_t size);
  inline ::std::string* mutable_sername();
  inline ::std::string* release_sername();
  inline void set_allocated_sername(::std::string* sername);

  // @@protoc_insertion_point(class_scope:TvWall.Packet.Notice.Stat.ViewStat.OthersStat)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_winid();
  inline void clear_has_winid();
  inline void set_has_sername();
  inline void clear_has_sername();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int type_;
  ::google::protobuf::int32 winid_;
  ::std::string* sername_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_protobuf_2ftvWall_2eproto();
  friend void protobuf_AssignDesc_protobuf_2ftvWall_2eproto();
  friend void protobuf_ShutdownFile_protobuf_2ftvWall_2eproto();

  void InitAsDefaultInstance();
  static Packet_Notice_Stat_ViewStat_OthersStat* default_instance_;
};
// -------------------------------------------------------------------

class Packet_Notice_Stat_ViewStat : public ::google::protobuf::Message {
 public:
  Packet_Notice_Stat_ViewStat();
  virtual ~Packet_Notice_Stat_ViewStat();

  Packet_Notice_Stat_ViewStat(const Packet_Notice_Stat_ViewStat& from);

  inline Packet_Notice_Stat_ViewStat& operator=(const Packet_Notice_Stat_ViewStat& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Packet_Notice_Stat_ViewStat& default_instance();

  void Swap(Packet_Notice_Stat_ViewStat* other);

  // implements Message ----------------------------------------------

  Packet_Notice_Stat_ViewStat* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Packet_Notice_Stat_ViewStat& from);
  void MergeFrom(const Packet_Notice_Stat_ViewStat& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Packet_Notice_Stat_ViewStat_ViewGeomotryStat ViewGeomotryStat;
  typedef Packet_Notice_Stat_ViewStat_VideoStat VideoStat;
  typedef Packet_Notice_Stat_ViewStat_RecordStat RecordStat;
  typedef Packet_Notice_Stat_ViewStat_LocalMovieStat LocalMovieStat;
  typedef Packet_Notice_Stat_ViewStat_FlashStat FlashStat;
  typedef Packet_Notice_Stat_ViewStat_HTMLStat HTMLStat;
  typedef Packet_Notice_Stat_ViewStat_TextStat TextStat;
  typedef Packet_Notice_Stat_ViewStat_MapStat MapStat;
  typedef Packet_Notice_Stat_ViewStat_OthersStat OthersStat;

  // accessors -------------------------------------------------------

  // optional .TvWall.Packet.Notice.Stat.ViewStat.VideoStat videoStat = 1;
  inline bool has_videostat() const;
  inline void clear_videostat();
  static const int kVideoStatFieldNumber = 1;
  inline const ::TvWall::Packet_Notice_Stat_ViewStat_VideoStat& videostat() const;
  inline ::TvWall::Packet_Notice_Stat_ViewStat_VideoStat* mutable_videostat();
  inline ::TvWall::Packet_Notice_Stat_ViewStat_VideoStat* release_videostat();
  inline void set_allocated_videostat(::TvWall::Packet_Notice_Stat_ViewStat_VideoStat* videostat);

  // optional .TvWall.Packet.Notice.Stat.ViewStat.FlashStat flashStat = 2;
  inline bool has_flashstat() const;
  inline void clear_flashstat();
  static const int kFlashStatFieldNumber = 2;
  inline const ::TvWall::Packet_Notice_Stat_ViewStat_FlashStat& flashstat() const;
  inline ::TvWall::Packet_Notice_Stat_ViewStat_FlashStat* mutable_flashstat();
  inline ::TvWall::Packet_Notice_Stat_ViewStat_FlashStat* release_flashstat();
  inline void set_allocated_flashstat(::TvWall::Packet_Notice_Stat_ViewStat_FlashStat* flashstat);

  // optional .TvWall.Packet.Notice.Stat.ViewStat.HTMLStat htmlStat = 3;
  inline bool has_htmlstat() const;
  inline void clear_htmlstat();
  static const int kHtmlStatFieldNumber = 3;
  inline const ::TvWall::Packet_Notice_Stat_ViewStat_HTMLStat& htmlstat() const;
  inline ::TvWall::Packet_Notice_Stat_ViewStat_HTMLStat* mutable_htmlstat();
  inline ::TvWall::Packet_Notice_Stat_ViewStat_HTMLStat* release_htmlstat();
  inline void set_allocated_htmlstat(::TvWall::Packet_Notice_Stat_ViewStat_HTMLStat* htmlstat);

  // optional .TvWall.Packet.Notice.Stat.ViewStat.TextStat textStat = 4;
  inline bool has_textstat() const;
  inline void clear_textstat();
  static const int kTextStatFieldNumber = 4;
  inline const ::TvWall::Packet_Notice_Stat_ViewStat_TextStat& textstat() const;
  inline ::TvWall::Packet_Notice_Stat_ViewStat_TextStat* mutable_textstat();
  inline ::TvWall::Packet_Notice_Stat_ViewStat_TextStat* release_textstat();
  inline void set_allocated_textstat(::TvWall::Packet_Notice_Stat_ViewStat_TextStat* textstat);

  // optional .TvWall.Packet.Notice.Stat.ViewStat.OthersStat othersStat = 5;
  inline bool has_othersstat() const;
  inline void clear_othersstat();
  static const int kOthersStatFieldNumber = 5;
  inline const ::TvWall::Packet_Notice_Stat_ViewStat_OthersStat& othersstat() const;
  inline ::TvWall::Packet_Notice_Stat_ViewStat_OthersStat* mutable_othersstat();
  inline ::TvWall::Packet_Notice_Stat_ViewStat_OthersStat* release_othersstat();
  inline void set_allocated_othersstat(::TvWall::Packet_Notice_Stat_ViewStat_OthersStat* othersstat);

  // optional .TvWall.Packet.Notice.Stat.ViewStat.LocalMovieStat localMovieStat = 6;
  inline bool has_localmoviestat() const;
  inline void clear_localmoviestat();
  static const int kLocalMovieStatFieldNumber = 6;
  inline const ::TvWall::Packet_Notice_Stat_ViewStat_LocalMovieStat& localmoviestat() const;
  inline ::TvWall::Packet_Notice_Stat_ViewStat_LocalMovieStat* mutable_localmoviestat();
  inline ::TvWall::Packet_Notice_Stat_ViewStat_LocalMovieStat* release_localmoviestat();
  inline void set_allocated_localmoviestat(::TvWall::Packet_Notice_Stat_ViewStat_LocalMovieStat* localmoviestat);

  // optional .TvWall.Packet.Notice.Stat.ViewStat.ViewGeomotryStat viewGeomotryStat = 7;
  inline bool has_viewgeomotrystat() const;
  inline void clear_viewgeomotrystat();
  static const int kViewGeomotryStatFieldNumber = 7;
  inline const ::TvWall::Packet_Notice_Stat_ViewStat_ViewGeomotryStat& viewgeomotrystat() const;
  inline ::TvWall::Packet_Notice_Stat_ViewStat_ViewGeomotryStat* mutable_viewgeomotrystat();
  inline ::TvWall::Packet_Notice_Stat_ViewStat_ViewGeomotryStat* release_viewgeomotrystat();
  inline void set_allocated_viewgeomotrystat(::TvWall::Packet_Notice_Stat_ViewStat_ViewGeomotryStat* viewgeomotrystat);

  // optional .TvWall.Packet.Notice.Stat.ViewStat.RecordStat recordStat = 8;
  inline bool has_recordstat() const;
  inline void clear_recordstat();
  static const int kRecordStatFieldNumber = 8;
  inline const ::TvWall::Packet_Notice_Stat_ViewStat_RecordStat& recordstat() const;
  inline ::TvWall::Packet_Notice_Stat_ViewStat_RecordStat* mutable_recordstat();
  inline ::TvWall::Packet_Notice_Stat_ViewStat_RecordStat* release_recordstat();
  inline void set_allocated_recordstat(::TvWall::Packet_Notice_Stat_ViewStat_RecordStat* recordstat);

  // optional .TvWall.Packet.Notice.Stat.ViewStat.MapStat mapStat = 9;
  inline bool has_mapstat() const;
  inline void clear_mapstat();
  static const int kMapStatFieldNumber = 9;
  inline const ::TvWall::Packet_Notice_Stat_ViewStat_MapStat& mapstat() const;
  inline ::TvWall::Packet_Notice_Stat_ViewStat_MapStat* mutable_mapstat();
  inline ::TvWall::Packet_Notice_Stat_ViewStat_MapStat* release_mapstat();
  inline void set_allocated_mapstat(::TvWall::Packet_Notice_Stat_ViewStat_MapStat* mapstat);

  // @@protoc_insertion_point(class_scope:TvWall.Packet.Notice.Stat.ViewStat)
 private:
  inline void set_has_videostat();
  inline void clear_has_videostat();
  inline void set_has_flashstat();
  inline void clear_has_flashstat();
  inline void set_has_htmlstat();
  inline void clear_has_htmlstat();
  inline void set_has_textstat();
  inline void clear_has_textstat();
  inline void set_has_othersstat();
  inline void clear_has_othersstat();
  inline void set_has_localmoviestat();
  inline void clear_has_localmoviestat();
  inline void set_has_viewgeomotrystat();
  inline void clear_has_viewgeomotrystat();
  inline void set_has_recordstat();
  inline void clear_has_recordstat();
  inline void set_has_mapstat();
  inline void clear_has_mapstat();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TvWall::Packet_Notice_Stat_ViewStat_VideoStat* videostat_;
  ::TvWall::Packet_Notice_Stat_ViewStat_FlashStat* flashstat_;
  ::TvWall::Packet_Notice_Stat_ViewStat_HTMLStat* htmlstat_;
  ::TvWall::Packet_Notice_Stat_ViewStat_TextStat* textstat_;
  ::TvWall::Packet_Notice_Stat_ViewStat_OthersStat* othersstat_;
  ::TvWall::Packet_Notice_Stat_ViewStat_LocalMovieStat* localmoviestat_;
  ::TvWall::Packet_Notice_Stat_ViewStat_ViewGeomotryStat* viewgeomotrystat_;
  ::TvWall::Packet_Notice_Stat_ViewStat_RecordStat* recordstat_;
  ::TvWall::Packet_Notice_Stat_ViewStat_MapStat* mapstat_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];

  friend void  protobuf_AddDesc_protobuf_2ftvWall_2eproto();
  friend void protobuf_AssignDesc_protobuf_2ftvWall_2eproto();
  friend void protobuf_ShutdownFile_protobuf_2ftvWall_2eproto();

  void InitAsDefaultInstance();
  static Packet_Notice_Stat_ViewStat* default_instance_;
};
// -------------------------------------------------------------------

class Packet_Notice_Stat_CameraStat : public ::google::protobuf::Message {
 public:
  Packet_Notice_Stat_CameraStat();
  virtual ~Packet_Notice_Stat_CameraStat();

  Packet_Notice_Stat_CameraStat(const Packet_Notice_Stat_CameraStat& from);

  inline Packet_Notice_Stat_CameraStat& operator=(const Packet_Notice_Stat_CameraStat& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Packet_Notice_Stat_CameraStat& default_instance();

  void Swap(Packet_Notice_Stat_CameraStat* other);

  // implements Message ----------------------------------------------

  Packet_Notice_Stat_CameraStat* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Packet_Notice_Stat_CameraStat& from);
  void MergeFrom(const Packet_Notice_Stat_CameraStat& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Packet_Notice_Stat_CameraStat_PTZ_TYPE PTZ_TYPE;
  static const PTZ_TYPE LEFT = Packet_Notice_Stat_CameraStat_PTZ_TYPE_LEFT;
  static const PTZ_TYPE RIGHT = Packet_Notice_Stat_CameraStat_PTZ_TYPE_RIGHT;
  static const PTZ_TYPE UP = Packet_Notice_Stat_CameraStat_PTZ_TYPE_UP;
  static const PTZ_TYPE DOWN = Packet_Notice_Stat_CameraStat_PTZ_TYPE_DOWN;
  static const PTZ_TYPE ADD_CAMERA = Packet_Notice_Stat_CameraStat_PTZ_TYPE_ADD_CAMERA;
  static const PTZ_TYPE REMOVE_CAMERA = Packet_Notice_Stat_CameraStat_PTZ_TYPE_REMOVE_CAMERA;
  static const PTZ_TYPE NETSTAT = Packet_Notice_Stat_CameraStat_PTZ_TYPE_NETSTAT;
  static const PTZ_TYPE PLAYING_STAT = Packet_Notice_Stat_CameraStat_PTZ_TYPE_PLAYING_STAT;
  static const PTZ_TYPE PLAYBACK_STAT = Packet_Notice_Stat_CameraStat_PTZ_TYPE_PLAYBACK_STAT;
  static const PTZ_TYPE UPDATE = Packet_Notice_Stat_CameraStat_PTZ_TYPE_UPDATE;
  static const PTZ_TYPE ADD = Packet_Notice_Stat_CameraStat_PTZ_TYPE_ADD;
  static const PTZ_TYPE REMOVE = Packet_Notice_Stat_CameraStat_PTZ_TYPE_REMOVE;
  static const PTZ_TYPE ADD_GRP = Packet_Notice_Stat_CameraStat_PTZ_TYPE_ADD_GRP;
  static const PTZ_TYPE REMOVE_GRP = Packet_Notice_Stat_CameraStat_PTZ_TYPE_REMOVE_GRP;
  static const PTZ_TYPE UPDATE_GRP = Packet_Notice_Stat_CameraStat_PTZ_TYPE_UPDATE_GRP;
  static inline bool PTZ_TYPE_IsValid(int value) {
    return Packet_Notice_Stat_CameraStat_PTZ_TYPE_IsValid(value);
  }
  static const PTZ_TYPE PTZ_TYPE_MIN =
    Packet_Notice_Stat_CameraStat_PTZ_TYPE_PTZ_TYPE_MIN;
  static const PTZ_TYPE PTZ_TYPE_MAX =
    Packet_Notice_Stat_CameraStat_PTZ_TYPE_PTZ_TYPE_MAX;
  static const int PTZ_TYPE_ARRAYSIZE =
    Packet_Notice_Stat_CameraStat_PTZ_TYPE_PTZ_TYPE_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  PTZ_TYPE_descriptor() {
    return Packet_Notice_Stat_CameraStat_PTZ_TYPE_descriptor();
  }
  static inline const ::std::string& PTZ_TYPE_Name(PTZ_TYPE value) {
    return Packet_Notice_Stat_CameraStat_PTZ_TYPE_Name(value);
  }
  static inline bool PTZ_TYPE_Parse(const ::std::string& name,
      PTZ_TYPE* value) {
    return Packet_Notice_Stat_CameraStat_PTZ_TYPE_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .TvWall.Packet.Notice.Stat.CameraStat.PTZ_TYPE type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::TvWall::Packet_Notice_Stat_CameraStat_PTZ_TYPE type() const;
  inline void set_type(::TvWall::Packet_Notice_Stat_CameraStat_PTZ_TYPE value);

  // optional .TvWall.Guid cameraId = 2;
  inline bool has_cameraid() const;
  inline void clear_cameraid();
  static const int kCameraIdFieldNumber = 2;
  inline const ::TvWall::Guid& cameraid() const;
  inline ::TvWall::Guid* mutable_cameraid();
  inline ::TvWall::Guid* release_cameraid();
  inline void set_allocated_cameraid(::TvWall::Guid* cameraid);

  // repeated .TvWall.Packet.ElementDat.CameraGrp camGrp = 3;
  inline int camgrp_size() const;
  inline void clear_camgrp();
  static const int kCamGrpFieldNumber = 3;
  inline const ::TvWall::Packet_ElementDat_CameraGrp& camgrp(int index) const;
  inline ::TvWall::Packet_ElementDat_CameraGrp* mutable_camgrp(int index);
  inline ::TvWall::Packet_ElementDat_CameraGrp* add_camgrp();
  inline const ::google::protobuf::RepeatedPtrField< ::TvWall::Packet_ElementDat_CameraGrp >&
      camgrp() const;
  inline ::google::protobuf::RepeatedPtrField< ::TvWall::Packet_ElementDat_CameraGrp >*
      mutable_camgrp();

  // optional .TvWall.Packet.ElementDat.Camera cam = 4;
  inline bool has_cam() const;
  inline void clear_cam();
  static const int kCamFieldNumber = 4;
  inline const ::TvWall::Packet_ElementDat_Camera& cam() const;
  inline ::TvWall::Packet_ElementDat_Camera* mutable_cam();
  inline ::TvWall::Packet_ElementDat_Camera* release_cam();
  inline void set_allocated_cam(::TvWall::Packet_ElementDat_Camera* cam);

  // optional .TvWall.Packet.ElementDat.CameraGrp grp = 5;
  inline bool has_grp() const;
  inline void clear_grp();
  static const int kGrpFieldNumber = 5;
  inline const ::TvWall::Packet_ElementDat_CameraGrp& grp() const;
  inline ::TvWall::Packet_ElementDat_CameraGrp* mutable_grp();
  inline ::TvWall::Packet_ElementDat_CameraGrp* release_grp();
  inline void set_allocated_grp(::TvWall::Packet_ElementDat_CameraGrp* grp);

  // @@protoc_insertion_point(class_scope:TvWall.Packet.Notice.Stat.CameraStat)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_cameraid();
  inline void clear_has_cameraid();
  inline void set_has_cam();
  inline void clear_has_cam();
  inline void set_has_grp();
  inline void clear_has_grp();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TvWall::Guid* cameraid_;
  ::google::protobuf::RepeatedPtrField< ::TvWall::Packet_ElementDat_CameraGrp > camgrp_;
  ::TvWall::Packet_ElementDat_Camera* cam_;
  ::TvWall::Packet_ElementDat_CameraGrp* grp_;
  int type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_protobuf_2ftvWall_2eproto();
  friend void protobuf_AssignDesc_protobuf_2ftvWall_2eproto();
  friend void protobuf_ShutdownFile_protobuf_2ftvWall_2eproto();

  void InitAsDefaultInstance();
  static Packet_Notice_Stat_CameraStat* default_instance_;
};
// -------------------------------------------------------------------

class Packet_Notice_Stat_HotPointStat : public ::google::protobuf::Message {
 public:
  Packet_Notice_Stat_HotPointStat();
  virtual ~Packet_Notice_Stat_HotPointStat();

  Packet_Notice_Stat_HotPointStat(const Packet_Notice_Stat_HotPointStat& from);

  inline Packet_Notice_Stat_HotPointStat& operator=(const Packet_Notice_Stat_HotPointStat& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Packet_Notice_Stat_HotPointStat& default_instance();

  void Swap(Packet_Notice_Stat_HotPointStat* other);

  // implements Message ----------------------------------------------

  Packet_Notice_Stat_HotPointStat* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Packet_Notice_Stat_HotPointStat& from);
  void MergeFrom(const Packet_Notice_Stat_HotPointStat& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Packet_Notice_Stat_HotPointStat_HotPointStatType HotPointStatType;
  static const HotPointStatType CREATE = Packet_Notice_Stat_HotPointStat_HotPointStatType_CREATE;
  static const HotPointStatType REMOVE = Packet_Notice_Stat_HotPointStat_HotPointStatType_REMOVE;
  static const HotPointStatType RESET = Packet_Notice_Stat_HotPointStat_HotPointStatType_RESET;
  static const HotPointStatType RESET_SCREEN = Packet_Notice_Stat_HotPointStat_HotPointStatType_RESET_SCREEN;
  static inline bool HotPointStatType_IsValid(int value) {
    return Packet_Notice_Stat_HotPointStat_HotPointStatType_IsValid(value);
  }
  static const HotPointStatType HotPointStatType_MIN =
    Packet_Notice_Stat_HotPointStat_HotPointStatType_HotPointStatType_MIN;
  static const HotPointStatType HotPointStatType_MAX =
    Packet_Notice_Stat_HotPointStat_HotPointStatType_HotPointStatType_MAX;
  static const int HotPointStatType_ARRAYSIZE =
    Packet_Notice_Stat_HotPointStat_HotPointStatType_HotPointStatType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  HotPointStatType_descriptor() {
    return Packet_Notice_Stat_HotPointStat_HotPointStatType_descriptor();
  }
  static inline const ::std::string& HotPointStatType_Name(HotPointStatType value) {
    return Packet_Notice_Stat_HotPointStat_HotPointStatType_Name(value);
  }
  static inline bool HotPointStatType_Parse(const ::std::string& name,
      HotPointStatType* value) {
    return Packet_Notice_Stat_HotPointStat_HotPointStatType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .TvWall.Packet.Notice.Stat.HotPointStat.HotPointStatType type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::TvWall::Packet_Notice_Stat_HotPointStat_HotPointStatType type() const;
  inline void set_type(::TvWall::Packet_Notice_Stat_HotPointStat_HotPointStatType value);

  // optional .TvWall.Packet.ElementDat.HotPoint hotPoint = 2;
  inline bool has_hotpoint() const;
  inline void clear_hotpoint();
  static const int kHotPointFieldNumber = 2;
  inline const ::TvWall::Packet_ElementDat_HotPoint& hotpoint() const;
  inline ::TvWall::Packet_ElementDat_HotPoint* mutable_hotpoint();
  inline ::TvWall::Packet_ElementDat_HotPoint* release_hotpoint();
  inline void set_allocated_hotpoint(::TvWall::Packet_ElementDat_HotPoint* hotpoint);

  // @@protoc_insertion_point(class_scope:TvWall.Packet.Notice.Stat.HotPointStat)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_hotpoint();
  inline void clear_has_hotpoint();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TvWall::Packet_ElementDat_HotPoint* hotpoint_;
  int type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_protobuf_2ftvWall_2eproto();
  friend void protobuf_AssignDesc_protobuf_2ftvWall_2eproto();
  friend void protobuf_ShutdownFile_protobuf_2ftvWall_2eproto();

  void InitAsDefaultInstance();
  static Packet_Notice_Stat_HotPointStat* default_instance_;
};
// -------------------------------------------------------------------

class Packet_Notice_Stat_LayoutStat : public ::google::protobuf::Message {
 public:
  Packet_Notice_Stat_LayoutStat();
  virtual ~Packet_Notice_Stat_LayoutStat();

  Packet_Notice_Stat_LayoutStat(const Packet_Notice_Stat_LayoutStat& from);

  inline Packet_Notice_Stat_LayoutStat& operator=(const Packet_Notice_Stat_LayoutStat& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Packet_Notice_Stat_LayoutStat& default_instance();

  void Swap(Packet_Notice_Stat_LayoutStat* other);

  // implements Message ----------------------------------------------

  Packet_Notice_Stat_LayoutStat* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Packet_Notice_Stat_LayoutStat& from);
  void MergeFrom(const Packet_Notice_Stat_LayoutStat& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Packet_Notice_Stat_LayoutStat_LayoutStatType LayoutStatType;
  static const LayoutStatType ADD = Packet_Notice_Stat_LayoutStat_LayoutStatType_ADD;
  static const LayoutStatType REMOVE = Packet_Notice_Stat_LayoutStat_LayoutStatType_REMOVE;
  static const LayoutStatType USE = Packet_Notice_Stat_LayoutStat_LayoutStatType_USE;
  static inline bool LayoutStatType_IsValid(int value) {
    return Packet_Notice_Stat_LayoutStat_LayoutStatType_IsValid(value);
  }
  static const LayoutStatType LayoutStatType_MIN =
    Packet_Notice_Stat_LayoutStat_LayoutStatType_LayoutStatType_MIN;
  static const LayoutStatType LayoutStatType_MAX =
    Packet_Notice_Stat_LayoutStat_LayoutStatType_LayoutStatType_MAX;
  static const int LayoutStatType_ARRAYSIZE =
    Packet_Notice_Stat_LayoutStat_LayoutStatType_LayoutStatType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  LayoutStatType_descriptor() {
    return Packet_Notice_Stat_LayoutStat_LayoutStatType_descriptor();
  }
  static inline const ::std::string& LayoutStatType_Name(LayoutStatType value) {
    return Packet_Notice_Stat_LayoutStat_LayoutStatType_Name(value);
  }
  static inline bool LayoutStatType_Parse(const ::std::string& name,
      LayoutStatType* value) {
    return Packet_Notice_Stat_LayoutStat_LayoutStatType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .TvWall.Packet.Notice.Stat.LayoutStat.LayoutStatType type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::TvWall::Packet_Notice_Stat_LayoutStat_LayoutStatType type() const;
  inline void set_type(::TvWall::Packet_Notice_Stat_LayoutStat_LayoutStatType value);

  // repeated .TvWall.Packet.ElementDat.ServerLayout servLayout = 2;
  inline int servlayout_size() const;
  inline void clear_servlayout();
  static const int kServLayoutFieldNumber = 2;
  inline const ::TvWall::Packet_ElementDat_ServerLayout& servlayout(int index) const;
  inline ::TvWall::Packet_ElementDat_ServerLayout* mutable_servlayout(int index);
  inline ::TvWall::Packet_ElementDat_ServerLayout* add_servlayout();
  inline const ::google::protobuf::RepeatedPtrField< ::TvWall::Packet_ElementDat_ServerLayout >&
      servlayout() const;
  inline ::google::protobuf::RepeatedPtrField< ::TvWall::Packet_ElementDat_ServerLayout >*
      mutable_servlayout();

  // optional string currentLayout = 3;
  inline bool has_currentlayout() const;
  inline void clear_currentlayout();
  static const int kCurrentLayoutFieldNumber = 3;
  inline const ::std::string& currentlayout() const;
  inline void set_currentlayout(const ::std::string& value);
  inline void set_currentlayout(const char* value);
  inline void set_currentlayout(const char* value, size_t size);
  inline ::std::string* mutable_currentlayout();
  inline ::std::string* release_currentlayout();
  inline void set_allocated_currentlayout(::std::string* currentlayout);

  // optional .TvWall.Packet.ElementDat.ServerLayout dy = 4;
  inline bool has_dy() const;
  inline void clear_dy();
  static const int kDyFieldNumber = 4;
  inline const ::TvWall::Packet_ElementDat_ServerLayout& dy() const;
  inline ::TvWall::Packet_ElementDat_ServerLayout* mutable_dy();
  inline ::TvWall::Packet_ElementDat_ServerLayout* release_dy();
  inline void set_allocated_dy(::TvWall::Packet_ElementDat_ServerLayout* dy);

  // @@protoc_insertion_point(class_scope:TvWall.Packet.Notice.Stat.LayoutStat)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_currentlayout();
  inline void clear_has_currentlayout();
  inline void set_has_dy();
  inline void clear_has_dy();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::TvWall::Packet_ElementDat_ServerLayout > servlayout_;
  ::std::string* currentlayout_;
  ::TvWall::Packet_ElementDat_ServerLayout* dy_;
  int type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_protobuf_2ftvWall_2eproto();
  friend void protobuf_AssignDesc_protobuf_2ftvWall_2eproto();
  friend void protobuf_ShutdownFile_protobuf_2ftvWall_2eproto();

  void InitAsDefaultInstance();
  static Packet_Notice_Stat_LayoutStat* default_instance_;
};
// -------------------------------------------------------------------

class Packet_Notice_Stat_LayoutLoopStat : public ::google::protobuf::Message {
 public:
  Packet_Notice_Stat_LayoutLoopStat();
  virtual ~Packet_Notice_Stat_LayoutLoopStat();

  Packet_Notice_Stat_LayoutLoopStat(const Packet_Notice_Stat_LayoutLoopStat& from);

  inline Packet_Notice_Stat_LayoutLoopStat& operator=(const Packet_Notice_Stat_LayoutLoopStat& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Packet_Notice_Stat_LayoutLoopStat& default_instance();

  void Swap(Packet_Notice_Stat_LayoutLoopStat* other);

  // implements Message ----------------------------------------------

  Packet_Notice_Stat_LayoutLoopStat* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Packet_Notice_Stat_LayoutLoopStat& from);
  void MergeFrom(const Packet_Notice_Stat_LayoutLoopStat& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Packet_Notice_Stat_LayoutLoopStat_LayoutLoopStatType LayoutLoopStatType;
  static const LayoutLoopStatType ADD = Packet_Notice_Stat_LayoutLoopStat_LayoutLoopStatType_ADD;
  static const LayoutLoopStatType REMOVE = Packet_Notice_Stat_LayoutLoopStat_LayoutLoopStatType_REMOVE;
  static const LayoutLoopStatType ADD_LAYOUT = Packet_Notice_Stat_LayoutLoopStat_LayoutLoopStatType_ADD_LAYOUT;
  static const LayoutLoopStatType USE = Packet_Notice_Stat_LayoutLoopStat_LayoutLoopStatType_USE;
  static const LayoutLoopStatType SET_LOOP = Packet_Notice_Stat_LayoutLoopStat_LayoutLoopStatType_SET_LOOP;
  static const LayoutLoopStatType STOP = Packet_Notice_Stat_LayoutLoopStat_LayoutLoopStatType_STOP;
  static inline bool LayoutLoopStatType_IsValid(int value) {
    return Packet_Notice_Stat_LayoutLoopStat_LayoutLoopStatType_IsValid(value);
  }
  static const LayoutLoopStatType LayoutLoopStatType_MIN =
    Packet_Notice_Stat_LayoutLoopStat_LayoutLoopStatType_LayoutLoopStatType_MIN;
  static const LayoutLoopStatType LayoutLoopStatType_MAX =
    Packet_Notice_Stat_LayoutLoopStat_LayoutLoopStatType_LayoutLoopStatType_MAX;
  static const int LayoutLoopStatType_ARRAYSIZE =
    Packet_Notice_Stat_LayoutLoopStat_LayoutLoopStatType_LayoutLoopStatType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  LayoutLoopStatType_descriptor() {
    return Packet_Notice_Stat_LayoutLoopStat_LayoutLoopStatType_descriptor();
  }
  static inline const ::std::string& LayoutLoopStatType_Name(LayoutLoopStatType value) {
    return Packet_Notice_Stat_LayoutLoopStat_LayoutLoopStatType_Name(value);
  }
  static inline bool LayoutLoopStatType_Parse(const ::std::string& name,
      LayoutLoopStatType* value) {
    return Packet_Notice_Stat_LayoutLoopStat_LayoutLoopStatType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .TvWall.Packet.Notice.Stat.LayoutLoopStat.LayoutLoopStatType type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::TvWall::Packet_Notice_Stat_LayoutLoopStat_LayoutLoopStatType type() const;
  inline void set_type(::TvWall::Packet_Notice_Stat_LayoutLoopStat_LayoutLoopStatType value);

  // repeated .TvWall.Packet.ElementDat.ServerLayoutLoop servLayoutLoop = 2;
  inline int servlayoutloop_size() const;
  inline void clear_servlayoutloop();
  static const int kServLayoutLoopFieldNumber = 2;
  inline const ::TvWall::Packet_ElementDat_ServerLayoutLoop& servlayoutloop(int index) const;
  inline ::TvWall::Packet_ElementDat_ServerLayoutLoop* mutable_servlayoutloop(int index);
  inline ::TvWall::Packet_ElementDat_ServerLayoutLoop* add_servlayoutloop();
  inline const ::google::protobuf::RepeatedPtrField< ::TvWall::Packet_ElementDat_ServerLayoutLoop >&
      servlayoutloop() const;
  inline ::google::protobuf::RepeatedPtrField< ::TvWall::Packet_ElementDat_ServerLayoutLoop >*
      mutable_servlayoutloop();

  // optional string currentLayoutLoop = 4;
  inline bool has_currentlayoutloop() const;
  inline void clear_currentlayoutloop();
  static const int kCurrentLayoutLoopFieldNumber = 4;
  inline const ::std::string& currentlayoutloop() const;
  inline void set_currentlayoutloop(const ::std::string& value);
  inline void set_currentlayoutloop(const char* value);
  inline void set_currentlayoutloop(const char* value, size_t size);
  inline ::std::string* mutable_currentlayoutloop();
  inline ::std::string* release_currentlayoutloop();
  inline void set_allocated_currentlayoutloop(::std::string* currentlayoutloop);

  // optional uint32 loop = 5;
  inline bool has_loop() const;
  inline void clear_loop();
  static const int kLoopFieldNumber = 5;
  inline ::google::protobuf::uint32 loop() const;
  inline void set_loop(::google::protobuf::uint32 value);

  // optional .TvWall.Packet.ElementDat.ServerLayoutLoop dy = 6;
  inline bool has_dy() const;
  inline void clear_dy();
  static const int kDyFieldNumber = 6;
  inline const ::TvWall::Packet_ElementDat_ServerLayoutLoop& dy() const;
  inline ::TvWall::Packet_ElementDat_ServerLayoutLoop* mutable_dy();
  inline ::TvWall::Packet_ElementDat_ServerLayoutLoop* release_dy();
  inline void set_allocated_dy(::TvWall::Packet_ElementDat_ServerLayoutLoop* dy);

  // @@protoc_insertion_point(class_scope:TvWall.Packet.Notice.Stat.LayoutLoopStat)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_currentlayoutloop();
  inline void clear_has_currentlayoutloop();
  inline void set_has_loop();
  inline void clear_has_loop();
  inline void set_has_dy();
  inline void clear_has_dy();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::TvWall::Packet_ElementDat_ServerLayoutLoop > servlayoutloop_;
  int type_;
  ::google::protobuf::uint32 loop_;
  ::std::string* currentlayoutloop_;
  ::TvWall::Packet_ElementDat_ServerLayoutLoop* dy_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_protobuf_2ftvWall_2eproto();
  friend void protobuf_AssignDesc_protobuf_2ftvWall_2eproto();
  friend void protobuf_ShutdownFile_protobuf_2ftvWall_2eproto();

  void InitAsDefaultInstance();
  static Packet_Notice_Stat_LayoutLoopStat* default_instance_;
};
// -------------------------------------------------------------------

class Packet_Notice_Stat_MapGrpStat : public ::google::protobuf::Message {
 public:
  Packet_Notice_Stat_MapGrpStat();
  virtual ~Packet_Notice_Stat_MapGrpStat();

  Packet_Notice_Stat_MapGrpStat(const Packet_Notice_Stat_MapGrpStat& from);

  inline Packet_Notice_Stat_MapGrpStat& operator=(const Packet_Notice_Stat_MapGrpStat& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Packet_Notice_Stat_MapGrpStat& default_instance();

  void Swap(Packet_Notice_Stat_MapGrpStat* other);

  // implements Message ----------------------------------------------

  Packet_Notice_Stat_MapGrpStat* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Packet_Notice_Stat_MapGrpStat& from);
  void MergeFrom(const Packet_Notice_Stat_MapGrpStat& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Packet_Notice_Stat_MapGrpStat_MapGrpStatType MapGrpStatType;
  static const MapGrpStatType RESET = Packet_Notice_Stat_MapGrpStat_MapGrpStatType_RESET;
  static inline bool MapGrpStatType_IsValid(int value) {
    return Packet_Notice_Stat_MapGrpStat_MapGrpStatType_IsValid(value);
  }
  static const MapGrpStatType MapGrpStatType_MIN =
    Packet_Notice_Stat_MapGrpStat_MapGrpStatType_MapGrpStatType_MIN;
  static const MapGrpStatType MapGrpStatType_MAX =
    Packet_Notice_Stat_MapGrpStat_MapGrpStatType_MapGrpStatType_MAX;
  static const int MapGrpStatType_ARRAYSIZE =
    Packet_Notice_Stat_MapGrpStat_MapGrpStatType_MapGrpStatType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  MapGrpStatType_descriptor() {
    return Packet_Notice_Stat_MapGrpStat_MapGrpStatType_descriptor();
  }
  static inline const ::std::string& MapGrpStatType_Name(MapGrpStatType value) {
    return Packet_Notice_Stat_MapGrpStat_MapGrpStatType_Name(value);
  }
  static inline bool MapGrpStatType_Parse(const ::std::string& name,
      MapGrpStatType* value) {
    return Packet_Notice_Stat_MapGrpStat_MapGrpStatType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .TvWall.Packet.Notice.Stat.MapGrpStat.MapGrpStatType type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::TvWall::Packet_Notice_Stat_MapGrpStat_MapGrpStatType type() const;
  inline void set_type(::TvWall::Packet_Notice_Stat_MapGrpStat_MapGrpStatType value);

  // repeated .TvWall.Packet.ElementDat.Map mapGrp = 2;
  inline int mapgrp_size() const;
  inline void clear_mapgrp();
  static const int kMapGrpFieldNumber = 2;
  inline const ::TvWall::Packet_ElementDat_Map& mapgrp(int index) const;
  inline ::TvWall::Packet_ElementDat_Map* mutable_mapgrp(int index);
  inline ::TvWall::Packet_ElementDat_Map* add_mapgrp();
  inline const ::google::protobuf::RepeatedPtrField< ::TvWall::Packet_ElementDat_Map >&
      mapgrp() const;
  inline ::google::protobuf::RepeatedPtrField< ::TvWall::Packet_ElementDat_Map >*
      mutable_mapgrp();

  // @@protoc_insertion_point(class_scope:TvWall.Packet.Notice.Stat.MapGrpStat)
 private:
  inline void set_has_type();
  inline void clear_has_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::TvWall::Packet_ElementDat_Map > mapgrp_;
  int type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_protobuf_2ftvWall_2eproto();
  friend void protobuf_AssignDesc_protobuf_2ftvWall_2eproto();
  friend void protobuf_ShutdownFile_protobuf_2ftvWall_2eproto();

  void InitAsDefaultInstance();
  static Packet_Notice_Stat_MapGrpStat* default_instance_;
};
// -------------------------------------------------------------------

class Packet_Notice_Stat_ErrorStat : public ::google::protobuf::Message {
 public:
  Packet_Notice_Stat_ErrorStat();
  virtual ~Packet_Notice_Stat_ErrorStat();

  Packet_Notice_Stat_ErrorStat(const Packet_Notice_Stat_ErrorStat& from);

  inline Packet_Notice_Stat_ErrorStat& operator=(const Packet_Notice_Stat_ErrorStat& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Packet_Notice_Stat_ErrorStat& default_instance();

  void Swap(Packet_Notice_Stat_ErrorStat* other);

  // implements Message ----------------------------------------------

  Packet_Notice_Stat_ErrorStat* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Packet_Notice_Stat_ErrorStat& from);
  void MergeFrom(const Packet_Notice_Stat_ErrorStat& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string error = 1;
  inline bool has_error() const;
  inline void clear_error();
  static const int kErrorFieldNumber = 1;
  inline const ::std::string& error() const;
  inline void set_error(const ::std::string& value);
  inline void set_error(const char* value);
  inline void set_error(const char* value, size_t size);
  inline ::std::string* mutable_error();
  inline ::std::string* release_error();
  inline void set_allocated_error(::std::string* error);

  // @@protoc_insertion_point(class_scope:TvWall.Packet.Notice.Stat.ErrorStat)
 private:
  inline void set_has_error();
  inline void clear_has_error();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* error_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_protobuf_2ftvWall_2eproto();
  friend void protobuf_AssignDesc_protobuf_2ftvWall_2eproto();
  friend void protobuf_ShutdownFile_protobuf_2ftvWall_2eproto();

  void InitAsDefaultInstance();
  static Packet_Notice_Stat_ErrorStat* default_instance_;
};
// -------------------------------------------------------------------

class Packet_Notice_Stat_KeyboardSelectedStat : public ::google::protobuf::Message {
 public:
  Packet_Notice_Stat_KeyboardSelectedStat();
  virtual ~Packet_Notice_Stat_KeyboardSelectedStat();

  Packet_Notice_Stat_KeyboardSelectedStat(const Packet_Notice_Stat_KeyboardSelectedStat& from);

  inline Packet_Notice_Stat_KeyboardSelectedStat& operator=(const Packet_Notice_Stat_KeyboardSelectedStat& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Packet_Notice_Stat_KeyboardSelectedStat& default_instance();

  void Swap(Packet_Notice_Stat_KeyboardSelectedStat* other);

  // implements Message ----------------------------------------------

  Packet_Notice_Stat_KeyboardSelectedStat* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Packet_Notice_Stat_KeyboardSelectedStat& from);
  void MergeFrom(const Packet_Notice_Stat_KeyboardSelectedStat& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 screenId = 1;
  inline bool has_screenid() const;
  inline void clear_screenid();
  static const int kScreenIdFieldNumber = 1;
  inline ::google::protobuf::int32 screenid() const;
  inline void set_screenid(::google::protobuf::int32 value);

  // required .TvWall.Guid cameraId = 2;
  inline bool has_cameraid() const;
  inline void clear_cameraid();
  static const int kCameraIdFieldNumber = 2;
  inline const ::TvWall::Guid& cameraid() const;
  inline ::TvWall::Guid* mutable_cameraid();
  inline ::TvWall::Guid* release_cameraid();
  inline void set_allocated_cameraid(::TvWall::Guid* cameraid);

  // required int32 cellid = 3;
  inline bool has_cellid() const;
  inline void clear_cellid();
  static const int kCellidFieldNumber = 3;
  inline ::google::protobuf::int32 cellid() const;
  inline void set_cellid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:TvWall.Packet.Notice.Stat.KeyboardSelectedStat)
 private:
  inline void set_has_screenid();
  inline void clear_has_screenid();
  inline void set_has_cameraid();
  inline void clear_has_cameraid();
  inline void set_has_cellid();
  inline void clear_has_cellid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TvWall::Guid* cameraid_;
  ::google::protobuf::int32 screenid_;
  ::google::protobuf::int32 cellid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_protobuf_2ftvWall_2eproto();
  friend void protobuf_AssignDesc_protobuf_2ftvWall_2eproto();
  friend void protobuf_ShutdownFile_protobuf_2ftvWall_2eproto();

  void InitAsDefaultInstance();
  static Packet_Notice_Stat_KeyboardSelectedStat* default_instance_;
};
// -------------------------------------------------------------------

class Packet_Notice_Stat_AlarmStat : public ::google::protobuf::Message {
 public:
  Packet_Notice_Stat_AlarmStat();
  virtual ~Packet_Notice_Stat_AlarmStat();

  Packet_Notice_Stat_AlarmStat(const Packet_Notice_Stat_AlarmStat& from);

  inline Packet_Notice_Stat_AlarmStat& operator=(const Packet_Notice_Stat_AlarmStat& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Packet_Notice_Stat_AlarmStat& default_instance();

  void Swap(Packet_Notice_Stat_AlarmStat* other);

  // implements Message ----------------------------------------------

  Packet_Notice_Stat_AlarmStat* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Packet_Notice_Stat_AlarmStat& from);
  void MergeFrom(const Packet_Notice_Stat_AlarmStat& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string alarmSource = 1;
  inline bool has_alarmsource() const;
  inline void clear_alarmsource();
  static const int kAlarmSourceFieldNumber = 1;
  inline const ::std::string& alarmsource() const;
  inline void set_alarmsource(const ::std::string& value);
  inline void set_alarmsource(const char* value);
  inline void set_alarmsource(const char* value, size_t size);
  inline ::std::string* mutable_alarmsource();
  inline ::std::string* release_alarmsource();
  inline void set_allocated_alarmsource(::std::string* alarmsource);

  // required bool alarmClear = 2;
  inline bool has_alarmclear() const;
  inline void clear_alarmclear();
  static const int kAlarmClearFieldNumber = 2;
  inline bool alarmclear() const;
  inline void set_alarmclear(bool value);

  // @@protoc_insertion_point(class_scope:TvWall.Packet.Notice.Stat.AlarmStat)
 private:
  inline void set_has_alarmsource();
  inline void clear_has_alarmsource();
  inline void set_has_alarmclear();
  inline void clear_has_alarmclear();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* alarmsource_;
  bool alarmclear_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_protobuf_2ftvWall_2eproto();
  friend void protobuf_AssignDesc_protobuf_2ftvWall_2eproto();
  friend void protobuf_ShutdownFile_protobuf_2ftvWall_2eproto();

  void InitAsDefaultInstance();
  static Packet_Notice_Stat_AlarmStat* default_instance_;
};
// -------------------------------------------------------------------

class Packet_Notice_Stat_GroupLoopStat : public ::google::protobuf::Message {
 public:
  Packet_Notice_Stat_GroupLoopStat();
  virtual ~Packet_Notice_Stat_GroupLoopStat();

  Packet_Notice_Stat_GroupLoopStat(const Packet_Notice_Stat_GroupLoopStat& from);

  inline Packet_Notice_Stat_GroupLoopStat& operator=(const Packet_Notice_Stat_GroupLoopStat& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Packet_Notice_Stat_GroupLoopStat& default_instance();

  void Swap(Packet_Notice_Stat_GroupLoopStat* other);

  // implements Message ----------------------------------------------

  Packet_Notice_Stat_GroupLoopStat* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Packet_Notice_Stat_GroupLoopStat& from);
  void MergeFrom(const Packet_Notice_Stat_GroupLoopStat& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Packet_Notice_Stat_GroupLoopStat_GroupLoopStatType GroupLoopStatType;
  static const GroupLoopStatType ALL = Packet_Notice_Stat_GroupLoopStat_GroupLoopStatType_ALL;
  static const GroupLoopStatType FOCUS_AREA = Packet_Notice_Stat_GroupLoopStat_GroupLoopStatType_FOCUS_AREA;
  static const GroupLoopStatType RESET_VIEWS = Packet_Notice_Stat_GroupLoopStat_GroupLoopStatType_RESET_VIEWS;
  static const GroupLoopStatType LOOP_TIME = Packet_Notice_Stat_GroupLoopStat_GroupLoopStatType_LOOP_TIME;
  static const GroupLoopStatType ACTIVED = Packet_Notice_Stat_GroupLoopStat_GroupLoopStatType_ACTIVED;
  static inline bool GroupLoopStatType_IsValid(int value) {
    return Packet_Notice_Stat_GroupLoopStat_GroupLoopStatType_IsValid(value);
  }
  static const GroupLoopStatType GroupLoopStatType_MIN =
    Packet_Notice_Stat_GroupLoopStat_GroupLoopStatType_GroupLoopStatType_MIN;
  static const GroupLoopStatType GroupLoopStatType_MAX =
    Packet_Notice_Stat_GroupLoopStat_GroupLoopStatType_GroupLoopStatType_MAX;
  static const int GroupLoopStatType_ARRAYSIZE =
    Packet_Notice_Stat_GroupLoopStat_GroupLoopStatType_GroupLoopStatType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  GroupLoopStatType_descriptor() {
    return Packet_Notice_Stat_GroupLoopStat_GroupLoopStatType_descriptor();
  }
  static inline const ::std::string& GroupLoopStatType_Name(GroupLoopStatType value) {
    return Packet_Notice_Stat_GroupLoopStat_GroupLoopStatType_Name(value);
  }
  static inline bool GroupLoopStatType_Parse(const ::std::string& name,
      GroupLoopStatType* value) {
    return Packet_Notice_Stat_GroupLoopStat_GroupLoopStatType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .TvWall.Packet.Notice.Stat.GroupLoopStat.GroupLoopStatType type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::TvWall::Packet_Notice_Stat_GroupLoopStat_GroupLoopStatType type() const;
  inline void set_type(::TvWall::Packet_Notice_Stat_GroupLoopStat_GroupLoopStatType value);

  // required .TvWall.Packet.ElementDat.GroupLoop groupLoop = 2;
  inline bool has_grouploop() const;
  inline void clear_grouploop();
  static const int kGroupLoopFieldNumber = 2;
  inline const ::TvWall::Packet_ElementDat_GroupLoop& grouploop() const;
  inline ::TvWall::Packet_ElementDat_GroupLoop* mutable_grouploop();
  inline ::TvWall::Packet_ElementDat_GroupLoop* release_grouploop();
  inline void set_allocated_grouploop(::TvWall::Packet_ElementDat_GroupLoop* grouploop);

  // @@protoc_insertion_point(class_scope:TvWall.Packet.Notice.Stat.GroupLoopStat)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_grouploop();
  inline void clear_has_grouploop();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TvWall::Packet_ElementDat_GroupLoop* grouploop_;
  int type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_protobuf_2ftvWall_2eproto();
  friend void protobuf_AssignDesc_protobuf_2ftvWall_2eproto();
  friend void protobuf_ShutdownFile_protobuf_2ftvWall_2eproto();

  void InitAsDefaultInstance();
  static Packet_Notice_Stat_GroupLoopStat* default_instance_;
};
// -------------------------------------------------------------------

class Packet_Notice_Stat : public ::google::protobuf::Message {
 public:
  Packet_Notice_Stat();
  virtual ~Packet_Notice_Stat();

  Packet_Notice_Stat(const Packet_Notice_Stat& from);

  inline Packet_Notice_Stat& operator=(const Packet_Notice_Stat& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Packet_Notice_Stat& default_instance();

  void Swap(Packet_Notice_Stat* other);

  // implements Message ----------------------------------------------

  Packet_Notice_Stat* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Packet_Notice_Stat& from);
  void MergeFrom(const Packet_Notice_Stat& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Packet_Notice_Stat_ScreenSpliStat ScreenSpliStat;
  typedef Packet_Notice_Stat_ViewStat ViewStat;
  typedef Packet_Notice_Stat_CameraStat CameraStat;
  typedef Packet_Notice_Stat_HotPointStat HotPointStat;
  typedef Packet_Notice_Stat_LayoutStat LayoutStat;
  typedef Packet_Notice_Stat_LayoutLoopStat LayoutLoopStat;
  typedef Packet_Notice_Stat_MapGrpStat MapGrpStat;
  typedef Packet_Notice_Stat_ErrorStat ErrorStat;
  typedef Packet_Notice_Stat_KeyboardSelectedStat KeyboardSelectedStat;
  typedef Packet_Notice_Stat_AlarmStat AlarmStat;
  typedef Packet_Notice_Stat_GroupLoopStat GroupLoopStat;

  // accessors -------------------------------------------------------

  // optional .TvWall.Packet.Notice.Stat.ViewStat viewStat = 1;
  inline bool has_viewstat() const;
  inline void clear_viewstat();
  static const int kViewStatFieldNumber = 1;
  inline const ::TvWall::Packet_Notice_Stat_ViewStat& viewstat() const;
  inline ::TvWall::Packet_Notice_Stat_ViewStat* mutable_viewstat();
  inline ::TvWall::Packet_Notice_Stat_ViewStat* release_viewstat();
  inline void set_allocated_viewstat(::TvWall::Packet_Notice_Stat_ViewStat* viewstat);

  // optional .TvWall.Packet.Notice.Stat.CameraStat cameraStat = 2;
  inline bool has_camerastat() const;
  inline void clear_camerastat();
  static const int kCameraStatFieldNumber = 2;
  inline const ::TvWall::Packet_Notice_Stat_CameraStat& camerastat() const;
  inline ::TvWall::Packet_Notice_Stat_CameraStat* mutable_camerastat();
  inline ::TvWall::Packet_Notice_Stat_CameraStat* release_camerastat();
  inline void set_allocated_camerastat(::TvWall::Packet_Notice_Stat_CameraStat* camerastat);

  // optional .TvWall.Packet.Notice.Stat.HotPointStat hotPointStat = 3;
  inline bool has_hotpointstat() const;
  inline void clear_hotpointstat();
  static const int kHotPointStatFieldNumber = 3;
  inline const ::TvWall::Packet_Notice_Stat_HotPointStat& hotpointstat() const;
  inline ::TvWall::Packet_Notice_Stat_HotPointStat* mutable_hotpointstat();
  inline ::TvWall::Packet_Notice_Stat_HotPointStat* release_hotpointstat();
  inline void set_allocated_hotpointstat(::TvWall::Packet_Notice_Stat_HotPointStat* hotpointstat);

  // optional .TvWall.Packet.Notice.Stat.LayoutStat lyoutStat = 4;
  inline bool has_lyoutstat() const;
  inline void clear_lyoutstat();
  static const int kLyoutStatFieldNumber = 4;
  inline const ::TvWall::Packet_Notice_Stat_LayoutStat& lyoutstat() const;
  inline ::TvWall::Packet_Notice_Stat_LayoutStat* mutable_lyoutstat();
  inline ::TvWall::Packet_Notice_Stat_LayoutStat* release_lyoutstat();
  inline void set_allocated_lyoutstat(::TvWall::Packet_Notice_Stat_LayoutStat* lyoutstat);

  // optional .TvWall.Packet.Notice.Stat.ScreenSpliStat screenStat = 5;
  inline bool has_screenstat() const;
  inline void clear_screenstat();
  static const int kScreenStatFieldNumber = 5;
  inline const ::TvWall::Packet_Notice_Stat_ScreenSpliStat& screenstat() const;
  inline ::TvWall::Packet_Notice_Stat_ScreenSpliStat* mutable_screenstat();
  inline ::TvWall::Packet_Notice_Stat_ScreenSpliStat* release_screenstat();
  inline void set_allocated_screenstat(::TvWall::Packet_Notice_Stat_ScreenSpliStat* screenstat);

  // optional .TvWall.Packet.Notice.Stat.MapGrpStat mapGrpStat = 6;
  inline bool has_mapgrpstat() const;
  inline void clear_mapgrpstat();
  static const int kMapGrpStatFieldNumber = 6;
  inline const ::TvWall::Packet_Notice_Stat_MapGrpStat& mapgrpstat() const;
  inline ::TvWall::Packet_Notice_Stat_MapGrpStat* mutable_mapgrpstat();
  inline ::TvWall::Packet_Notice_Stat_MapGrpStat* release_mapgrpstat();
  inline void set_allocated_mapgrpstat(::TvWall::Packet_Notice_Stat_MapGrpStat* mapgrpstat);

  // optional .TvWall.Packet.Notice.Stat.LayoutLoopStat lyoutLoopStat = 7;
  inline bool has_lyoutloopstat() const;
  inline void clear_lyoutloopstat();
  static const int kLyoutLoopStatFieldNumber = 7;
  inline const ::TvWall::Packet_Notice_Stat_LayoutLoopStat& lyoutloopstat() const;
  inline ::TvWall::Packet_Notice_Stat_LayoutLoopStat* mutable_lyoutloopstat();
  inline ::TvWall::Packet_Notice_Stat_LayoutLoopStat* release_lyoutloopstat();
  inline void set_allocated_lyoutloopstat(::TvWall::Packet_Notice_Stat_LayoutLoopStat* lyoutloopstat);

  // optional .TvWall.Packet.Notice.Stat.ErrorStat errStat = 8;
  inline bool has_errstat() const;
  inline void clear_errstat();
  static const int kErrStatFieldNumber = 8;
  inline const ::TvWall::Packet_Notice_Stat_ErrorStat& errstat() const;
  inline ::TvWall::Packet_Notice_Stat_ErrorStat* mutable_errstat();
  inline ::TvWall::Packet_Notice_Stat_ErrorStat* release_errstat();
  inline void set_allocated_errstat(::TvWall::Packet_Notice_Stat_ErrorStat* errstat);

  // optional .TvWall.Packet.Notice.Stat.KeyboardSelectedStat keyboardSelectedStat = 9;
  inline bool has_keyboardselectedstat() const;
  inline void clear_keyboardselectedstat();
  static const int kKeyboardSelectedStatFieldNumber = 9;
  inline const ::TvWall::Packet_Notice_Stat_KeyboardSelectedStat& keyboardselectedstat() const;
  inline ::TvWall::Packet_Notice_Stat_KeyboardSelectedStat* mutable_keyboardselectedstat();
  inline ::TvWall::Packet_Notice_Stat_KeyboardSelectedStat* release_keyboardselectedstat();
  inline void set_allocated_keyboardselectedstat(::TvWall::Packet_Notice_Stat_KeyboardSelectedStat* keyboardselectedstat);

  // optional .TvWall.Packet.Notice.Stat.AlarmStat alarmStat = 10;
  inline bool has_alarmstat() const;
  inline void clear_alarmstat();
  static const int kAlarmStatFieldNumber = 10;
  inline const ::TvWall::Packet_Notice_Stat_AlarmStat& alarmstat() const;
  inline ::TvWall::Packet_Notice_Stat_AlarmStat* mutable_alarmstat();
  inline ::TvWall::Packet_Notice_Stat_AlarmStat* release_alarmstat();
  inline void set_allocated_alarmstat(::TvWall::Packet_Notice_Stat_AlarmStat* alarmstat);

  // optional .TvWall.Packet.Notice.Stat.GroupLoopStat groupLoopStat = 11;
  inline bool has_grouploopstat() const;
  inline void clear_grouploopstat();
  static const int kGroupLoopStatFieldNumber = 11;
  inline const ::TvWall::Packet_Notice_Stat_GroupLoopStat& grouploopstat() const;
  inline ::TvWall::Packet_Notice_Stat_GroupLoopStat* mutable_grouploopstat();
  inline ::TvWall::Packet_Notice_Stat_GroupLoopStat* release_grouploopstat();
  inline void set_allocated_grouploopstat(::TvWall::Packet_Notice_Stat_GroupLoopStat* grouploopstat);

  // @@protoc_insertion_point(class_scope:TvWall.Packet.Notice.Stat)
 private:
  inline void set_has_viewstat();
  inline void clear_has_viewstat();
  inline void set_has_camerastat();
  inline void clear_has_camerastat();
  inline void set_has_hotpointstat();
  inline void clear_has_hotpointstat();
  inline void set_has_lyoutstat();
  inline void clear_has_lyoutstat();
  inline void set_has_screenstat();
  inline void clear_has_screenstat();
  inline void set_has_mapgrpstat();
  inline void clear_has_mapgrpstat();
  inline void set_has_lyoutloopstat();
  inline void clear_has_lyoutloopstat();
  inline void set_has_errstat();
  inline void clear_has_errstat();
  inline void set_has_keyboardselectedstat();
  inline void clear_has_keyboardselectedstat();
  inline void set_has_alarmstat();
  inline void clear_has_alarmstat();
  inline void set_has_grouploopstat();
  inline void clear_has_grouploopstat();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TvWall::Packet_Notice_Stat_ViewStat* viewstat_;
  ::TvWall::Packet_Notice_Stat_CameraStat* camerastat_;
  ::TvWall::Packet_Notice_Stat_HotPointStat* hotpointstat_;
  ::TvWall::Packet_Notice_Stat_LayoutStat* lyoutstat_;
  ::TvWall::Packet_Notice_Stat_ScreenSpliStat* screenstat_;
  ::TvWall::Packet_Notice_Stat_MapGrpStat* mapgrpstat_;
  ::TvWall::Packet_Notice_Stat_LayoutLoopStat* lyoutloopstat_;
  ::TvWall::Packet_Notice_Stat_ErrorStat* errstat_;
  ::TvWall::Packet_Notice_Stat_KeyboardSelectedStat* keyboardselectedstat_;
  ::TvWall::Packet_Notice_Stat_AlarmStat* alarmstat_;
  ::TvWall::Packet_Notice_Stat_GroupLoopStat* grouploopstat_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(11 + 31) / 32];

  friend void  protobuf_AddDesc_protobuf_2ftvWall_2eproto();
  friend void protobuf_AssignDesc_protobuf_2ftvWall_2eproto();
  friend void protobuf_ShutdownFile_protobuf_2ftvWall_2eproto();

  void InitAsDefaultInstance();
  static Packet_Notice_Stat* default_instance_;
};
// -------------------------------------------------------------------

class Packet_Notice_NoticeMaster_NoticeMasterLyout : public ::google::protobuf::Message {
 public:
  Packet_Notice_NoticeMaster_NoticeMasterLyout();
  virtual ~Packet_Notice_NoticeMaster_NoticeMasterLyout();

  Packet_Notice_NoticeMaster_NoticeMasterLyout(const Packet_Notice_NoticeMaster_NoticeMasterLyout& from);

  inline Packet_Notice_NoticeMaster_NoticeMasterLyout& operator=(const Packet_Notice_NoticeMaster_NoticeMasterLyout& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Packet_Notice_NoticeMaster_NoticeMasterLyout& default_instance();

  void Swap(Packet_Notice_NoticeMaster_NoticeMasterLyout* other);

  // implements Message ----------------------------------------------

  Packet_Notice_NoticeMaster_NoticeMasterLyout* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Packet_Notice_NoticeMaster_NoticeMasterLyout& from);
  void MergeFrom(const Packet_Notice_NoticeMaster_NoticeMasterLyout& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TvWall.Packet.ElementMaster.MasterLayout masterLayout = 1;
  inline bool has_masterlayout() const;
  inline void clear_masterlayout();
  static const int kMasterLayoutFieldNumber = 1;
  inline const ::TvWall::Packet_ElementMaster_MasterLayout& masterlayout() const;
  inline ::TvWall::Packet_ElementMaster_MasterLayout* mutable_masterlayout();
  inline ::TvWall::Packet_ElementMaster_MasterLayout* release_masterlayout();
  inline void set_allocated_masterlayout(::TvWall::Packet_ElementMaster_MasterLayout* masterlayout);

  // @@protoc_insertion_point(class_scope:TvWall.Packet.Notice.NoticeMaster.NoticeMasterLyout)
 private:
  inline void set_has_masterlayout();
  inline void clear_has_masterlayout();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TvWall::Packet_ElementMaster_MasterLayout* masterlayout_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_protobuf_2ftvWall_2eproto();
  friend void protobuf_AssignDesc_protobuf_2ftvWall_2eproto();
  friend void protobuf_ShutdownFile_protobuf_2ftvWall_2eproto();

  void InitAsDefaultInstance();
  static Packet_Notice_NoticeMaster_NoticeMasterLyout* default_instance_;
};
// -------------------------------------------------------------------

class Packet_Notice_NoticeMaster : public ::google::protobuf::Message {
 public:
  Packet_Notice_NoticeMaster();
  virtual ~Packet_Notice_NoticeMaster();

  Packet_Notice_NoticeMaster(const Packet_Notice_NoticeMaster& from);

  inline Packet_Notice_NoticeMaster& operator=(const Packet_Notice_NoticeMaster& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Packet_Notice_NoticeMaster& default_instance();

  void Swap(Packet_Notice_NoticeMaster* other);

  // implements Message ----------------------------------------------

  Packet_Notice_NoticeMaster* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Packet_Notice_NoticeMaster& from);
  void MergeFrom(const Packet_Notice_NoticeMaster& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Packet_Notice_NoticeMaster_NoticeMasterLyout NoticeMasterLyout;

  // accessors -------------------------------------------------------

  // required .TvWall.Packet.Notice.NoticeMaster.NoticeMasterLyout nmlyout = 1;
  inline bool has_nmlyout() const;
  inline void clear_nmlyout();
  static const int kNmlyoutFieldNumber = 1;
  inline const ::TvWall::Packet_Notice_NoticeMaster_NoticeMasterLyout& nmlyout() const;
  inline ::TvWall::Packet_Notice_NoticeMaster_NoticeMasterLyout* mutable_nmlyout();
  inline ::TvWall::Packet_Notice_NoticeMaster_NoticeMasterLyout* release_nmlyout();
  inline void set_allocated_nmlyout(::TvWall::Packet_Notice_NoticeMaster_NoticeMasterLyout* nmlyout);

  // @@protoc_insertion_point(class_scope:TvWall.Packet.Notice.NoticeMaster)
 private:
  inline void set_has_nmlyout();
  inline void clear_has_nmlyout();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TvWall::Packet_Notice_NoticeMaster_NoticeMasterLyout* nmlyout_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_protobuf_2ftvWall_2eproto();
  friend void protobuf_AssignDesc_protobuf_2ftvWall_2eproto();
  friend void protobuf_ShutdownFile_protobuf_2ftvWall_2eproto();

  void InitAsDefaultInstance();
  static Packet_Notice_NoticeMaster* default_instance_;
};
// -------------------------------------------------------------------

class Packet_Notice : public ::google::protobuf::Message {
 public:
  Packet_Notice();
  virtual ~Packet_Notice();

  Packet_Notice(const Packet_Notice& from);

  inline Packet_Notice& operator=(const Packet_Notice& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Packet_Notice& default_instance();

  void Swap(Packet_Notice* other);

  // implements Message ----------------------------------------------

  Packet_Notice* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Packet_Notice& from);
  void MergeFrom(const Packet_Notice& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Packet_Notice_Stat Stat;
  typedef Packet_Notice_NoticeMaster NoticeMaster;

  // accessors -------------------------------------------------------

  // repeated .TvWall.Packet.ElementDat.Screen screenInfo = 1;
  inline int screeninfo_size() const;
  inline void clear_screeninfo();
  static const int kScreenInfoFieldNumber = 1;
  inline const ::TvWall::Packet_ElementDat_Screen& screeninfo(int index) const;
  inline ::TvWall::Packet_ElementDat_Screen* mutable_screeninfo(int index);
  inline ::TvWall::Packet_ElementDat_Screen* add_screeninfo();
  inline const ::google::protobuf::RepeatedPtrField< ::TvWall::Packet_ElementDat_Screen >&
      screeninfo() const;
  inline ::google::protobuf::RepeatedPtrField< ::TvWall::Packet_ElementDat_Screen >*
      mutable_screeninfo();

  // optional .TvWall.Packet.Notice.Stat statInfo = 2;
  inline bool has_statinfo() const;
  inline void clear_statinfo();
  static const int kStatInfoFieldNumber = 2;
  inline const ::TvWall::Packet_Notice_Stat& statinfo() const;
  inline ::TvWall::Packet_Notice_Stat* mutable_statinfo();
  inline ::TvWall::Packet_Notice_Stat* release_statinfo();
  inline void set_allocated_statinfo(::TvWall::Packet_Notice_Stat* statinfo);

  // repeated .TvWall.Packet.ElementDat.CameraGrp cameraGrpInfo = 3;
  inline int cameragrpinfo_size() const;
  inline void clear_cameragrpinfo();
  static const int kCameraGrpInfoFieldNumber = 3;
  inline const ::TvWall::Packet_ElementDat_CameraGrp& cameragrpinfo(int index) const;
  inline ::TvWall::Packet_ElementDat_CameraGrp* mutable_cameragrpinfo(int index);
  inline ::TvWall::Packet_ElementDat_CameraGrp* add_cameragrpinfo();
  inline const ::google::protobuf::RepeatedPtrField< ::TvWall::Packet_ElementDat_CameraGrp >&
      cameragrpinfo() const;
  inline ::google::protobuf::RepeatedPtrField< ::TvWall::Packet_ElementDat_CameraGrp >*
      mutable_cameragrpinfo();

  // optional .TvWall.Packet.Notice.NoticeMaster masterStat = 4;
  inline bool has_masterstat() const;
  inline void clear_masterstat();
  static const int kMasterStatFieldNumber = 4;
  inline const ::TvWall::Packet_Notice_NoticeMaster& masterstat() const;
  inline ::TvWall::Packet_Notice_NoticeMaster* mutable_masterstat();
  inline ::TvWall::Packet_Notice_NoticeMaster* release_masterstat();
  inline void set_allocated_masterstat(::TvWall::Packet_Notice_NoticeMaster* masterstat);

  // @@protoc_insertion_point(class_scope:TvWall.Packet.Notice)
 private:
  inline void set_has_statinfo();
  inline void clear_has_statinfo();
  inline void set_has_masterstat();
  inline void clear_has_masterstat();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::TvWall::Packet_ElementDat_Screen > screeninfo_;
  ::TvWall::Packet_Notice_Stat* statinfo_;
  ::google::protobuf::RepeatedPtrField< ::TvWall::Packet_ElementDat_CameraGrp > cameragrpinfo_;
  ::TvWall::Packet_Notice_NoticeMaster* masterstat_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_protobuf_2ftvWall_2eproto();
  friend void protobuf_AssignDesc_protobuf_2ftvWall_2eproto();
  friend void protobuf_ShutdownFile_protobuf_2ftvWall_2eproto();

  void InitAsDefaultInstance();
  static Packet_Notice* default_instance_;
};
// -------------------------------------------------------------------

class Packet : public ::google::protobuf::Message {
 public:
  Packet();
  virtual ~Packet();

  Packet(const Packet& from);

  inline Packet& operator=(const Packet& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Packet& default_instance();

  void Swap(Packet* other);

  // implements Message ----------------------------------------------

  Packet* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Packet& from);
  void MergeFrom(const Packet& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Packet_Session Session;
  typedef Packet_ElementDat ElementDat;
  typedef Packet_ElementMaster ElementMaster;
  typedef Packet_Ctrl Ctrl;
  typedef Packet_RequireSession RequireSession;
  typedef Packet_Notice Notice;

  // accessors -------------------------------------------------------

  // optional .TvWall.Packet.Session session = 2;
  inline bool has_session() const;
  inline void clear_session();
  static const int kSessionFieldNumber = 2;
  inline const ::TvWall::Packet_Session& session() const;
  inline ::TvWall::Packet_Session* mutable_session();
  inline ::TvWall::Packet_Session* release_session();
  inline void set_allocated_session(::TvWall::Packet_Session* session);

  // optional .TvWall.Packet.Ctrl ctrl = 3;
  inline bool has_ctrl() const;
  inline void clear_ctrl();
  static const int kCtrlFieldNumber = 3;
  inline const ::TvWall::Packet_Ctrl& ctrl() const;
  inline ::TvWall::Packet_Ctrl* mutable_ctrl();
  inline ::TvWall::Packet_Ctrl* release_ctrl();
  inline void set_allocated_ctrl(::TvWall::Packet_Ctrl* ctrl);

  // optional .TvWall.Packet.RequireSession requireSession = 4;
  inline bool has_requiresession() const;
  inline void clear_requiresession();
  static const int kRequireSessionFieldNumber = 4;
  inline const ::TvWall::Packet_RequireSession& requiresession() const;
  inline ::TvWall::Packet_RequireSession* mutable_requiresession();
  inline ::TvWall::Packet_RequireSession* release_requiresession();
  inline void set_allocated_requiresession(::TvWall::Packet_RequireSession* requiresession);

  // optional .TvWall.Packet.Notice notice = 5;
  inline bool has_notice() const;
  inline void clear_notice();
  static const int kNoticeFieldNumber = 5;
  inline const ::TvWall::Packet_Notice& notice() const;
  inline ::TvWall::Packet_Notice* mutable_notice();
  inline ::TvWall::Packet_Notice* release_notice();
  inline void set_allocated_notice(::TvWall::Packet_Notice* notice);

  // @@protoc_insertion_point(class_scope:TvWall.Packet)
 private:
  inline void set_has_session();
  inline void clear_has_session();
  inline void set_has_ctrl();
  inline void clear_has_ctrl();
  inline void set_has_requiresession();
  inline void clear_has_requiresession();
  inline void set_has_notice();
  inline void clear_has_notice();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TvWall::Packet_Session* session_;
  ::TvWall::Packet_Ctrl* ctrl_;
  ::TvWall::Packet_RequireSession* requiresession_;
  ::TvWall::Packet_Notice* notice_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_protobuf_2ftvWall_2eproto();
  friend void protobuf_AssignDesc_protobuf_2ftvWall_2eproto();
  friend void protobuf_ShutdownFile_protobuf_2ftvWall_2eproto();

  void InitAsDefaultInstance();
  static Packet* default_instance_;
};
// ===================================================================


// ===================================================================

// Rect

// required int32 x = 1;
inline bool Rect::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Rect::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Rect::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Rect::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline ::google::protobuf::int32 Rect::x() const {
  return x_;
}
inline void Rect::set_x(::google::protobuf::int32 value) {
  set_has_x();
  x_ = value;
}

// required int32 y = 2;
inline bool Rect::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Rect::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Rect::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Rect::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline ::google::protobuf::int32 Rect::y() const {
  return y_;
}
inline void Rect::set_y(::google::protobuf::int32 value) {
  set_has_y();
  y_ = value;
}

// required int32 w = 3;
inline bool Rect::has_w() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Rect::set_has_w() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Rect::clear_has_w() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Rect::clear_w() {
  w_ = 0;
  clear_has_w();
}
inline ::google::protobuf::int32 Rect::w() const {
  return w_;
}
inline void Rect::set_w(::google::protobuf::int32 value) {
  set_has_w();
  w_ = value;
}

// required int32 h = 4;
inline bool Rect::has_h() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Rect::set_has_h() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Rect::clear_has_h() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Rect::clear_h() {
  h_ = 0;
  clear_has_h();
}
inline ::google::protobuf::int32 Rect::h() const {
  return h_;
}
inline void Rect::set_h(::google::protobuf::int32 value) {
  set_has_h();
  h_ = value;
}

// -------------------------------------------------------------------

// Point

// required int32 x = 1;
inline bool Point::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Point::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Point::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Point::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline ::google::protobuf::int32 Point::x() const {
  return x_;
}
inline void Point::set_x(::google::protobuf::int32 value) {
  set_has_x();
  x_ = value;
}

// required int32 y = 2;
inline bool Point::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Point::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Point::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Point::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline ::google::protobuf::int32 Point::y() const {
  return y_;
}
inline void Point::set_y(::google::protobuf::int32 value) {
  set_has_y();
  y_ = value;
}

// -------------------------------------------------------------------

// Guid

// required bytes data = 1;
inline bool Guid::has_data() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Guid::set_has_data() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Guid::clear_has_data() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Guid::clear_data() {
  if (data_ != &::google::protobuf::internal::kEmptyString) {
    data_->clear();
  }
  clear_has_data();
}
inline const ::std::string& Guid::data() const {
  return *data_;
}
inline void Guid::set_data(const ::std::string& value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void Guid::set_data(const char* value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void Guid::set_data(const void* value, size_t size) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Guid::mutable_data() {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  return data_;
}
inline ::std::string* Guid::release_data() {
  clear_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = data_;
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Guid::set_allocated_data(::std::string* data) {
  if (data_ != &::google::protobuf::internal::kEmptyString) {
    delete data_;
  }
  if (data) {
    set_has_data();
    data_ = data;
  } else {
    clear_has_data();
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// NetInterface

// required string ifname = 1;
inline bool NetInterface::has_ifname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NetInterface::set_has_ifname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NetInterface::clear_has_ifname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NetInterface::clear_ifname() {
  if (ifname_ != &::google::protobuf::internal::kEmptyString) {
    ifname_->clear();
  }
  clear_has_ifname();
}
inline const ::std::string& NetInterface::ifname() const {
  return *ifname_;
}
inline void NetInterface::set_ifname(const ::std::string& value) {
  set_has_ifname();
  if (ifname_ == &::google::protobuf::internal::kEmptyString) {
    ifname_ = new ::std::string;
  }
  ifname_->assign(value);
}
inline void NetInterface::set_ifname(const char* value) {
  set_has_ifname();
  if (ifname_ == &::google::protobuf::internal::kEmptyString) {
    ifname_ = new ::std::string;
  }
  ifname_->assign(value);
}
inline void NetInterface::set_ifname(const char* value, size_t size) {
  set_has_ifname();
  if (ifname_ == &::google::protobuf::internal::kEmptyString) {
    ifname_ = new ::std::string;
  }
  ifname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NetInterface::mutable_ifname() {
  set_has_ifname();
  if (ifname_ == &::google::protobuf::internal::kEmptyString) {
    ifname_ = new ::std::string;
  }
  return ifname_;
}
inline ::std::string* NetInterface::release_ifname() {
  clear_has_ifname();
  if (ifname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ifname_;
    ifname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void NetInterface::set_allocated_ifname(::std::string* ifname) {
  if (ifname_ != &::google::protobuf::internal::kEmptyString) {
    delete ifname_;
  }
  if (ifname) {
    set_has_ifname();
    ifname_ = ifname;
  } else {
    clear_has_ifname();
    ifname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string ip = 2;
inline bool NetInterface::has_ip() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NetInterface::set_has_ip() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NetInterface::clear_has_ip() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NetInterface::clear_ip() {
  if (ip_ != &::google::protobuf::internal::kEmptyString) {
    ip_->clear();
  }
  clear_has_ip();
}
inline const ::std::string& NetInterface::ip() const {
  return *ip_;
}
inline void NetInterface::set_ip(const ::std::string& value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
}
inline void NetInterface::set_ip(const char* value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
}
inline void NetInterface::set_ip(const char* value, size_t size) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NetInterface::mutable_ip() {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  return ip_;
}
inline ::std::string* NetInterface::release_ip() {
  clear_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ip_;
    ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void NetInterface::set_allocated_ip(::std::string* ip) {
  if (ip_ != &::google::protobuf::internal::kEmptyString) {
    delete ip_;
  }
  if (ip) {
    set_has_ip();
    ip_ = ip;
  } else {
    clear_has_ip();
    ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string netmask = 3;
inline bool NetInterface::has_netmask() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void NetInterface::set_has_netmask() {
  _has_bits_[0] |= 0x00000004u;
}
inline void NetInterface::clear_has_netmask() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void NetInterface::clear_netmask() {
  if (netmask_ != &::google::protobuf::internal::kEmptyString) {
    netmask_->clear();
  }
  clear_has_netmask();
}
inline const ::std::string& NetInterface::netmask() const {
  return *netmask_;
}
inline void NetInterface::set_netmask(const ::std::string& value) {
  set_has_netmask();
  if (netmask_ == &::google::protobuf::internal::kEmptyString) {
    netmask_ = new ::std::string;
  }
  netmask_->assign(value);
}
inline void NetInterface::set_netmask(const char* value) {
  set_has_netmask();
  if (netmask_ == &::google::protobuf::internal::kEmptyString) {
    netmask_ = new ::std::string;
  }
  netmask_->assign(value);
}
inline void NetInterface::set_netmask(const char* value, size_t size) {
  set_has_netmask();
  if (netmask_ == &::google::protobuf::internal::kEmptyString) {
    netmask_ = new ::std::string;
  }
  netmask_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NetInterface::mutable_netmask() {
  set_has_netmask();
  if (netmask_ == &::google::protobuf::internal::kEmptyString) {
    netmask_ = new ::std::string;
  }
  return netmask_;
}
inline ::std::string* NetInterface::release_netmask() {
  clear_has_netmask();
  if (netmask_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = netmask_;
    netmask_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void NetInterface::set_allocated_netmask(::std::string* netmask) {
  if (netmask_ != &::google::protobuf::internal::kEmptyString) {
    delete netmask_;
  }
  if (netmask) {
    set_has_netmask();
    netmask_ = netmask;
  } else {
    clear_has_netmask();
    netmask_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool enabled = 4;
inline bool NetInterface::has_enabled() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void NetInterface::set_has_enabled() {
  _has_bits_[0] |= 0x00000008u;
}
inline void NetInterface::clear_has_enabled() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void NetInterface::clear_enabled() {
  enabled_ = false;
  clear_has_enabled();
}
inline bool NetInterface::enabled() const {
  return enabled_;
}
inline void NetInterface::set_enabled(bool value) {
  set_has_enabled();
  enabled_ = value;
}

// optional bool plug = 5;
inline bool NetInterface::has_plug() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void NetInterface::set_has_plug() {
  _has_bits_[0] |= 0x00000010u;
}
inline void NetInterface::clear_has_plug() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void NetInterface::clear_plug() {
  plug_ = false;
  clear_has_plug();
}
inline bool NetInterface::plug() const {
  return plug_;
}
inline void NetInterface::set_plug(bool value) {
  set_has_plug();
  plug_ = value;
}

// optional int32 speed = 6 [default = 1000];
inline bool NetInterface::has_speed() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void NetInterface::set_has_speed() {
  _has_bits_[0] |= 0x00000020u;
}
inline void NetInterface::clear_has_speed() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void NetInterface::clear_speed() {
  speed_ = 1000;
  clear_has_speed();
}
inline ::google::protobuf::int32 NetInterface::speed() const {
  return speed_;
}
inline void NetInterface::set_speed(::google::protobuf::int32 value) {
  set_has_speed();
  speed_ = value;
}

// optional bool dhcp = 7 [default = false];
inline bool NetInterface::has_dhcp() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void NetInterface::set_has_dhcp() {
  _has_bits_[0] |= 0x00000040u;
}
inline void NetInterface::clear_has_dhcp() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void NetInterface::clear_dhcp() {
  dhcp_ = false;
  clear_has_dhcp();
}
inline bool NetInterface::dhcp() const {
  return dhcp_;
}
inline void NetInterface::set_dhcp(bool value) {
  set_has_dhcp();
  dhcp_ = value;
}

// -------------------------------------------------------------------

// Network

// required string hostName = 1;
inline bool Network::has_hostname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Network::set_has_hostname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Network::clear_has_hostname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Network::clear_hostname() {
  if (hostname_ != &::google::protobuf::internal::kEmptyString) {
    hostname_->clear();
  }
  clear_has_hostname();
}
inline const ::std::string& Network::hostname() const {
  return *hostname_;
}
inline void Network::set_hostname(const ::std::string& value) {
  set_has_hostname();
  if (hostname_ == &::google::protobuf::internal::kEmptyString) {
    hostname_ = new ::std::string;
  }
  hostname_->assign(value);
}
inline void Network::set_hostname(const char* value) {
  set_has_hostname();
  if (hostname_ == &::google::protobuf::internal::kEmptyString) {
    hostname_ = new ::std::string;
  }
  hostname_->assign(value);
}
inline void Network::set_hostname(const char* value, size_t size) {
  set_has_hostname();
  if (hostname_ == &::google::protobuf::internal::kEmptyString) {
    hostname_ = new ::std::string;
  }
  hostname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Network::mutable_hostname() {
  set_has_hostname();
  if (hostname_ == &::google::protobuf::internal::kEmptyString) {
    hostname_ = new ::std::string;
  }
  return hostname_;
}
inline ::std::string* Network::release_hostname() {
  clear_has_hostname();
  if (hostname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = hostname_;
    hostname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Network::set_allocated_hostname(::std::string* hostname) {
  if (hostname_ != &::google::protobuf::internal::kEmptyString) {
    delete hostname_;
  }
  if (hostname) {
    set_has_hostname();
    hostname_ = hostname;
  } else {
    clear_has_hostname();
    hostname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string gateway = 2;
inline bool Network::has_gateway() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Network::set_has_gateway() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Network::clear_has_gateway() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Network::clear_gateway() {
  if (gateway_ != &::google::protobuf::internal::kEmptyString) {
    gateway_->clear();
  }
  clear_has_gateway();
}
inline const ::std::string& Network::gateway() const {
  return *gateway_;
}
inline void Network::set_gateway(const ::std::string& value) {
  set_has_gateway();
  if (gateway_ == &::google::protobuf::internal::kEmptyString) {
    gateway_ = new ::std::string;
  }
  gateway_->assign(value);
}
inline void Network::set_gateway(const char* value) {
  set_has_gateway();
  if (gateway_ == &::google::protobuf::internal::kEmptyString) {
    gateway_ = new ::std::string;
  }
  gateway_->assign(value);
}
inline void Network::set_gateway(const char* value, size_t size) {
  set_has_gateway();
  if (gateway_ == &::google::protobuf::internal::kEmptyString) {
    gateway_ = new ::std::string;
  }
  gateway_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Network::mutable_gateway() {
  set_has_gateway();
  if (gateway_ == &::google::protobuf::internal::kEmptyString) {
    gateway_ = new ::std::string;
  }
  return gateway_;
}
inline ::std::string* Network::release_gateway() {
  clear_has_gateway();
  if (gateway_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = gateway_;
    gateway_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Network::set_allocated_gateway(::std::string* gateway) {
  if (gateway_ != &::google::protobuf::internal::kEmptyString) {
    delete gateway_;
  }
  if (gateway) {
    set_has_gateway();
    gateway_ = gateway;
  } else {
    clear_has_gateway();
    gateway_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string gateway6 = 3;
inline bool Network::has_gateway6() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Network::set_has_gateway6() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Network::clear_has_gateway6() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Network::clear_gateway6() {
  if (gateway6_ != &::google::protobuf::internal::kEmptyString) {
    gateway6_->clear();
  }
  clear_has_gateway6();
}
inline const ::std::string& Network::gateway6() const {
  return *gateway6_;
}
inline void Network::set_gateway6(const ::std::string& value) {
  set_has_gateway6();
  if (gateway6_ == &::google::protobuf::internal::kEmptyString) {
    gateway6_ = new ::std::string;
  }
  gateway6_->assign(value);
}
inline void Network::set_gateway6(const char* value) {
  set_has_gateway6();
  if (gateway6_ == &::google::protobuf::internal::kEmptyString) {
    gateway6_ = new ::std::string;
  }
  gateway6_->assign(value);
}
inline void Network::set_gateway6(const char* value, size_t size) {
  set_has_gateway6();
  if (gateway6_ == &::google::protobuf::internal::kEmptyString) {
    gateway6_ = new ::std::string;
  }
  gateway6_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Network::mutable_gateway6() {
  set_has_gateway6();
  if (gateway6_ == &::google::protobuf::internal::kEmptyString) {
    gateway6_ = new ::std::string;
  }
  return gateway6_;
}
inline ::std::string* Network::release_gateway6() {
  clear_has_gateway6();
  if (gateway6_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = gateway6_;
    gateway6_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Network::set_allocated_gateway6(::std::string* gateway6) {
  if (gateway6_ != &::google::protobuf::internal::kEmptyString) {
    delete gateway6_;
  }
  if (gateway6) {
    set_has_gateway6();
    gateway6_ = gateway6;
  } else {
    clear_has_gateway6();
    gateway6_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string gwdev = 4;
inline bool Network::has_gwdev() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Network::set_has_gwdev() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Network::clear_has_gwdev() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Network::clear_gwdev() {
  if (gwdev_ != &::google::protobuf::internal::kEmptyString) {
    gwdev_->clear();
  }
  clear_has_gwdev();
}
inline const ::std::string& Network::gwdev() const {
  return *gwdev_;
}
inline void Network::set_gwdev(const ::std::string& value) {
  set_has_gwdev();
  if (gwdev_ == &::google::protobuf::internal::kEmptyString) {
    gwdev_ = new ::std::string;
  }
  gwdev_->assign(value);
}
inline void Network::set_gwdev(const char* value) {
  set_has_gwdev();
  if (gwdev_ == &::google::protobuf::internal::kEmptyString) {
    gwdev_ = new ::std::string;
  }
  gwdev_->assign(value);
}
inline void Network::set_gwdev(const char* value, size_t size) {
  set_has_gwdev();
  if (gwdev_ == &::google::protobuf::internal::kEmptyString) {
    gwdev_ = new ::std::string;
  }
  gwdev_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Network::mutable_gwdev() {
  set_has_gwdev();
  if (gwdev_ == &::google::protobuf::internal::kEmptyString) {
    gwdev_ = new ::std::string;
  }
  return gwdev_;
}
inline ::std::string* Network::release_gwdev() {
  clear_has_gwdev();
  if (gwdev_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = gwdev_;
    gwdev_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Network::set_allocated_gwdev(::std::string* gwdev) {
  if (gwdev_ != &::google::protobuf::internal::kEmptyString) {
    delete gwdev_;
  }
  if (gwdev) {
    set_has_gwdev();
    gwdev_ = gwdev;
  } else {
    clear_has_gwdev();
    gwdev_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string nat = 5;
inline bool Network::has_nat() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Network::set_has_nat() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Network::clear_has_nat() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Network::clear_nat() {
  if (nat_ != &::google::protobuf::internal::kEmptyString) {
    nat_->clear();
  }
  clear_has_nat();
}
inline const ::std::string& Network::nat() const {
  return *nat_;
}
inline void Network::set_nat(const ::std::string& value) {
  set_has_nat();
  if (nat_ == &::google::protobuf::internal::kEmptyString) {
    nat_ = new ::std::string;
  }
  nat_->assign(value);
}
inline void Network::set_nat(const char* value) {
  set_has_nat();
  if (nat_ == &::google::protobuf::internal::kEmptyString) {
    nat_ = new ::std::string;
  }
  nat_->assign(value);
}
inline void Network::set_nat(const char* value, size_t size) {
  set_has_nat();
  if (nat_ == &::google::protobuf::internal::kEmptyString) {
    nat_ = new ::std::string;
  }
  nat_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Network::mutable_nat() {
  set_has_nat();
  if (nat_ == &::google::protobuf::internal::kEmptyString) {
    nat_ = new ::std::string;
  }
  return nat_;
}
inline ::std::string* Network::release_nat() {
  clear_has_nat();
  if (nat_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = nat_;
    nat_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Network::set_allocated_nat(::std::string* nat) {
  if (nat_ != &::google::protobuf::internal::kEmptyString) {
    delete nat_;
  }
  if (nat) {
    set_has_nat();
    nat_ = nat;
  } else {
    clear_has_nat();
    nat_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string dns = 6;
inline bool Network::has_dns() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Network::set_has_dns() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Network::clear_has_dns() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Network::clear_dns() {
  if (dns_ != &::google::protobuf::internal::kEmptyString) {
    dns_->clear();
  }
  clear_has_dns();
}
inline const ::std::string& Network::dns() const {
  return *dns_;
}
inline void Network::set_dns(const ::std::string& value) {
  set_has_dns();
  if (dns_ == &::google::protobuf::internal::kEmptyString) {
    dns_ = new ::std::string;
  }
  dns_->assign(value);
}
inline void Network::set_dns(const char* value) {
  set_has_dns();
  if (dns_ == &::google::protobuf::internal::kEmptyString) {
    dns_ = new ::std::string;
  }
  dns_->assign(value);
}
inline void Network::set_dns(const char* value, size_t size) {
  set_has_dns();
  if (dns_ == &::google::protobuf::internal::kEmptyString) {
    dns_ = new ::std::string;
  }
  dns_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Network::mutable_dns() {
  set_has_dns();
  if (dns_ == &::google::protobuf::internal::kEmptyString) {
    dns_ = new ::std::string;
  }
  return dns_;
}
inline ::std::string* Network::release_dns() {
  clear_has_dns();
  if (dns_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = dns_;
    dns_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Network::set_allocated_dns(::std::string* dns) {
  if (dns_ != &::google::protobuf::internal::kEmptyString) {
    delete dns_;
  }
  if (dns) {
    set_has_dns();
    dns_ = dns;
  } else {
    clear_has_dns();
    dns_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .TvWall.NetInterface interfaces = 7;
inline int Network::interfaces_size() const {
  return interfaces_.size();
}
inline void Network::clear_interfaces() {
  interfaces_.Clear();
}
inline const ::TvWall::NetInterface& Network::interfaces(int index) const {
  return interfaces_.Get(index);
}
inline ::TvWall::NetInterface* Network::mutable_interfaces(int index) {
  return interfaces_.Mutable(index);
}
inline ::TvWall::NetInterface* Network::add_interfaces() {
  return interfaces_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TvWall::NetInterface >&
Network::interfaces() const {
  return interfaces_;
}
inline ::google::protobuf::RepeatedPtrField< ::TvWall::NetInterface >*
Network::mutable_interfaces() {
  return &interfaces_;
}

// -------------------------------------------------------------------

// NVR

// required string ip = 1;
inline bool NVR::has_ip() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NVR::set_has_ip() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NVR::clear_has_ip() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NVR::clear_ip() {
  if (ip_ != &::google::protobuf::internal::kEmptyString) {
    ip_->clear();
  }
  clear_has_ip();
}
inline const ::std::string& NVR::ip() const {
  return *ip_;
}
inline void NVR::set_ip(const ::std::string& value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
}
inline void NVR::set_ip(const char* value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
}
inline void NVR::set_ip(const char* value, size_t size) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NVR::mutable_ip() {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  return ip_;
}
inline ::std::string* NVR::release_ip() {
  clear_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ip_;
    ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void NVR::set_allocated_ip(::std::string* ip) {
  if (ip_ != &::google::protobuf::internal::kEmptyString) {
    delete ip_;
  }
  if (ip) {
    set_has_ip();
    ip_ = ip;
  } else {
    clear_has_ip();
    ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string userName = 2;
inline bool NVR::has_username() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NVR::set_has_username() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NVR::clear_has_username() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NVR::clear_username() {
  if (username_ != &::google::protobuf::internal::kEmptyString) {
    username_->clear();
  }
  clear_has_username();
}
inline const ::std::string& NVR::username() const {
  return *username_;
}
inline void NVR::set_username(const ::std::string& value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void NVR::set_username(const char* value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void NVR::set_username(const char* value, size_t size) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NVR::mutable_username() {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  return username_;
}
inline ::std::string* NVR::release_username() {
  clear_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = username_;
    username_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void NVR::set_allocated_username(::std::string* username) {
  if (username_ != &::google::protobuf::internal::kEmptyString) {
    delete username_;
  }
  if (username) {
    set_has_username();
    username_ = username;
  } else {
    clear_has_username();
    username_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string password = 3;
inline bool NVR::has_password() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void NVR::set_has_password() {
  _has_bits_[0] |= 0x00000004u;
}
inline void NVR::clear_has_password() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void NVR::clear_password() {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    password_->clear();
  }
  clear_has_password();
}
inline const ::std::string& NVR::password() const {
  return *password_;
}
inline void NVR::set_password(const ::std::string& value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void NVR::set_password(const char* value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void NVR::set_password(const char* value, size_t size) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NVR::mutable_password() {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  return password_;
}
inline ::std::string* NVR::release_password() {
  clear_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = password_;
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void NVR::set_allocated_password(::std::string* password) {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    delete password_;
  }
  if (password) {
    set_has_password();
    password_ = password;
  } else {
    clear_has_password();
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool connected = 4;
inline bool NVR::has_connected() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void NVR::set_has_connected() {
  _has_bits_[0] |= 0x00000008u;
}
inline void NVR::clear_has_connected() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void NVR::clear_connected() {
  connected_ = false;
  clear_has_connected();
}
inline bool NVR::connected() const {
  return connected_;
}
inline void NVR::set_connected(bool value) {
  set_has_connected();
  connected_ = value;
}

// -------------------------------------------------------------------

// FMP

// required string ip = 1;
inline bool FMP::has_ip() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FMP::set_has_ip() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FMP::clear_has_ip() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FMP::clear_ip() {
  if (ip_ != &::google::protobuf::internal::kEmptyString) {
    ip_->clear();
  }
  clear_has_ip();
}
inline const ::std::string& FMP::ip() const {
  return *ip_;
}
inline void FMP::set_ip(const ::std::string& value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
}
inline void FMP::set_ip(const char* value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
}
inline void FMP::set_ip(const char* value, size_t size) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FMP::mutable_ip() {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  return ip_;
}
inline ::std::string* FMP::release_ip() {
  clear_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ip_;
    ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void FMP::set_allocated_ip(::std::string* ip) {
  if (ip_ != &::google::protobuf::internal::kEmptyString) {
    delete ip_;
  }
  if (ip) {
    set_has_ip();
    ip_ = ip;
  } else {
    clear_has_ip();
    ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string userName = 2;
inline bool FMP::has_username() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FMP::set_has_username() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FMP::clear_has_username() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FMP::clear_username() {
  if (username_ != &::google::protobuf::internal::kEmptyString) {
    username_->clear();
  }
  clear_has_username();
}
inline const ::std::string& FMP::username() const {
  return *username_;
}
inline void FMP::set_username(const ::std::string& value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void FMP::set_username(const char* value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void FMP::set_username(const char* value, size_t size) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FMP::mutable_username() {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  return username_;
}
inline ::std::string* FMP::release_username() {
  clear_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = username_;
    username_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void FMP::set_allocated_username(::std::string* username) {
  if (username_ != &::google::protobuf::internal::kEmptyString) {
    delete username_;
  }
  if (username) {
    set_has_username();
    username_ = username;
  } else {
    clear_has_username();
    username_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string password = 3;
inline bool FMP::has_password() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FMP::set_has_password() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FMP::clear_has_password() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FMP::clear_password() {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    password_->clear();
  }
  clear_has_password();
}
inline const ::std::string& FMP::password() const {
  return *password_;
}
inline void FMP::set_password(const ::std::string& value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void FMP::set_password(const char* value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void FMP::set_password(const char* value, size_t size) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FMP::mutable_password() {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  return password_;
}
inline ::std::string* FMP::release_password() {
  clear_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = password_;
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void FMP::set_allocated_password(::std::string* password) {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    delete password_;
  }
  if (password) {
    set_has_password();
    password_ = password;
  } else {
    clear_has_password();
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// Packet_Session_Login

// required string version = 1 [default = "v1.0.0"];
inline bool Packet_Session_Login::has_version() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Packet_Session_Login::set_has_version() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Packet_Session_Login::clear_has_version() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Packet_Session_Login::clear_version() {
  if (version_ != _default_version_) {
    version_->assign(*_default_version_);
  }
  clear_has_version();
}
inline const ::std::string& Packet_Session_Login::version() const {
  return *version_;
}
inline void Packet_Session_Login::set_version(const ::std::string& value) {
  set_has_version();
  if (version_ == _default_version_) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void Packet_Session_Login::set_version(const char* value) {
  set_has_version();
  if (version_ == _default_version_) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void Packet_Session_Login::set_version(const char* value, size_t size) {
  set_has_version();
  if (version_ == _default_version_) {
    version_ = new ::std::string;
  }
  version_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Packet_Session_Login::mutable_version() {
  set_has_version();
  if (version_ == _default_version_) {
    version_ = new ::std::string(*_default_version_);
  }
  return version_;
}
inline ::std::string* Packet_Session_Login::release_version() {
  clear_has_version();
  if (version_ == _default_version_) {
    return NULL;
  } else {
    ::std::string* temp = version_;
    version_ = const_cast< ::std::string*>(_default_version_);
    return temp;
  }
}
inline void Packet_Session_Login::set_allocated_version(::std::string* version) {
  if (version_ != _default_version_) {
    delete version_;
  }
  if (version) {
    set_has_version();
    version_ = version;
  } else {
    clear_has_version();
    version_ = const_cast< ::std::string*>(_default_version_);
  }
}

// optional string userName = 2;
inline bool Packet_Session_Login::has_username() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Packet_Session_Login::set_has_username() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Packet_Session_Login::clear_has_username() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Packet_Session_Login::clear_username() {
  if (username_ != &::google::protobuf::internal::kEmptyString) {
    username_->clear();
  }
  clear_has_username();
}
inline const ::std::string& Packet_Session_Login::username() const {
  return *username_;
}
inline void Packet_Session_Login::set_username(const ::std::string& value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void Packet_Session_Login::set_username(const char* value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void Packet_Session_Login::set_username(const char* value, size_t size) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Packet_Session_Login::mutable_username() {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  return username_;
}
inline ::std::string* Packet_Session_Login::release_username() {
  clear_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = username_;
    username_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Packet_Session_Login::set_allocated_username(::std::string* username) {
  if (username_ != &::google::protobuf::internal::kEmptyString) {
    delete username_;
  }
  if (username) {
    set_has_username();
    username_ = username;
  } else {
    clear_has_username();
    username_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string passwd = 3;
inline bool Packet_Session_Login::has_passwd() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Packet_Session_Login::set_has_passwd() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Packet_Session_Login::clear_has_passwd() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Packet_Session_Login::clear_passwd() {
  if (passwd_ != &::google::protobuf::internal::kEmptyString) {
    passwd_->clear();
  }
  clear_has_passwd();
}
inline const ::std::string& Packet_Session_Login::passwd() const {
  return *passwd_;
}
inline void Packet_Session_Login::set_passwd(const ::std::string& value) {
  set_has_passwd();
  if (passwd_ == &::google::protobuf::internal::kEmptyString) {
    passwd_ = new ::std::string;
  }
  passwd_->assign(value);
}
inline void Packet_Session_Login::set_passwd(const char* value) {
  set_has_passwd();
  if (passwd_ == &::google::protobuf::internal::kEmptyString) {
    passwd_ = new ::std::string;
  }
  passwd_->assign(value);
}
inline void Packet_Session_Login::set_passwd(const char* value, size_t size) {
  set_has_passwd();
  if (passwd_ == &::google::protobuf::internal::kEmptyString) {
    passwd_ = new ::std::string;
  }
  passwd_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Packet_Session_Login::mutable_passwd() {
  set_has_passwd();
  if (passwd_ == &::google::protobuf::internal::kEmptyString) {
    passwd_ = new ::std::string;
  }
  return passwd_;
}
inline ::std::string* Packet_Session_Login::release_passwd() {
  clear_has_passwd();
  if (passwd_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = passwd_;
    passwd_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Packet_Session_Login::set_allocated_passwd(::std::string* passwd) {
  if (passwd_ != &::google::protobuf::internal::kEmptyString) {
    delete passwd_;
  }
  if (passwd) {
    set_has_passwd();
    passwd_ = passwd;
  } else {
    clear_has_passwd();
    passwd_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string encryption = 4 [default = "md5"];
inline bool Packet_Session_Login::has_encryption() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Packet_Session_Login::set_has_encryption() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Packet_Session_Login::clear_has_encryption() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Packet_Session_Login::clear_encryption() {
  if (encryption_ != _default_encryption_) {
    encryption_->assign(*_default_encryption_);
  }
  clear_has_encryption();
}
inline const ::std::string& Packet_Session_Login::encryption() const {
  return *encryption_;
}
inline void Packet_Session_Login::set_encryption(const ::std::string& value) {
  set_has_encryption();
  if (encryption_ == _default_encryption_) {
    encryption_ = new ::std::string;
  }
  encryption_->assign(value);
}
inline void Packet_Session_Login::set_encryption(const char* value) {
  set_has_encryption();
  if (encryption_ == _default_encryption_) {
    encryption_ = new ::std::string;
  }
  encryption_->assign(value);
}
inline void Packet_Session_Login::set_encryption(const char* value, size_t size) {
  set_has_encryption();
  if (encryption_ == _default_encryption_) {
    encryption_ = new ::std::string;
  }
  encryption_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Packet_Session_Login::mutable_encryption() {
  set_has_encryption();
  if (encryption_ == _default_encryption_) {
    encryption_ = new ::std::string(*_default_encryption_);
  }
  return encryption_;
}
inline ::std::string* Packet_Session_Login::release_encryption() {
  clear_has_encryption();
  if (encryption_ == _default_encryption_) {
    return NULL;
  } else {
    ::std::string* temp = encryption_;
    encryption_ = const_cast< ::std::string*>(_default_encryption_);
    return temp;
  }
}
inline void Packet_Session_Login::set_allocated_encryption(::std::string* encryption) {
  if (encryption_ != _default_encryption_) {
    delete encryption_;
  }
  if (encryption) {
    set_has_encryption();
    encryption_ = encryption;
  } else {
    clear_has_encryption();
    encryption_ = const_cast< ::std::string*>(_default_encryption_);
  }
}

// optional int32 token = 5;
inline bool Packet_Session_Login::has_token() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Packet_Session_Login::set_has_token() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Packet_Session_Login::clear_has_token() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Packet_Session_Login::clear_token() {
  token_ = 0;
  clear_has_token();
}
inline ::google::protobuf::int32 Packet_Session_Login::token() const {
  return token_;
}
inline void Packet_Session_Login::set_token(::google::protobuf::int32 value) {
  set_has_token();
  token_ = value;
}

// optional bool isMaster = 6;
inline bool Packet_Session_Login::has_ismaster() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Packet_Session_Login::set_has_ismaster() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Packet_Session_Login::clear_has_ismaster() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Packet_Session_Login::clear_ismaster() {
  ismaster_ = false;
  clear_has_ismaster();
}
inline bool Packet_Session_Login::ismaster() const {
  return ismaster_;
}
inline void Packet_Session_Login::set_ismaster(bool value) {
  set_has_ismaster();
  ismaster_ = value;
}

// -------------------------------------------------------------------

// Packet_Session_LoginAck

// required string version = 1 [default = "v1.0.0"];
inline bool Packet_Session_LoginAck::has_version() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Packet_Session_LoginAck::set_has_version() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Packet_Session_LoginAck::clear_has_version() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Packet_Session_LoginAck::clear_version() {
  if (version_ != _default_version_) {
    version_->assign(*_default_version_);
  }
  clear_has_version();
}
inline const ::std::string& Packet_Session_LoginAck::version() const {
  return *version_;
}
inline void Packet_Session_LoginAck::set_version(const ::std::string& value) {
  set_has_version();
  if (version_ == _default_version_) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void Packet_Session_LoginAck::set_version(const char* value) {
  set_has_version();
  if (version_ == _default_version_) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void Packet_Session_LoginAck::set_version(const char* value, size_t size) {
  set_has_version();
  if (version_ == _default_version_) {
    version_ = new ::std::string;
  }
  version_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Packet_Session_LoginAck::mutable_version() {
  set_has_version();
  if (version_ == _default_version_) {
    version_ = new ::std::string(*_default_version_);
  }
  return version_;
}
inline ::std::string* Packet_Session_LoginAck::release_version() {
  clear_has_version();
  if (version_ == _default_version_) {
    return NULL;
  } else {
    ::std::string* temp = version_;
    version_ = const_cast< ::std::string*>(_default_version_);
    return temp;
  }
}
inline void Packet_Session_LoginAck::set_allocated_version(::std::string* version) {
  if (version_ != _default_version_) {
    delete version_;
  }
  if (version) {
    set_has_version();
    version_ = version;
  } else {
    clear_has_version();
    version_ = const_cast< ::std::string*>(_default_version_);
  }
}

// required int32 result = 2;
inline bool Packet_Session_LoginAck::has_result() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Packet_Session_LoginAck::set_has_result() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Packet_Session_LoginAck::clear_has_result() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Packet_Session_LoginAck::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 Packet_Session_LoginAck::result() const {
  return result_;
}
inline void Packet_Session_LoginAck::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// optional int32 sessionId = 3;
inline bool Packet_Session_LoginAck::has_sessionid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Packet_Session_LoginAck::set_has_sessionid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Packet_Session_LoginAck::clear_has_sessionid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Packet_Session_LoginAck::clear_sessionid() {
  sessionid_ = 0;
  clear_has_sessionid();
}
inline ::google::protobuf::int32 Packet_Session_LoginAck::sessionid() const {
  return sessionid_;
}
inline void Packet_Session_LoginAck::set_sessionid(::google::protobuf::int32 value) {
  set_has_sessionid();
  sessionid_ = value;
}

// -------------------------------------------------------------------

// Packet_Session_LoginMasterAck_Server

// required string peer = 1;
inline bool Packet_Session_LoginMasterAck_Server::has_peer() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Packet_Session_LoginMasterAck_Server::set_has_peer() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Packet_Session_LoginMasterAck_Server::clear_has_peer() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Packet_Session_LoginMasterAck_Server::clear_peer() {
  if (peer_ != &::google::protobuf::internal::kEmptyString) {
    peer_->clear();
  }
  clear_has_peer();
}
inline const ::std::string& Packet_Session_LoginMasterAck_Server::peer() const {
  return *peer_;
}
inline void Packet_Session_LoginMasterAck_Server::set_peer(const ::std::string& value) {
  set_has_peer();
  if (peer_ == &::google::protobuf::internal::kEmptyString) {
    peer_ = new ::std::string;
  }
  peer_->assign(value);
}
inline void Packet_Session_LoginMasterAck_Server::set_peer(const char* value) {
  set_has_peer();
  if (peer_ == &::google::protobuf::internal::kEmptyString) {
    peer_ = new ::std::string;
  }
  peer_->assign(value);
}
inline void Packet_Session_LoginMasterAck_Server::set_peer(const char* value, size_t size) {
  set_has_peer();
  if (peer_ == &::google::protobuf::internal::kEmptyString) {
    peer_ = new ::std::string;
  }
  peer_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Packet_Session_LoginMasterAck_Server::mutable_peer() {
  set_has_peer();
  if (peer_ == &::google::protobuf::internal::kEmptyString) {
    peer_ = new ::std::string;
  }
  return peer_;
}
inline ::std::string* Packet_Session_LoginMasterAck_Server::release_peer() {
  clear_has_peer();
  if (peer_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = peer_;
    peer_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Packet_Session_LoginMasterAck_Server::set_allocated_peer(::std::string* peer) {
  if (peer_ != &::google::protobuf::internal::kEmptyString) {
    delete peer_;
  }
  if (peer) {
    set_has_peer();
    peer_ = peer;
  } else {
    clear_has_peer();
    peer_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .TvWall.Packet.Session.Login login = 3;
inline bool Packet_Session_LoginMasterAck_Server::has_login() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Packet_Session_LoginMasterAck_Server::set_has_login() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Packet_Session_LoginMasterAck_Server::clear_has_login() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Packet_Session_LoginMasterAck_Server::clear_login() {
  if (login_ != NULL) login_->::TvWall::Packet_Session_Login::Clear();
  clear_has_login();
}
inline const ::TvWall::Packet_Session_Login& Packet_Session_LoginMasterAck_Server::login() const {
  return login_ != NULL ? *login_ : *default_instance_->login_;
}
inline ::TvWall::Packet_Session_Login* Packet_Session_LoginMasterAck_Server::mutable_login() {
  set_has_login();
  if (login_ == NULL) login_ = new ::TvWall::Packet_Session_Login;
  return login_;
}
inline ::TvWall::Packet_Session_Login* Packet_Session_LoginMasterAck_Server::release_login() {
  clear_has_login();
  ::TvWall::Packet_Session_Login* temp = login_;
  login_ = NULL;
  return temp;
}
inline void Packet_Session_LoginMasterAck_Server::set_allocated_login(::TvWall::Packet_Session_Login* login) {
  delete login_;
  login_ = login;
  if (login) {
    set_has_login();
  } else {
    clear_has_login();
  }
}

// optional string serverName = 4;
inline bool Packet_Session_LoginMasterAck_Server::has_servername() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Packet_Session_LoginMasterAck_Server::set_has_servername() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Packet_Session_LoginMasterAck_Server::clear_has_servername() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Packet_Session_LoginMasterAck_Server::clear_servername() {
  if (servername_ != &::google::protobuf::internal::kEmptyString) {
    servername_->clear();
  }
  clear_has_servername();
}
inline const ::std::string& Packet_Session_LoginMasterAck_Server::servername() const {
  return *servername_;
}
inline void Packet_Session_LoginMasterAck_Server::set_servername(const ::std::string& value) {
  set_has_servername();
  if (servername_ == &::google::protobuf::internal::kEmptyString) {
    servername_ = new ::std::string;
  }
  servername_->assign(value);
}
inline void Packet_Session_LoginMasterAck_Server::set_servername(const char* value) {
  set_has_servername();
  if (servername_ == &::google::protobuf::internal::kEmptyString) {
    servername_ = new ::std::string;
  }
  servername_->assign(value);
}
inline void Packet_Session_LoginMasterAck_Server::set_servername(const char* value, size_t size) {
  set_has_servername();
  if (servername_ == &::google::protobuf::internal::kEmptyString) {
    servername_ = new ::std::string;
  }
  servername_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Packet_Session_LoginMasterAck_Server::mutable_servername() {
  set_has_servername();
  if (servername_ == &::google::protobuf::internal::kEmptyString) {
    servername_ = new ::std::string;
  }
  return servername_;
}
inline ::std::string* Packet_Session_LoginMasterAck_Server::release_servername() {
  clear_has_servername();
  if (servername_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = servername_;
    servername_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Packet_Session_LoginMasterAck_Server::set_allocated_servername(::std::string* servername) {
  if (servername_ != &::google::protobuf::internal::kEmptyString) {
    delete servername_;
  }
  if (servername) {
    set_has_servername();
    servername_ = servername;
  } else {
    clear_has_servername();
    servername_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// Packet_Session_LoginMasterAck

// required .TvWall.Packet.Session.LoginAck loginAck = 1;
inline bool Packet_Session_LoginMasterAck::has_loginack() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Packet_Session_LoginMasterAck::set_has_loginack() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Packet_Session_LoginMasterAck::clear_has_loginack() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Packet_Session_LoginMasterAck::clear_loginack() {
  if (loginack_ != NULL) loginack_->::TvWall::Packet_Session_LoginAck::Clear();
  clear_has_loginack();
}
inline const ::TvWall::Packet_Session_LoginAck& Packet_Session_LoginMasterAck::loginack() const {
  return loginack_ != NULL ? *loginack_ : *default_instance_->loginack_;
}
inline ::TvWall::Packet_Session_LoginAck* Packet_Session_LoginMasterAck::mutable_loginack() {
  set_has_loginack();
  if (loginack_ == NULL) loginack_ = new ::TvWall::Packet_Session_LoginAck;
  return loginack_;
}
inline ::TvWall::Packet_Session_LoginAck* Packet_Session_LoginMasterAck::release_loginack() {
  clear_has_loginack();
  ::TvWall::Packet_Session_LoginAck* temp = loginack_;
  loginack_ = NULL;
  return temp;
}
inline void Packet_Session_LoginMasterAck::set_allocated_loginack(::TvWall::Packet_Session_LoginAck* loginack) {
  delete loginack_;
  loginack_ = loginack;
  if (loginack) {
    set_has_loginack();
  } else {
    clear_has_loginack();
  }
}

// required int32 token = 2;
inline bool Packet_Session_LoginMasterAck::has_token() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Packet_Session_LoginMasterAck::set_has_token() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Packet_Session_LoginMasterAck::clear_has_token() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Packet_Session_LoginMasterAck::clear_token() {
  token_ = 0;
  clear_has_token();
}
inline ::google::protobuf::int32 Packet_Session_LoginMasterAck::token() const {
  return token_;
}
inline void Packet_Session_LoginMasterAck::set_token(::google::protobuf::int32 value) {
  set_has_token();
  token_ = value;
}

// repeated .TvWall.Packet.Session.LoginMasterAck.Server ser = 3;
inline int Packet_Session_LoginMasterAck::ser_size() const {
  return ser_.size();
}
inline void Packet_Session_LoginMasterAck::clear_ser() {
  ser_.Clear();
}
inline const ::TvWall::Packet_Session_LoginMasterAck_Server& Packet_Session_LoginMasterAck::ser(int index) const {
  return ser_.Get(index);
}
inline ::TvWall::Packet_Session_LoginMasterAck_Server* Packet_Session_LoginMasterAck::mutable_ser(int index) {
  return ser_.Mutable(index);
}
inline ::TvWall::Packet_Session_LoginMasterAck_Server* Packet_Session_LoginMasterAck::add_ser() {
  return ser_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TvWall::Packet_Session_LoginMasterAck_Server >&
Packet_Session_LoginMasterAck::ser() const {
  return ser_;
}
inline ::google::protobuf::RepeatedPtrField< ::TvWall::Packet_Session_LoginMasterAck_Server >*
Packet_Session_LoginMasterAck::mutable_ser() {
  return &ser_;
}

// required .TvWall.Packet.ElementMaster.MasterLayout lyout = 4;
inline bool Packet_Session_LoginMasterAck::has_lyout() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Packet_Session_LoginMasterAck::set_has_lyout() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Packet_Session_LoginMasterAck::clear_has_lyout() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Packet_Session_LoginMasterAck::clear_lyout() {
  if (lyout_ != NULL) lyout_->::TvWall::Packet_ElementMaster_MasterLayout::Clear();
  clear_has_lyout();
}
inline const ::TvWall::Packet_ElementMaster_MasterLayout& Packet_Session_LoginMasterAck::lyout() const {
  return lyout_ != NULL ? *lyout_ : *default_instance_->lyout_;
}
inline ::TvWall::Packet_ElementMaster_MasterLayout* Packet_Session_LoginMasterAck::mutable_lyout() {
  set_has_lyout();
  if (lyout_ == NULL) lyout_ = new ::TvWall::Packet_ElementMaster_MasterLayout;
  return lyout_;
}
inline ::TvWall::Packet_ElementMaster_MasterLayout* Packet_Session_LoginMasterAck::release_lyout() {
  clear_has_lyout();
  ::TvWall::Packet_ElementMaster_MasterLayout* temp = lyout_;
  lyout_ = NULL;
  return temp;
}
inline void Packet_Session_LoginMasterAck::set_allocated_lyout(::TvWall::Packet_ElementMaster_MasterLayout* lyout) {
  delete lyout_;
  lyout_ = lyout;
  if (lyout) {
    set_has_lyout();
  } else {
    clear_has_lyout();
  }
}

// -------------------------------------------------------------------

// Packet_Session_Logout

// required .TvWall.Packet.Session.LogoutReasonType reason = 1;
inline bool Packet_Session_Logout::has_reason() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Packet_Session_Logout::set_has_reason() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Packet_Session_Logout::clear_has_reason() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Packet_Session_Logout::clear_reason() {
  reason_ = 0;
  clear_has_reason();
}
inline ::TvWall::Packet_Session_LogoutReasonType Packet_Session_Logout::reason() const {
  return static_cast< ::TvWall::Packet_Session_LogoutReasonType >(reason_);
}
inline void Packet_Session_Logout::set_reason(::TvWall::Packet_Session_LogoutReasonType value) {
  assert(::TvWall::Packet_Session_LogoutReasonType_IsValid(value));
  set_has_reason();
  reason_ = value;
}

// -------------------------------------------------------------------

// Packet_Session_LogoutAck

// -------------------------------------------------------------------

// Packet_Session_Ping

// required int32 num = 1;
inline bool Packet_Session_Ping::has_num() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Packet_Session_Ping::set_has_num() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Packet_Session_Ping::clear_has_num() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Packet_Session_Ping::clear_num() {
  num_ = 0;
  clear_has_num();
}
inline ::google::protobuf::int32 Packet_Session_Ping::num() const {
  return num_;
}
inline void Packet_Session_Ping::set_num(::google::protobuf::int32 value) {
  set_has_num();
  num_ = value;
}

// -------------------------------------------------------------------

// Packet_Session_PingAck

// required int32 num = 2;
inline bool Packet_Session_PingAck::has_num() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Packet_Session_PingAck::set_has_num() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Packet_Session_PingAck::clear_has_num() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Packet_Session_PingAck::clear_num() {
  num_ = 0;
  clear_has_num();
}
inline ::google::protobuf::int32 Packet_Session_PingAck::num() const {
  return num_;
}
inline void Packet_Session_PingAck::set_num(::google::protobuf::int32 value) {
  set_has_num();
  num_ = value;
}

// -------------------------------------------------------------------

// Packet_Session

// optional .TvWall.Packet.Session.Login login = 1;
inline bool Packet_Session::has_login() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Packet_Session::set_has_login() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Packet_Session::clear_has_login() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Packet_Session::clear_login() {
  if (login_ != NULL) login_->::TvWall::Packet_Session_Login::Clear();
  clear_has_login();
}
inline const ::TvWall::Packet_Session_Login& Packet_Session::login() const {
  return login_ != NULL ? *login_ : *default_instance_->login_;
}
inline ::TvWall::Packet_Session_Login* Packet_Session::mutable_login() {
  set_has_login();
  if (login_ == NULL) login_ = new ::TvWall::Packet_Session_Login;
  return login_;
}
inline ::TvWall::Packet_Session_Login* Packet_Session::release_login() {
  clear_has_login();
  ::TvWall::Packet_Session_Login* temp = login_;
  login_ = NULL;
  return temp;
}
inline void Packet_Session::set_allocated_login(::TvWall::Packet_Session_Login* login) {
  delete login_;
  login_ = login;
  if (login) {
    set_has_login();
  } else {
    clear_has_login();
  }
}

// optional .TvWall.Packet.Session.LoginAck loginAck = 2;
inline bool Packet_Session::has_loginack() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Packet_Session::set_has_loginack() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Packet_Session::clear_has_loginack() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Packet_Session::clear_loginack() {
  if (loginack_ != NULL) loginack_->::TvWall::Packet_Session_LoginAck::Clear();
  clear_has_loginack();
}
inline const ::TvWall::Packet_Session_LoginAck& Packet_Session::loginack() const {
  return loginack_ != NULL ? *loginack_ : *default_instance_->loginack_;
}
inline ::TvWall::Packet_Session_LoginAck* Packet_Session::mutable_loginack() {
  set_has_loginack();
  if (loginack_ == NULL) loginack_ = new ::TvWall::Packet_Session_LoginAck;
  return loginack_;
}
inline ::TvWall::Packet_Session_LoginAck* Packet_Session::release_loginack() {
  clear_has_loginack();
  ::TvWall::Packet_Session_LoginAck* temp = loginack_;
  loginack_ = NULL;
  return temp;
}
inline void Packet_Session::set_allocated_loginack(::TvWall::Packet_Session_LoginAck* loginack) {
  delete loginack_;
  loginack_ = loginack;
  if (loginack) {
    set_has_loginack();
  } else {
    clear_has_loginack();
  }
}

// optional .TvWall.Packet.Session.LoginMasterAck loginMstAck = 3;
inline bool Packet_Session::has_loginmstack() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Packet_Session::set_has_loginmstack() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Packet_Session::clear_has_loginmstack() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Packet_Session::clear_loginmstack() {
  if (loginmstack_ != NULL) loginmstack_->::TvWall::Packet_Session_LoginMasterAck::Clear();
  clear_has_loginmstack();
}
inline const ::TvWall::Packet_Session_LoginMasterAck& Packet_Session::loginmstack() const {
  return loginmstack_ != NULL ? *loginmstack_ : *default_instance_->loginmstack_;
}
inline ::TvWall::Packet_Session_LoginMasterAck* Packet_Session::mutable_loginmstack() {
  set_has_loginmstack();
  if (loginmstack_ == NULL) loginmstack_ = new ::TvWall::Packet_Session_LoginMasterAck;
  return loginmstack_;
}
inline ::TvWall::Packet_Session_LoginMasterAck* Packet_Session::release_loginmstack() {
  clear_has_loginmstack();
  ::TvWall::Packet_Session_LoginMasterAck* temp = loginmstack_;
  loginmstack_ = NULL;
  return temp;
}
inline void Packet_Session::set_allocated_loginmstack(::TvWall::Packet_Session_LoginMasterAck* loginmstack) {
  delete loginmstack_;
  loginmstack_ = loginmstack;
  if (loginmstack) {
    set_has_loginmstack();
  } else {
    clear_has_loginmstack();
  }
}

// optional .TvWall.Packet.Session.Logout logout = 4;
inline bool Packet_Session::has_logout() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Packet_Session::set_has_logout() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Packet_Session::clear_has_logout() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Packet_Session::clear_logout() {
  if (logout_ != NULL) logout_->::TvWall::Packet_Session_Logout::Clear();
  clear_has_logout();
}
inline const ::TvWall::Packet_Session_Logout& Packet_Session::logout() const {
  return logout_ != NULL ? *logout_ : *default_instance_->logout_;
}
inline ::TvWall::Packet_Session_Logout* Packet_Session::mutable_logout() {
  set_has_logout();
  if (logout_ == NULL) logout_ = new ::TvWall::Packet_Session_Logout;
  return logout_;
}
inline ::TvWall::Packet_Session_Logout* Packet_Session::release_logout() {
  clear_has_logout();
  ::TvWall::Packet_Session_Logout* temp = logout_;
  logout_ = NULL;
  return temp;
}
inline void Packet_Session::set_allocated_logout(::TvWall::Packet_Session_Logout* logout) {
  delete logout_;
  logout_ = logout;
  if (logout) {
    set_has_logout();
  } else {
    clear_has_logout();
  }
}

// optional .TvWall.Packet.Session.LogoutAck logoutAck = 5;
inline bool Packet_Session::has_logoutack() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Packet_Session::set_has_logoutack() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Packet_Session::clear_has_logoutack() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Packet_Session::clear_logoutack() {
  if (logoutack_ != NULL) logoutack_->::TvWall::Packet_Session_LogoutAck::Clear();
  clear_has_logoutack();
}
inline const ::TvWall::Packet_Session_LogoutAck& Packet_Session::logoutack() const {
  return logoutack_ != NULL ? *logoutack_ : *default_instance_->logoutack_;
}
inline ::TvWall::Packet_Session_LogoutAck* Packet_Session::mutable_logoutack() {
  set_has_logoutack();
  if (logoutack_ == NULL) logoutack_ = new ::TvWall::Packet_Session_LogoutAck;
  return logoutack_;
}
inline ::TvWall::Packet_Session_LogoutAck* Packet_Session::release_logoutack() {
  clear_has_logoutack();
  ::TvWall::Packet_Session_LogoutAck* temp = logoutack_;
  logoutack_ = NULL;
  return temp;
}
inline void Packet_Session::set_allocated_logoutack(::TvWall::Packet_Session_LogoutAck* logoutack) {
  delete logoutack_;
  logoutack_ = logoutack;
  if (logoutack) {
    set_has_logoutack();
  } else {
    clear_has_logoutack();
  }
}

// optional .TvWall.Packet.Session.Ping ping = 6;
inline bool Packet_Session::has_ping() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Packet_Session::set_has_ping() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Packet_Session::clear_has_ping() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Packet_Session::clear_ping() {
  if (ping_ != NULL) ping_->::TvWall::Packet_Session_Ping::Clear();
  clear_has_ping();
}
inline const ::TvWall::Packet_Session_Ping& Packet_Session::ping() const {
  return ping_ != NULL ? *ping_ : *default_instance_->ping_;
}
inline ::TvWall::Packet_Session_Ping* Packet_Session::mutable_ping() {
  set_has_ping();
  if (ping_ == NULL) ping_ = new ::TvWall::Packet_Session_Ping;
  return ping_;
}
inline ::TvWall::Packet_Session_Ping* Packet_Session::release_ping() {
  clear_has_ping();
  ::TvWall::Packet_Session_Ping* temp = ping_;
  ping_ = NULL;
  return temp;
}
inline void Packet_Session::set_allocated_ping(::TvWall::Packet_Session_Ping* ping) {
  delete ping_;
  ping_ = ping;
  if (ping) {
    set_has_ping();
  } else {
    clear_has_ping();
  }
}

// optional .TvWall.Packet.Session.PingAck pingAck = 7;
inline bool Packet_Session::has_pingack() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Packet_Session::set_has_pingack() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Packet_Session::clear_has_pingack() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Packet_Session::clear_pingack() {
  if (pingack_ != NULL) pingack_->::TvWall::Packet_Session_PingAck::Clear();
  clear_has_pingack();
}
inline const ::TvWall::Packet_Session_PingAck& Packet_Session::pingack() const {
  return pingack_ != NULL ? *pingack_ : *default_instance_->pingack_;
}
inline ::TvWall::Packet_Session_PingAck* Packet_Session::mutable_pingack() {
  set_has_pingack();
  if (pingack_ == NULL) pingack_ = new ::TvWall::Packet_Session_PingAck;
  return pingack_;
}
inline ::TvWall::Packet_Session_PingAck* Packet_Session::release_pingack() {
  clear_has_pingack();
  ::TvWall::Packet_Session_PingAck* temp = pingack_;
  pingack_ = NULL;
  return temp;
}
inline void Packet_Session::set_allocated_pingack(::TvWall::Packet_Session_PingAck* pingack) {
  delete pingack_;
  pingack_ = pingack;
  if (pingack) {
    set_has_pingack();
  } else {
    clear_has_pingack();
  }
}

// -------------------------------------------------------------------

// Packet_ElementDat_Screen

// required .TvWall.Rect geometry = 1;
inline bool Packet_ElementDat_Screen::has_geometry() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Packet_ElementDat_Screen::set_has_geometry() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Packet_ElementDat_Screen::clear_has_geometry() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Packet_ElementDat_Screen::clear_geometry() {
  if (geometry_ != NULL) geometry_->::TvWall::Rect::Clear();
  clear_has_geometry();
}
inline const ::TvWall::Rect& Packet_ElementDat_Screen::geometry() const {
  return geometry_ != NULL ? *geometry_ : *default_instance_->geometry_;
}
inline ::TvWall::Rect* Packet_ElementDat_Screen::mutable_geometry() {
  set_has_geometry();
  if (geometry_ == NULL) geometry_ = new ::TvWall::Rect;
  return geometry_;
}
inline ::TvWall::Rect* Packet_ElementDat_Screen::release_geometry() {
  clear_has_geometry();
  ::TvWall::Rect* temp = geometry_;
  geometry_ = NULL;
  return temp;
}
inline void Packet_ElementDat_Screen::set_allocated_geometry(::TvWall::Rect* geometry) {
  delete geometry_;
  geometry_ = geometry;
  if (geometry) {
    set_has_geometry();
  } else {
    clear_has_geometry();
  }
}

// optional int32 screenIndex = 2;
inline bool Packet_ElementDat_Screen::has_screenindex() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Packet_ElementDat_Screen::set_has_screenindex() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Packet_ElementDat_Screen::clear_has_screenindex() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Packet_ElementDat_Screen::clear_screenindex() {
  screenindex_ = 0;
  clear_has_screenindex();
}
inline ::google::protobuf::int32 Packet_ElementDat_Screen::screenindex() const {
  return screenindex_;
}
inline void Packet_ElementDat_Screen::set_screenindex(::google::protobuf::int32 value) {
  set_has_screenindex();
  screenindex_ = value;
}

// required int32 row = 3;
inline bool Packet_ElementDat_Screen::has_row() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Packet_ElementDat_Screen::set_has_row() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Packet_ElementDat_Screen::clear_has_row() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Packet_ElementDat_Screen::clear_row() {
  row_ = 0;
  clear_has_row();
}
inline ::google::protobuf::int32 Packet_ElementDat_Screen::row() const {
  return row_;
}
inline void Packet_ElementDat_Screen::set_row(::google::protobuf::int32 value) {
  set_has_row();
  row_ = value;
}

// required int32 col = 4;
inline bool Packet_ElementDat_Screen::has_col() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Packet_ElementDat_Screen::set_has_col() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Packet_ElementDat_Screen::clear_has_col() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Packet_ElementDat_Screen::clear_col() {
  col_ = 0;
  clear_has_col();
}
inline ::google::protobuf::int32 Packet_ElementDat_Screen::col() const {
  return col_;
}
inline void Packet_ElementDat_Screen::set_col(::google::protobuf::int32 value) {
  set_has_col();
  col_ = value;
}

// -------------------------------------------------------------------

// Packet_ElementDat_Camera_CameraInfo

// required string cameraIP = 1;
inline bool Packet_ElementDat_Camera_CameraInfo::has_cameraip() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Packet_ElementDat_Camera_CameraInfo::set_has_cameraip() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Packet_ElementDat_Camera_CameraInfo::clear_has_cameraip() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Packet_ElementDat_Camera_CameraInfo::clear_cameraip() {
  if (cameraip_ != &::google::protobuf::internal::kEmptyString) {
    cameraip_->clear();
  }
  clear_has_cameraip();
}
inline const ::std::string& Packet_ElementDat_Camera_CameraInfo::cameraip() const {
  return *cameraip_;
}
inline void Packet_ElementDat_Camera_CameraInfo::set_cameraip(const ::std::string& value) {
  set_has_cameraip();
  if (cameraip_ == &::google::protobuf::internal::kEmptyString) {
    cameraip_ = new ::std::string;
  }
  cameraip_->assign(value);
}
inline void Packet_ElementDat_Camera_CameraInfo::set_cameraip(const char* value) {
  set_has_cameraip();
  if (cameraip_ == &::google::protobuf::internal::kEmptyString) {
    cameraip_ = new ::std::string;
  }
  cameraip_->assign(value);
}
inline void Packet_ElementDat_Camera_CameraInfo::set_cameraip(const char* value, size_t size) {
  set_has_cameraip();
  if (cameraip_ == &::google::protobuf::internal::kEmptyString) {
    cameraip_ = new ::std::string;
  }
  cameraip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Packet_ElementDat_Camera_CameraInfo::mutable_cameraip() {
  set_has_cameraip();
  if (cameraip_ == &::google::protobuf::internal::kEmptyString) {
    cameraip_ = new ::std::string;
  }
  return cameraip_;
}
inline ::std::string* Packet_ElementDat_Camera_CameraInfo::release_cameraip() {
  clear_has_cameraip();
  if (cameraip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = cameraip_;
    cameraip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Packet_ElementDat_Camera_CameraInfo::set_allocated_cameraip(::std::string* cameraip) {
  if (cameraip_ != &::google::protobuf::internal::kEmptyString) {
    delete cameraip_;
  }
  if (cameraip) {
    set_has_cameraip();
    cameraip_ = cameraip;
  } else {
    clear_has_cameraip();
    cameraip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 cameraPort = 2;
inline bool Packet_ElementDat_Camera_CameraInfo::has_cameraport() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Packet_ElementDat_Camera_CameraInfo::set_has_cameraport() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Packet_ElementDat_Camera_CameraInfo::clear_has_cameraport() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Packet_ElementDat_Camera_CameraInfo::clear_cameraport() {
  cameraport_ = 0;
  clear_has_cameraport();
}
inline ::google::protobuf::int32 Packet_ElementDat_Camera_CameraInfo::cameraport() const {
  return cameraport_;
}
inline void Packet_ElementDat_Camera_CameraInfo::set_cameraport(::google::protobuf::int32 value) {
  set_has_cameraport();
  cameraport_ = value;
}

// optional string cameraName = 3;
inline bool Packet_ElementDat_Camera_CameraInfo::has_cameraname() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Packet_ElementDat_Camera_CameraInfo::set_has_cameraname() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Packet_ElementDat_Camera_CameraInfo::clear_has_cameraname() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Packet_ElementDat_Camera_CameraInfo::clear_cameraname() {
  if (cameraname_ != &::google::protobuf::internal::kEmptyString) {
    cameraname_->clear();
  }
  clear_has_cameraname();
}
inline const ::std::string& Packet_ElementDat_Camera_CameraInfo::cameraname() const {
  return *cameraname_;
}
inline void Packet_ElementDat_Camera_CameraInfo::set_cameraname(const ::std::string& value) {
  set_has_cameraname();
  if (cameraname_ == &::google::protobuf::internal::kEmptyString) {
    cameraname_ = new ::std::string;
  }
  cameraname_->assign(value);
}
inline void Packet_ElementDat_Camera_CameraInfo::set_cameraname(const char* value) {
  set_has_cameraname();
  if (cameraname_ == &::google::protobuf::internal::kEmptyString) {
    cameraname_ = new ::std::string;
  }
  cameraname_->assign(value);
}
inline void Packet_ElementDat_Camera_CameraInfo::set_cameraname(const char* value, size_t size) {
  set_has_cameraname();
  if (cameraname_ == &::google::protobuf::internal::kEmptyString) {
    cameraname_ = new ::std::string;
  }
  cameraname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Packet_ElementDat_Camera_CameraInfo::mutable_cameraname() {
  set_has_cameraname();
  if (cameraname_ == &::google::protobuf::internal::kEmptyString) {
    cameraname_ = new ::std::string;
  }
  return cameraname_;
}
inline ::std::string* Packet_ElementDat_Camera_CameraInfo::release_cameraname() {
  clear_has_cameraname();
  if (cameraname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = cameraname_;
    cameraname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Packet_ElementDat_Camera_CameraInfo::set_allocated_cameraname(::std::string* cameraname) {
  if (cameraname_ != &::google::protobuf::internal::kEmptyString) {
    delete cameraname_;
  }
  if (cameraname) {
    set_has_cameraname();
    cameraname_ = cameraname;
  } else {
    clear_has_cameraname();
    cameraname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 width = 4;
inline bool Packet_ElementDat_Camera_CameraInfo::has_width() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Packet_ElementDat_Camera_CameraInfo::set_has_width() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Packet_ElementDat_Camera_CameraInfo::clear_has_width() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Packet_ElementDat_Camera_CameraInfo::clear_width() {
  width_ = 0;
  clear_has_width();
}
inline ::google::protobuf::int32 Packet_ElementDat_Camera_CameraInfo::width() const {
  return width_;
}
inline void Packet_ElementDat_Camera_CameraInfo::set_width(::google::protobuf::int32 value) {
  set_has_width();
  width_ = value;
}

// optional int32 height = 5;
inline bool Packet_ElementDat_Camera_CameraInfo::has_height() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Packet_ElementDat_Camera_CameraInfo::set_has_height() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Packet_ElementDat_Camera_CameraInfo::clear_has_height() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Packet_ElementDat_Camera_CameraInfo::clear_height() {
  height_ = 0;
  clear_has_height();
}
inline ::google::protobuf::int32 Packet_ElementDat_Camera_CameraInfo::height() const {
  return height_;
}
inline void Packet_ElementDat_Camera_CameraInfo::set_height(::google::protobuf::int32 value) {
  set_has_height();
  height_ = value;
}

// optional bool canPtz = 6;
inline bool Packet_ElementDat_Camera_CameraInfo::has_canptz() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Packet_ElementDat_Camera_CameraInfo::set_has_canptz() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Packet_ElementDat_Camera_CameraInfo::clear_has_canptz() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Packet_ElementDat_Camera_CameraInfo::clear_canptz() {
  canptz_ = false;
  clear_has_canptz();
}
inline bool Packet_ElementDat_Camera_CameraInfo::canptz() const {
  return canptz_;
}
inline void Packet_ElementDat_Camera_CameraInfo::set_canptz(bool value) {
  set_has_canptz();
  canptz_ = value;
}

// optional bool composite = 7 [default = false];
inline bool Packet_ElementDat_Camera_CameraInfo::has_composite() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Packet_ElementDat_Camera_CameraInfo::set_has_composite() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Packet_ElementDat_Camera_CameraInfo::clear_has_composite() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Packet_ElementDat_Camera_CameraInfo::clear_composite() {
  composite_ = false;
  clear_has_composite();
}
inline bool Packet_ElementDat_Camera_CameraInfo::composite() const {
  return composite_;
}
inline void Packet_ElementDat_Camera_CameraInfo::set_composite(bool value) {
  set_has_composite();
  composite_ = value;
}

// optional uint32 model = 8;
inline bool Packet_ElementDat_Camera_CameraInfo::has_model() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Packet_ElementDat_Camera_CameraInfo::set_has_model() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Packet_ElementDat_Camera_CameraInfo::clear_has_model() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Packet_ElementDat_Camera_CameraInfo::clear_model() {
  model_ = 0u;
  clear_has_model();
}
inline ::google::protobuf::uint32 Packet_ElementDat_Camera_CameraInfo::model() const {
  return model_;
}
inline void Packet_ElementDat_Camera_CameraInfo::set_model(::google::protobuf::uint32 value) {
  set_has_model();
  model_ = value;
}

// -------------------------------------------------------------------

// Packet_ElementDat_Camera_RecordInfo

// required uint64 begin = 1;
inline bool Packet_ElementDat_Camera_RecordInfo::has_begin() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Packet_ElementDat_Camera_RecordInfo::set_has_begin() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Packet_ElementDat_Camera_RecordInfo::clear_has_begin() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Packet_ElementDat_Camera_RecordInfo::clear_begin() {
  begin_ = GOOGLE_ULONGLONG(0);
  clear_has_begin();
}
inline ::google::protobuf::uint64 Packet_ElementDat_Camera_RecordInfo::begin() const {
  return begin_;
}
inline void Packet_ElementDat_Camera_RecordInfo::set_begin(::google::protobuf::uint64 value) {
  set_has_begin();
  begin_ = value;
}

// -------------------------------------------------------------------

// Packet_ElementDat_Camera

// required .TvWall.Guid cameraId = 1;
inline bool Packet_ElementDat_Camera::has_cameraid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Packet_ElementDat_Camera::set_has_cameraid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Packet_ElementDat_Camera::clear_has_cameraid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Packet_ElementDat_Camera::clear_cameraid() {
  if (cameraid_ != NULL) cameraid_->::TvWall::Guid::Clear();
  clear_has_cameraid();
}
inline const ::TvWall::Guid& Packet_ElementDat_Camera::cameraid() const {
  return cameraid_ != NULL ? *cameraid_ : *default_instance_->cameraid_;
}
inline ::TvWall::Guid* Packet_ElementDat_Camera::mutable_cameraid() {
  set_has_cameraid();
  if (cameraid_ == NULL) cameraid_ = new ::TvWall::Guid;
  return cameraid_;
}
inline ::TvWall::Guid* Packet_ElementDat_Camera::release_cameraid() {
  clear_has_cameraid();
  ::TvWall::Guid* temp = cameraid_;
  cameraid_ = NULL;
  return temp;
}
inline void Packet_ElementDat_Camera::set_allocated_cameraid(::TvWall::Guid* cameraid) {
  delete cameraid_;
  cameraid_ = cameraid;
  if (cameraid) {
    set_has_cameraid();
  } else {
    clear_has_cameraid();
  }
}

// required .TvWall.Packet.ElementDat.Camera.CameraInfo cameraInfo = 2;
inline bool Packet_ElementDat_Camera::has_camerainfo() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Packet_ElementDat_Camera::set_has_camerainfo() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Packet_ElementDat_Camera::clear_has_camerainfo() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Packet_ElementDat_Camera::clear_camerainfo() {
  if (camerainfo_ != NULL) camerainfo_->::TvWall::Packet_ElementDat_Camera_CameraInfo::Clear();
  clear_has_camerainfo();
}
inline const ::TvWall::Packet_ElementDat_Camera_CameraInfo& Packet_ElementDat_Camera::camerainfo() const {
  return camerainfo_ != NULL ? *camerainfo_ : *default_instance_->camerainfo_;
}
inline ::TvWall::Packet_ElementDat_Camera_CameraInfo* Packet_ElementDat_Camera::mutable_camerainfo() {
  set_has_camerainfo();
  if (camerainfo_ == NULL) camerainfo_ = new ::TvWall::Packet_ElementDat_Camera_CameraInfo;
  return camerainfo_;
}
inline ::TvWall::Packet_ElementDat_Camera_CameraInfo* Packet_ElementDat_Camera::release_camerainfo() {
  clear_has_camerainfo();
  ::TvWall::Packet_ElementDat_Camera_CameraInfo* temp = camerainfo_;
  camerainfo_ = NULL;
  return temp;
}
inline void Packet_ElementDat_Camera::set_allocated_camerainfo(::TvWall::Packet_ElementDat_Camera_CameraInfo* camerainfo) {
  delete camerainfo_;
  camerainfo_ = camerainfo;
  if (camerainfo) {
    set_has_camerainfo();
  } else {
    clear_has_camerainfo();
  }
}

// optional .TvWall.Packet.ElementDat.Camera.RecordInfo recordInfo = 3;
inline bool Packet_ElementDat_Camera::has_recordinfo() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Packet_ElementDat_Camera::set_has_recordinfo() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Packet_ElementDat_Camera::clear_has_recordinfo() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Packet_ElementDat_Camera::clear_recordinfo() {
  if (recordinfo_ != NULL) recordinfo_->::TvWall::Packet_ElementDat_Camera_RecordInfo::Clear();
  clear_has_recordinfo();
}
inline const ::TvWall::Packet_ElementDat_Camera_RecordInfo& Packet_ElementDat_Camera::recordinfo() const {
  return recordinfo_ != NULL ? *recordinfo_ : *default_instance_->recordinfo_;
}
inline ::TvWall::Packet_ElementDat_Camera_RecordInfo* Packet_ElementDat_Camera::mutable_recordinfo() {
  set_has_recordinfo();
  if (recordinfo_ == NULL) recordinfo_ = new ::TvWall::Packet_ElementDat_Camera_RecordInfo;
  return recordinfo_;
}
inline ::TvWall::Packet_ElementDat_Camera_RecordInfo* Packet_ElementDat_Camera::release_recordinfo() {
  clear_has_recordinfo();
  ::TvWall::Packet_ElementDat_Camera_RecordInfo* temp = recordinfo_;
  recordinfo_ = NULL;
  return temp;
}
inline void Packet_ElementDat_Camera::set_allocated_recordinfo(::TvWall::Packet_ElementDat_Camera_RecordInfo* recordinfo) {
  delete recordinfo_;
  recordinfo_ = recordinfo;
  if (recordinfo) {
    set_has_recordinfo();
  } else {
    clear_has_recordinfo();
  }
}

// optional bool isPlaying = 4 [default = false];
inline bool Packet_ElementDat_Camera::has_isplaying() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Packet_ElementDat_Camera::set_has_isplaying() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Packet_ElementDat_Camera::clear_has_isplaying() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Packet_ElementDat_Camera::clear_isplaying() {
  isplaying_ = false;
  clear_has_isplaying();
}
inline bool Packet_ElementDat_Camera::isplaying() const {
  return isplaying_;
}
inline void Packet_ElementDat_Camera::set_isplaying(bool value) {
  set_has_isplaying();
  isplaying_ = value;
}

// optional bool isConnected = 5 [default = false];
inline bool Packet_ElementDat_Camera::has_isconnected() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Packet_ElementDat_Camera::set_has_isconnected() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Packet_ElementDat_Camera::clear_has_isconnected() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Packet_ElementDat_Camera::clear_isconnected() {
  isconnected_ = false;
  clear_has_isconnected();
}
inline bool Packet_ElementDat_Camera::isconnected() const {
  return isconnected_;
}
inline void Packet_ElementDat_Camera::set_isconnected(bool value) {
  set_has_isconnected();
  isconnected_ = value;
}

// optional bool isDel = 6 [default = false];
inline bool Packet_ElementDat_Camera::has_isdel() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Packet_ElementDat_Camera::set_has_isdel() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Packet_ElementDat_Camera::clear_has_isdel() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Packet_ElementDat_Camera::clear_isdel() {
  isdel_ = false;
  clear_has_isdel();
}
inline bool Packet_ElementDat_Camera::isdel() const {
  return isdel_;
}
inline void Packet_ElementDat_Camera::set_isdel(bool value) {
  set_has_isdel();
  isdel_ = value;
}

// optional bool isPlayBack = 7 [default = false];
inline bool Packet_ElementDat_Camera::has_isplayback() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Packet_ElementDat_Camera::set_has_isplayback() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Packet_ElementDat_Camera::clear_has_isplayback() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Packet_ElementDat_Camera::clear_isplayback() {
  isplayback_ = false;
  clear_has_isplayback();
}
inline bool Packet_ElementDat_Camera::isplayback() const {
  return isplayback_;
}
inline void Packet_ElementDat_Camera::set_isplayback(bool value) {
  set_has_isplayback();
  isplayback_ = value;
}

// optional .TvWall.Guid parentId = 8;
inline bool Packet_ElementDat_Camera::has_parentid() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Packet_ElementDat_Camera::set_has_parentid() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Packet_ElementDat_Camera::clear_has_parentid() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Packet_ElementDat_Camera::clear_parentid() {
  if (parentid_ != NULL) parentid_->::TvWall::Guid::Clear();
  clear_has_parentid();
}
inline const ::TvWall::Guid& Packet_ElementDat_Camera::parentid() const {
  return parentid_ != NULL ? *parentid_ : *default_instance_->parentid_;
}
inline ::TvWall::Guid* Packet_ElementDat_Camera::mutable_parentid() {
  set_has_parentid();
  if (parentid_ == NULL) parentid_ = new ::TvWall::Guid;
  return parentid_;
}
inline ::TvWall::Guid* Packet_ElementDat_Camera::release_parentid() {
  clear_has_parentid();
  ::TvWall::Guid* temp = parentid_;
  parentid_ = NULL;
  return temp;
}
inline void Packet_ElementDat_Camera::set_allocated_parentid(::TvWall::Guid* parentid) {
  delete parentid_;
  parentid_ = parentid;
  if (parentid) {
    set_has_parentid();
  } else {
    clear_has_parentid();
  }
}

// -------------------------------------------------------------------

// Packet_ElementDat_CameraGrp

// required string grpName = 1;
inline bool Packet_ElementDat_CameraGrp::has_grpname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Packet_ElementDat_CameraGrp::set_has_grpname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Packet_ElementDat_CameraGrp::clear_has_grpname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Packet_ElementDat_CameraGrp::clear_grpname() {
  if (grpname_ != &::google::protobuf::internal::kEmptyString) {
    grpname_->clear();
  }
  clear_has_grpname();
}
inline const ::std::string& Packet_ElementDat_CameraGrp::grpname() const {
  return *grpname_;
}
inline void Packet_ElementDat_CameraGrp::set_grpname(const ::std::string& value) {
  set_has_grpname();
  if (grpname_ == &::google::protobuf::internal::kEmptyString) {
    grpname_ = new ::std::string;
  }
  grpname_->assign(value);
}
inline void Packet_ElementDat_CameraGrp::set_grpname(const char* value) {
  set_has_grpname();
  if (grpname_ == &::google::protobuf::internal::kEmptyString) {
    grpname_ = new ::std::string;
  }
  grpname_->assign(value);
}
inline void Packet_ElementDat_CameraGrp::set_grpname(const char* value, size_t size) {
  set_has_grpname();
  if (grpname_ == &::google::protobuf::internal::kEmptyString) {
    grpname_ = new ::std::string;
  }
  grpname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Packet_ElementDat_CameraGrp::mutable_grpname() {
  set_has_grpname();
  if (grpname_ == &::google::protobuf::internal::kEmptyString) {
    grpname_ = new ::std::string;
  }
  return grpname_;
}
inline ::std::string* Packet_ElementDat_CameraGrp::release_grpname() {
  clear_has_grpname();
  if (grpname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = grpname_;
    grpname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Packet_ElementDat_CameraGrp::set_allocated_grpname(::std::string* grpname) {
  if (grpname_ != &::google::protobuf::internal::kEmptyString) {
    delete grpname_;
  }
  if (grpname) {
    set_has_grpname();
    grpname_ = grpname;
  } else {
    clear_has_grpname();
    grpname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .TvWall.Packet.ElementDat.Camera cam = 2;
inline int Packet_ElementDat_CameraGrp::cam_size() const {
  return cam_.size();
}
inline void Packet_ElementDat_CameraGrp::clear_cam() {
  cam_.Clear();
}
inline const ::TvWall::Packet_ElementDat_Camera& Packet_ElementDat_CameraGrp::cam(int index) const {
  return cam_.Get(index);
}
inline ::TvWall::Packet_ElementDat_Camera* Packet_ElementDat_CameraGrp::mutable_cam(int index) {
  return cam_.Mutable(index);
}
inline ::TvWall::Packet_ElementDat_Camera* Packet_ElementDat_CameraGrp::add_cam() {
  return cam_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TvWall::Packet_ElementDat_Camera >&
Packet_ElementDat_CameraGrp::cam() const {
  return cam_;
}
inline ::google::protobuf::RepeatedPtrField< ::TvWall::Packet_ElementDat_Camera >*
Packet_ElementDat_CameraGrp::mutable_cam() {
  return &cam_;
}

// repeated .TvWall.Packet.ElementDat.CameraGrp camGrp = 3;
inline int Packet_ElementDat_CameraGrp::camgrp_size() const {
  return camgrp_.size();
}
inline void Packet_ElementDat_CameraGrp::clear_camgrp() {
  camgrp_.Clear();
}
inline const ::TvWall::Packet_ElementDat_CameraGrp& Packet_ElementDat_CameraGrp::camgrp(int index) const {
  return camgrp_.Get(index);
}
inline ::TvWall::Packet_ElementDat_CameraGrp* Packet_ElementDat_CameraGrp::mutable_camgrp(int index) {
  return camgrp_.Mutable(index);
}
inline ::TvWall::Packet_ElementDat_CameraGrp* Packet_ElementDat_CameraGrp::add_camgrp() {
  return camgrp_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TvWall::Packet_ElementDat_CameraGrp >&
Packet_ElementDat_CameraGrp::camgrp() const {
  return camgrp_;
}
inline ::google::protobuf::RepeatedPtrField< ::TvWall::Packet_ElementDat_CameraGrp >*
Packet_ElementDat_CameraGrp::mutable_camgrp() {
  return &camgrp_;
}

// required .TvWall.Guid grpId = 4;
inline bool Packet_ElementDat_CameraGrp::has_grpid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Packet_ElementDat_CameraGrp::set_has_grpid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Packet_ElementDat_CameraGrp::clear_has_grpid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Packet_ElementDat_CameraGrp::clear_grpid() {
  if (grpid_ != NULL) grpid_->::TvWall::Guid::Clear();
  clear_has_grpid();
}
inline const ::TvWall::Guid& Packet_ElementDat_CameraGrp::grpid() const {
  return grpid_ != NULL ? *grpid_ : *default_instance_->grpid_;
}
inline ::TvWall::Guid* Packet_ElementDat_CameraGrp::mutable_grpid() {
  set_has_grpid();
  if (grpid_ == NULL) grpid_ = new ::TvWall::Guid;
  return grpid_;
}
inline ::TvWall::Guid* Packet_ElementDat_CameraGrp::release_grpid() {
  clear_has_grpid();
  ::TvWall::Guid* temp = grpid_;
  grpid_ = NULL;
  return temp;
}
inline void Packet_ElementDat_CameraGrp::set_allocated_grpid(::TvWall::Guid* grpid) {
  delete grpid_;
  grpid_ = grpid;
  if (grpid) {
    set_has_grpid();
  } else {
    clear_has_grpid();
  }
}

// optional bool isDel = 5 [default = false];
inline bool Packet_ElementDat_CameraGrp::has_isdel() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Packet_ElementDat_CameraGrp::set_has_isdel() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Packet_ElementDat_CameraGrp::clear_has_isdel() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Packet_ElementDat_CameraGrp::clear_isdel() {
  isdel_ = false;
  clear_has_isdel();
}
inline bool Packet_ElementDat_CameraGrp::isdel() const {
  return isdel_;
}
inline void Packet_ElementDat_CameraGrp::set_isdel(bool value) {
  set_has_isdel();
  isdel_ = value;
}

// optional .TvWall.Guid parentId = 6;
inline bool Packet_ElementDat_CameraGrp::has_parentid() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Packet_ElementDat_CameraGrp::set_has_parentid() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Packet_ElementDat_CameraGrp::clear_has_parentid() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Packet_ElementDat_CameraGrp::clear_parentid() {
  if (parentid_ != NULL) parentid_->::TvWall::Guid::Clear();
  clear_has_parentid();
}
inline const ::TvWall::Guid& Packet_ElementDat_CameraGrp::parentid() const {
  return parentid_ != NULL ? *parentid_ : *default_instance_->parentid_;
}
inline ::TvWall::Guid* Packet_ElementDat_CameraGrp::mutable_parentid() {
  set_has_parentid();
  if (parentid_ == NULL) parentid_ = new ::TvWall::Guid;
  return parentid_;
}
inline ::TvWall::Guid* Packet_ElementDat_CameraGrp::release_parentid() {
  clear_has_parentid();
  ::TvWall::Guid* temp = parentid_;
  parentid_ = NULL;
  return temp;
}
inline void Packet_ElementDat_CameraGrp::set_allocated_parentid(::TvWall::Guid* parentid) {
  delete parentid_;
  parentid_ = parentid;
  if (parentid) {
    set_has_parentid();
  } else {
    clear_has_parentid();
  }
}

// -------------------------------------------------------------------

// Packet_ElementDat_LocalMovie

// required string fileName = 1;
inline bool Packet_ElementDat_LocalMovie::has_filename() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Packet_ElementDat_LocalMovie::set_has_filename() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Packet_ElementDat_LocalMovie::clear_has_filename() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Packet_ElementDat_LocalMovie::clear_filename() {
  if (filename_ != &::google::protobuf::internal::kEmptyString) {
    filename_->clear();
  }
  clear_has_filename();
}
inline const ::std::string& Packet_ElementDat_LocalMovie::filename() const {
  return *filename_;
}
inline void Packet_ElementDat_LocalMovie::set_filename(const ::std::string& value) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  filename_->assign(value);
}
inline void Packet_ElementDat_LocalMovie::set_filename(const char* value) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  filename_->assign(value);
}
inline void Packet_ElementDat_LocalMovie::set_filename(const char* value, size_t size) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  filename_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Packet_ElementDat_LocalMovie::mutable_filename() {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  return filename_;
}
inline ::std::string* Packet_ElementDat_LocalMovie::release_filename() {
  clear_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = filename_;
    filename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Packet_ElementDat_LocalMovie::set_allocated_filename(::std::string* filename) {
  if (filename_ != &::google::protobuf::internal::kEmptyString) {
    delete filename_;
  }
  if (filename) {
    set_has_filename();
    filename_ = filename;
  } else {
    clear_has_filename();
    filename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// Packet_ElementDat_Flash

// required string url = 1;
inline bool Packet_ElementDat_Flash::has_url() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Packet_ElementDat_Flash::set_has_url() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Packet_ElementDat_Flash::clear_has_url() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Packet_ElementDat_Flash::clear_url() {
  if (url_ != &::google::protobuf::internal::kEmptyString) {
    url_->clear();
  }
  clear_has_url();
}
inline const ::std::string& Packet_ElementDat_Flash::url() const {
  return *url_;
}
inline void Packet_ElementDat_Flash::set_url(const ::std::string& value) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  url_->assign(value);
}
inline void Packet_ElementDat_Flash::set_url(const char* value) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  url_->assign(value);
}
inline void Packet_ElementDat_Flash::set_url(const char* value, size_t size) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  url_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Packet_ElementDat_Flash::mutable_url() {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  return url_;
}
inline ::std::string* Packet_ElementDat_Flash::release_url() {
  clear_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = url_;
    url_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Packet_ElementDat_Flash::set_allocated_url(::std::string* url) {
  if (url_ != &::google::protobuf::internal::kEmptyString) {
    delete url_;
  }
  if (url) {
    set_has_url();
    url_ = url;
  } else {
    clear_has_url();
    url_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// Packet_ElementDat_View

// required int32 winId = 1;
inline bool Packet_ElementDat_View::has_winid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Packet_ElementDat_View::set_has_winid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Packet_ElementDat_View::clear_has_winid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Packet_ElementDat_View::clear_winid() {
  winid_ = 0;
  clear_has_winid();
}
inline ::google::protobuf::int32 Packet_ElementDat_View::winid() const {
  return winid_;
}
inline void Packet_ElementDat_View::set_winid(::google::protobuf::int32 value) {
  set_has_winid();
  winid_ = value;
}

// required .TvWall.Rect rect = 2;
inline bool Packet_ElementDat_View::has_rect() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Packet_ElementDat_View::set_has_rect() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Packet_ElementDat_View::clear_has_rect() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Packet_ElementDat_View::clear_rect() {
  if (rect_ != NULL) rect_->::TvWall::Rect::Clear();
  clear_has_rect();
}
inline const ::TvWall::Rect& Packet_ElementDat_View::rect() const {
  return rect_ != NULL ? *rect_ : *default_instance_->rect_;
}
inline ::TvWall::Rect* Packet_ElementDat_View::mutable_rect() {
  set_has_rect();
  if (rect_ == NULL) rect_ = new ::TvWall::Rect;
  return rect_;
}
inline ::TvWall::Rect* Packet_ElementDat_View::release_rect() {
  clear_has_rect();
  ::TvWall::Rect* temp = rect_;
  rect_ = NULL;
  return temp;
}
inline void Packet_ElementDat_View::set_allocated_rect(::TvWall::Rect* rect) {
  delete rect_;
  rect_ = rect;
  if (rect) {
    set_has_rect();
  } else {
    clear_has_rect();
  }
}

// required .TvWall.Packet.ElementDat.View.ViewType viewType = 3;
inline bool Packet_ElementDat_View::has_viewtype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Packet_ElementDat_View::set_has_viewtype() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Packet_ElementDat_View::clear_has_viewtype() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Packet_ElementDat_View::clear_viewtype() {
  viewtype_ = 0;
  clear_has_viewtype();
}
inline ::TvWall::Packet_ElementDat_View_ViewType Packet_ElementDat_View::viewtype() const {
  return static_cast< ::TvWall::Packet_ElementDat_View_ViewType >(viewtype_);
}
inline void Packet_ElementDat_View::set_viewtype(::TvWall::Packet_ElementDat_View_ViewType value) {
  assert(::TvWall::Packet_ElementDat_View_ViewType_IsValid(value));
  set_has_viewtype();
  viewtype_ = value;
}

// optional string url = 4;
inline bool Packet_ElementDat_View::has_url() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Packet_ElementDat_View::set_has_url() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Packet_ElementDat_View::clear_has_url() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Packet_ElementDat_View::clear_url() {
  if (url_ != &::google::protobuf::internal::kEmptyString) {
    url_->clear();
  }
  clear_has_url();
}
inline const ::std::string& Packet_ElementDat_View::url() const {
  return *url_;
}
inline void Packet_ElementDat_View::set_url(const ::std::string& value) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  url_->assign(value);
}
inline void Packet_ElementDat_View::set_url(const char* value) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  url_->assign(value);
}
inline void Packet_ElementDat_View::set_url(const char* value, size_t size) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  url_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Packet_ElementDat_View::mutable_url() {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  return url_;
}
inline ::std::string* Packet_ElementDat_View::release_url() {
  clear_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = url_;
    url_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Packet_ElementDat_View::set_allocated_url(::std::string* url) {
  if (url_ != &::google::protobuf::internal::kEmptyString) {
    delete url_;
  }
  if (url) {
    set_has_url();
    url_ = url;
  } else {
    clear_has_url();
    url_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .TvWall.Guid cameraId = 5;
inline int Packet_ElementDat_View::cameraid_size() const {
  return cameraid_.size();
}
inline void Packet_ElementDat_View::clear_cameraid() {
  cameraid_.Clear();
}
inline const ::TvWall::Guid& Packet_ElementDat_View::cameraid(int index) const {
  return cameraid_.Get(index);
}
inline ::TvWall::Guid* Packet_ElementDat_View::mutable_cameraid(int index) {
  return cameraid_.Mutable(index);
}
inline ::TvWall::Guid* Packet_ElementDat_View::add_cameraid() {
  return cameraid_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TvWall::Guid >&
Packet_ElementDat_View::cameraid() const {
  return cameraid_;
}
inline ::google::protobuf::RepeatedPtrField< ::TvWall::Guid >*
Packet_ElementDat_View::mutable_cameraid() {
  return &cameraid_;
}

// optional uint64 startTime = 6;
inline bool Packet_ElementDat_View::has_starttime() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Packet_ElementDat_View::set_has_starttime() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Packet_ElementDat_View::clear_has_starttime() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Packet_ElementDat_View::clear_starttime() {
  starttime_ = GOOGLE_ULONGLONG(0);
  clear_has_starttime();
}
inline ::google::protobuf::uint64 Packet_ElementDat_View::starttime() const {
  return starttime_;
}
inline void Packet_ElementDat_View::set_starttime(::google::protobuf::uint64 value) {
  set_has_starttime();
  starttime_ = value;
}

// optional bool keepStretch = 7;
inline bool Packet_ElementDat_View::has_keepstretch() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Packet_ElementDat_View::set_has_keepstretch() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Packet_ElementDat_View::clear_has_keepstretch() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Packet_ElementDat_View::clear_keepstretch() {
  keepstretch_ = false;
  clear_has_keepstretch();
}
inline bool Packet_ElementDat_View::keepstretch() const {
  return keepstretch_;
}
inline void Packet_ElementDat_View::set_keepstretch(bool value) {
  set_has_keepstretch();
  keepstretch_ = value;
}

// optional int32 borderWidth = 8;
inline bool Packet_ElementDat_View::has_borderwidth() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Packet_ElementDat_View::set_has_borderwidth() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Packet_ElementDat_View::clear_has_borderwidth() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Packet_ElementDat_View::clear_borderwidth() {
  borderwidth_ = 0;
  clear_has_borderwidth();
}
inline ::google::protobuf::int32 Packet_ElementDat_View::borderwidth() const {
  return borderwidth_;
}
inline void Packet_ElementDat_View::set_borderwidth(::google::protobuf::int32 value) {
  set_has_borderwidth();
  borderwidth_ = value;
}

// optional bool showTitle = 9;
inline bool Packet_ElementDat_View::has_showtitle() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Packet_ElementDat_View::set_has_showtitle() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Packet_ElementDat_View::clear_has_showtitle() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Packet_ElementDat_View::clear_showtitle() {
  showtitle_ = false;
  clear_has_showtitle();
}
inline bool Packet_ElementDat_View::showtitle() const {
  return showtitle_;
}
inline void Packet_ElementDat_View::set_showtitle(bool value) {
  set_has_showtitle();
  showtitle_ = value;
}

// optional string title = 10;
inline bool Packet_ElementDat_View::has_title() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Packet_ElementDat_View::set_has_title() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Packet_ElementDat_View::clear_has_title() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Packet_ElementDat_View::clear_title() {
  if (title_ != &::google::protobuf::internal::kEmptyString) {
    title_->clear();
  }
  clear_has_title();
}
inline const ::std::string& Packet_ElementDat_View::title() const {
  return *title_;
}
inline void Packet_ElementDat_View::set_title(const ::std::string& value) {
  set_has_title();
  if (title_ == &::google::protobuf::internal::kEmptyString) {
    title_ = new ::std::string;
  }
  title_->assign(value);
}
inline void Packet_ElementDat_View::set_title(const char* value) {
  set_has_title();
  if (title_ == &::google::protobuf::internal::kEmptyString) {
    title_ = new ::std::string;
  }
  title_->assign(value);
}
inline void Packet_ElementDat_View::set_title(const char* value, size_t size) {
  set_has_title();
  if (title_ == &::google::protobuf::internal::kEmptyString) {
    title_ = new ::std::string;
  }
  title_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Packet_ElementDat_View::mutable_title() {
  set_has_title();
  if (title_ == &::google::protobuf::internal::kEmptyString) {
    title_ = new ::std::string;
  }
  return title_;
}
inline ::std::string* Packet_ElementDat_View::release_title() {
  clear_has_title();
  if (title_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = title_;
    title_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Packet_ElementDat_View::set_allocated_title(::std::string* title) {
  if (title_ != &::google::protobuf::internal::kEmptyString) {
    delete title_;
  }
  if (title) {
    set_has_title();
    title_ = title;
  } else {
    clear_has_title();
    title_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 pollInterval = 11;
inline bool Packet_ElementDat_View::has_pollinterval() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Packet_ElementDat_View::set_has_pollinterval() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Packet_ElementDat_View::clear_has_pollinterval() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Packet_ElementDat_View::clear_pollinterval() {
  pollinterval_ = 0;
  clear_has_pollinterval();
}
inline ::google::protobuf::int32 Packet_ElementDat_View::pollinterval() const {
  return pollinterval_;
}
inline void Packet_ElementDat_View::set_pollinterval(::google::protobuf::int32 value) {
  set_has_pollinterval();
  pollinterval_ = value;
}

// optional int32 gpuId = 12;
inline bool Packet_ElementDat_View::has_gpuid() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Packet_ElementDat_View::set_has_gpuid() {
  _has_bits_[0] |= 0x00000800u;
}
inline void Packet_ElementDat_View::clear_has_gpuid() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void Packet_ElementDat_View::clear_gpuid() {
  gpuid_ = 0;
  clear_has_gpuid();
}
inline ::google::protobuf::int32 Packet_ElementDat_View::gpuid() const {
  return gpuid_;
}
inline void Packet_ElementDat_View::set_gpuid(::google::protobuf::int32 value) {
  set_has_gpuid();
  gpuid_ = value;
}

// optional bool showFullScreen = 13;
inline bool Packet_ElementDat_View::has_showfullscreen() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void Packet_ElementDat_View::set_has_showfullscreen() {
  _has_bits_[0] |= 0x00001000u;
}
inline void Packet_ElementDat_View::clear_has_showfullscreen() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void Packet_ElementDat_View::clear_showfullscreen() {
  showfullscreen_ = false;
  clear_has_showfullscreen();
}
inline bool Packet_ElementDat_View::showfullscreen() const {
  return showfullscreen_;
}
inline void Packet_ElementDat_View::set_showfullscreen(bool value) {
  set_has_showfullscreen();
  showfullscreen_ = value;
}

// optional int32 windowStack = 14;
inline bool Packet_ElementDat_View::has_windowstack() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void Packet_ElementDat_View::set_has_windowstack() {
  _has_bits_[0] |= 0x00002000u;
}
inline void Packet_ElementDat_View::clear_has_windowstack() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void Packet_ElementDat_View::clear_windowstack() {
  windowstack_ = 0;
  clear_has_windowstack();
}
inline ::google::protobuf::int32 Packet_ElementDat_View::windowstack() const {
  return windowstack_;
}
inline void Packet_ElementDat_View::set_windowstack(::google::protobuf::int32 value) {
  set_has_windowstack();
  windowstack_ = value;
}

// optional bool isAlarm = 15;
inline bool Packet_ElementDat_View::has_isalarm() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void Packet_ElementDat_View::set_has_isalarm() {
  _has_bits_[0] |= 0x00004000u;
}
inline void Packet_ElementDat_View::clear_has_isalarm() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void Packet_ElementDat_View::clear_isalarm() {
  isalarm_ = false;
  clear_has_isalarm();
}
inline bool Packet_ElementDat_View::isalarm() const {
  return isalarm_;
}
inline void Packet_ElementDat_View::set_isalarm(bool value) {
  set_has_isalarm();
  isalarm_ = value;
}

// optional int32 alarmInterval = 16;
inline bool Packet_ElementDat_View::has_alarminterval() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void Packet_ElementDat_View::set_has_alarminterval() {
  _has_bits_[0] |= 0x00008000u;
}
inline void Packet_ElementDat_View::clear_has_alarminterval() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void Packet_ElementDat_View::clear_alarminterval() {
  alarminterval_ = 0;
  clear_has_alarminterval();
}
inline ::google::protobuf::int32 Packet_ElementDat_View::alarminterval() const {
  return alarminterval_;
}
inline void Packet_ElementDat_View::set_alarminterval(::google::protobuf::int32 value) {
  set_has_alarminterval();
  alarminterval_ = value;
}

// optional bool showMaxFullScreen = 17;
inline bool Packet_ElementDat_View::has_showmaxfullscreen() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void Packet_ElementDat_View::set_has_showmaxfullscreen() {
  _has_bits_[0] |= 0x00010000u;
}
inline void Packet_ElementDat_View::clear_has_showmaxfullscreen() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void Packet_ElementDat_View::clear_showmaxfullscreen() {
  showmaxfullscreen_ = false;
  clear_has_showmaxfullscreen();
}
inline bool Packet_ElementDat_View::showmaxfullscreen() const {
  return showmaxfullscreen_;
}
inline void Packet_ElementDat_View::set_showmaxfullscreen(bool value) {
  set_has_showmaxfullscreen();
  showmaxfullscreen_ = value;
}

// optional bool showMinFullScreen = 18;
inline bool Packet_ElementDat_View::has_showminfullscreen() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void Packet_ElementDat_View::set_has_showminfullscreen() {
  _has_bits_[0] |= 0x00020000u;
}
inline void Packet_ElementDat_View::clear_has_showminfullscreen() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void Packet_ElementDat_View::clear_showminfullscreen() {
  showminfullscreen_ = false;
  clear_has_showminfullscreen();
}
inline bool Packet_ElementDat_View::showminfullscreen() const {
  return showminfullscreen_;
}
inline void Packet_ElementDat_View::set_showminfullscreen(bool value) {
  set_has_showminfullscreen();
  showminfullscreen_ = value;
}

// optional .TvWall.Rect fullscreenRect = 19;
inline bool Packet_ElementDat_View::has_fullscreenrect() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void Packet_ElementDat_View::set_has_fullscreenrect() {
  _has_bits_[0] |= 0x00040000u;
}
inline void Packet_ElementDat_View::clear_has_fullscreenrect() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void Packet_ElementDat_View::clear_fullscreenrect() {
  if (fullscreenrect_ != NULL) fullscreenrect_->::TvWall::Rect::Clear();
  clear_has_fullscreenrect();
}
inline const ::TvWall::Rect& Packet_ElementDat_View::fullscreenrect() const {
  return fullscreenrect_ != NULL ? *fullscreenrect_ : *default_instance_->fullscreenrect_;
}
inline ::TvWall::Rect* Packet_ElementDat_View::mutable_fullscreenrect() {
  set_has_fullscreenrect();
  if (fullscreenrect_ == NULL) fullscreenrect_ = new ::TvWall::Rect;
  return fullscreenrect_;
}
inline ::TvWall::Rect* Packet_ElementDat_View::release_fullscreenrect() {
  clear_has_fullscreenrect();
  ::TvWall::Rect* temp = fullscreenrect_;
  fullscreenrect_ = NULL;
  return temp;
}
inline void Packet_ElementDat_View::set_allocated_fullscreenrect(::TvWall::Rect* fullscreenrect) {
  delete fullscreenrect_;
  fullscreenrect_ = fullscreenrect;
  if (fullscreenrect) {
    set_has_fullscreenrect();
  } else {
    clear_has_fullscreenrect();
  }
}

// -------------------------------------------------------------------

// Packet_ElementDat_FocusPoint

// -------------------------------------------------------------------

// Packet_ElementDat_HotPoint

// required .TvWall.Rect geometry = 1;
inline bool Packet_ElementDat_HotPoint::has_geometry() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Packet_ElementDat_HotPoint::set_has_geometry() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Packet_ElementDat_HotPoint::clear_has_geometry() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Packet_ElementDat_HotPoint::clear_geometry() {
  if (geometry_ != NULL) geometry_->::TvWall::Rect::Clear();
  clear_has_geometry();
}
inline const ::TvWall::Rect& Packet_ElementDat_HotPoint::geometry() const {
  return geometry_ != NULL ? *geometry_ : *default_instance_->geometry_;
}
inline ::TvWall::Rect* Packet_ElementDat_HotPoint::mutable_geometry() {
  set_has_geometry();
  if (geometry_ == NULL) geometry_ = new ::TvWall::Rect;
  return geometry_;
}
inline ::TvWall::Rect* Packet_ElementDat_HotPoint::release_geometry() {
  clear_has_geometry();
  ::TvWall::Rect* temp = geometry_;
  geometry_ = NULL;
  return temp;
}
inline void Packet_ElementDat_HotPoint::set_allocated_geometry(::TvWall::Rect* geometry) {
  delete geometry_;
  geometry_ = geometry;
  if (geometry) {
    set_has_geometry();
  } else {
    clear_has_geometry();
  }
}

// required int32 screenIndex = 3;
inline bool Packet_ElementDat_HotPoint::has_screenindex() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Packet_ElementDat_HotPoint::set_has_screenindex() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Packet_ElementDat_HotPoint::clear_has_screenindex() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Packet_ElementDat_HotPoint::clear_screenindex() {
  screenindex_ = 0;
  clear_has_screenindex();
}
inline ::google::protobuf::int32 Packet_ElementDat_HotPoint::screenindex() const {
  return screenindex_;
}
inline void Packet_ElementDat_HotPoint::set_screenindex(::google::protobuf::int32 value) {
  set_has_screenindex();
  screenindex_ = value;
}

// required bool limitedMap = 4;
inline bool Packet_ElementDat_HotPoint::has_limitedmap() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Packet_ElementDat_HotPoint::set_has_limitedmap() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Packet_ElementDat_HotPoint::clear_has_limitedmap() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Packet_ElementDat_HotPoint::clear_limitedmap() {
  limitedmap_ = false;
  clear_has_limitedmap();
}
inline bool Packet_ElementDat_HotPoint::limitedmap() const {
  return limitedmap_;
}
inline void Packet_ElementDat_HotPoint::set_limitedmap(bool value) {
  set_has_limitedmap();
  limitedmap_ = value;
}

// required bool limitedRecord = 5;
inline bool Packet_ElementDat_HotPoint::has_limitedrecord() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Packet_ElementDat_HotPoint::set_has_limitedrecord() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Packet_ElementDat_HotPoint::clear_has_limitedrecord() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Packet_ElementDat_HotPoint::clear_limitedrecord() {
  limitedrecord_ = false;
  clear_has_limitedrecord();
}
inline bool Packet_ElementDat_HotPoint::limitedrecord() const {
  return limitedrecord_;
}
inline void Packet_ElementDat_HotPoint::set_limitedrecord(bool value) {
  set_has_limitedrecord();
  limitedrecord_ = value;
}

// -------------------------------------------------------------------

// Packet_ElementDat_ServerLayout

// required string name = 1;
inline bool Packet_ElementDat_ServerLayout::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Packet_ElementDat_ServerLayout::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Packet_ElementDat_ServerLayout::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Packet_ElementDat_ServerLayout::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& Packet_ElementDat_ServerLayout::name() const {
  return *name_;
}
inline void Packet_ElementDat_ServerLayout::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Packet_ElementDat_ServerLayout::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Packet_ElementDat_ServerLayout::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Packet_ElementDat_ServerLayout::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* Packet_ElementDat_ServerLayout::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Packet_ElementDat_ServerLayout::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required .TvWall.Packet.ElementDat layoutDat = 2;
inline bool Packet_ElementDat_ServerLayout::has_layoutdat() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Packet_ElementDat_ServerLayout::set_has_layoutdat() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Packet_ElementDat_ServerLayout::clear_has_layoutdat() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Packet_ElementDat_ServerLayout::clear_layoutdat() {
  if (layoutdat_ != NULL) layoutdat_->::TvWall::Packet_ElementDat::Clear();
  clear_has_layoutdat();
}
inline const ::TvWall::Packet_ElementDat& Packet_ElementDat_ServerLayout::layoutdat() const {
  return layoutdat_ != NULL ? *layoutdat_ : *default_instance_->layoutdat_;
}
inline ::TvWall::Packet_ElementDat* Packet_ElementDat_ServerLayout::mutable_layoutdat() {
  set_has_layoutdat();
  if (layoutdat_ == NULL) layoutdat_ = new ::TvWall::Packet_ElementDat;
  return layoutdat_;
}
inline ::TvWall::Packet_ElementDat* Packet_ElementDat_ServerLayout::release_layoutdat() {
  clear_has_layoutdat();
  ::TvWall::Packet_ElementDat* temp = layoutdat_;
  layoutdat_ = NULL;
  return temp;
}
inline void Packet_ElementDat_ServerLayout::set_allocated_layoutdat(::TvWall::Packet_ElementDat* layoutdat) {
  delete layoutdat_;
  layoutdat_ = layoutdat;
  if (layoutdat) {
    set_has_layoutdat();
  } else {
    clear_has_layoutdat();
  }
}

// -------------------------------------------------------------------

// Packet_ElementDat_ServerLayoutLoop

// required string name = 1;
inline bool Packet_ElementDat_ServerLayoutLoop::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Packet_ElementDat_ServerLayoutLoop::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Packet_ElementDat_ServerLayoutLoop::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Packet_ElementDat_ServerLayoutLoop::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& Packet_ElementDat_ServerLayoutLoop::name() const {
  return *name_;
}
inline void Packet_ElementDat_ServerLayoutLoop::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Packet_ElementDat_ServerLayoutLoop::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Packet_ElementDat_ServerLayoutLoop::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Packet_ElementDat_ServerLayoutLoop::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* Packet_ElementDat_ServerLayoutLoop::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Packet_ElementDat_ServerLayoutLoop::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required uint32 pollInterval = 2;
inline bool Packet_ElementDat_ServerLayoutLoop::has_pollinterval() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Packet_ElementDat_ServerLayoutLoop::set_has_pollinterval() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Packet_ElementDat_ServerLayoutLoop::clear_has_pollinterval() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Packet_ElementDat_ServerLayoutLoop::clear_pollinterval() {
  pollinterval_ = 0u;
  clear_has_pollinterval();
}
inline ::google::protobuf::uint32 Packet_ElementDat_ServerLayoutLoop::pollinterval() const {
  return pollinterval_;
}
inline void Packet_ElementDat_ServerLayoutLoop::set_pollinterval(::google::protobuf::uint32 value) {
  set_has_pollinterval();
  pollinterval_ = value;
}

// repeated string layoutName = 3;
inline int Packet_ElementDat_ServerLayoutLoop::layoutname_size() const {
  return layoutname_.size();
}
inline void Packet_ElementDat_ServerLayoutLoop::clear_layoutname() {
  layoutname_.Clear();
}
inline const ::std::string& Packet_ElementDat_ServerLayoutLoop::layoutname(int index) const {
  return layoutname_.Get(index);
}
inline ::std::string* Packet_ElementDat_ServerLayoutLoop::mutable_layoutname(int index) {
  return layoutname_.Mutable(index);
}
inline void Packet_ElementDat_ServerLayoutLoop::set_layoutname(int index, const ::std::string& value) {
  layoutname_.Mutable(index)->assign(value);
}
inline void Packet_ElementDat_ServerLayoutLoop::set_layoutname(int index, const char* value) {
  layoutname_.Mutable(index)->assign(value);
}
inline void Packet_ElementDat_ServerLayoutLoop::set_layoutname(int index, const char* value, size_t size) {
  layoutname_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Packet_ElementDat_ServerLayoutLoop::add_layoutname() {
  return layoutname_.Add();
}
inline void Packet_ElementDat_ServerLayoutLoop::add_layoutname(const ::std::string& value) {
  layoutname_.Add()->assign(value);
}
inline void Packet_ElementDat_ServerLayoutLoop::add_layoutname(const char* value) {
  layoutname_.Add()->assign(value);
}
inline void Packet_ElementDat_ServerLayoutLoop::add_layoutname(const char* value, size_t size) {
  layoutname_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Packet_ElementDat_ServerLayoutLoop::layoutname() const {
  return layoutname_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Packet_ElementDat_ServerLayoutLoop::mutable_layoutname() {
  return &layoutname_;
}

// -------------------------------------------------------------------

// Packet_ElementDat_Map

// required string mapUrl = 1;
inline bool Packet_ElementDat_Map::has_mapurl() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Packet_ElementDat_Map::set_has_mapurl() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Packet_ElementDat_Map::clear_has_mapurl() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Packet_ElementDat_Map::clear_mapurl() {
  if (mapurl_ != &::google::protobuf::internal::kEmptyString) {
    mapurl_->clear();
  }
  clear_has_mapurl();
}
inline const ::std::string& Packet_ElementDat_Map::mapurl() const {
  return *mapurl_;
}
inline void Packet_ElementDat_Map::set_mapurl(const ::std::string& value) {
  set_has_mapurl();
  if (mapurl_ == &::google::protobuf::internal::kEmptyString) {
    mapurl_ = new ::std::string;
  }
  mapurl_->assign(value);
}
inline void Packet_ElementDat_Map::set_mapurl(const char* value) {
  set_has_mapurl();
  if (mapurl_ == &::google::protobuf::internal::kEmptyString) {
    mapurl_ = new ::std::string;
  }
  mapurl_->assign(value);
}
inline void Packet_ElementDat_Map::set_mapurl(const char* value, size_t size) {
  set_has_mapurl();
  if (mapurl_ == &::google::protobuf::internal::kEmptyString) {
    mapurl_ = new ::std::string;
  }
  mapurl_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Packet_ElementDat_Map::mutable_mapurl() {
  set_has_mapurl();
  if (mapurl_ == &::google::protobuf::internal::kEmptyString) {
    mapurl_ = new ::std::string;
  }
  return mapurl_;
}
inline ::std::string* Packet_ElementDat_Map::release_mapurl() {
  clear_has_mapurl();
  if (mapurl_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = mapurl_;
    mapurl_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Packet_ElementDat_Map::set_allocated_mapurl(::std::string* mapurl) {
  if (mapurl_ != &::google::protobuf::internal::kEmptyString) {
    delete mapurl_;
  }
  if (mapurl) {
    set_has_mapurl();
    mapurl_ = mapurl;
  } else {
    clear_has_mapurl();
    mapurl_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .TvWall.Packet.ElementDat.Map map = 2;
inline int Packet_ElementDat_Map::map_size() const {
  return map_.size();
}
inline void Packet_ElementDat_Map::clear_map() {
  map_.Clear();
}
inline const ::TvWall::Packet_ElementDat_Map& Packet_ElementDat_Map::map(int index) const {
  return map_.Get(index);
}
inline ::TvWall::Packet_ElementDat_Map* Packet_ElementDat_Map::mutable_map(int index) {
  return map_.Mutable(index);
}
inline ::TvWall::Packet_ElementDat_Map* Packet_ElementDat_Map::add_map() {
  return map_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TvWall::Packet_ElementDat_Map >&
Packet_ElementDat_Map::map() const {
  return map_;
}
inline ::google::protobuf::RepeatedPtrField< ::TvWall::Packet_ElementDat_Map >*
Packet_ElementDat_Map::mutable_map() {
  return &map_;
}

// -------------------------------------------------------------------

// Packet_ElementDat_GroupLoop

// repeated .TvWall.Packet.ElementDat.View views = 1;
inline int Packet_ElementDat_GroupLoop::views_size() const {
  return views_.size();
}
inline void Packet_ElementDat_GroupLoop::clear_views() {
  views_.Clear();
}
inline const ::TvWall::Packet_ElementDat_View& Packet_ElementDat_GroupLoop::views(int index) const {
  return views_.Get(index);
}
inline ::TvWall::Packet_ElementDat_View* Packet_ElementDat_GroupLoop::mutable_views(int index) {
  return views_.Mutable(index);
}
inline ::TvWall::Packet_ElementDat_View* Packet_ElementDat_GroupLoop::add_views() {
  return views_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TvWall::Packet_ElementDat_View >&
Packet_ElementDat_GroupLoop::views() const {
  return views_;
}
inline ::google::protobuf::RepeatedPtrField< ::TvWall::Packet_ElementDat_View >*
Packet_ElementDat_GroupLoop::mutable_views() {
  return &views_;
}

// required uint32 pollInterval = 2;
inline bool Packet_ElementDat_GroupLoop::has_pollinterval() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Packet_ElementDat_GroupLoop::set_has_pollinterval() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Packet_ElementDat_GroupLoop::clear_has_pollinterval() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Packet_ElementDat_GroupLoop::clear_pollinterval() {
  pollinterval_ = 0u;
  clear_has_pollinterval();
}
inline ::google::protobuf::uint32 Packet_ElementDat_GroupLoop::pollinterval() const {
  return pollinterval_;
}
inline void Packet_ElementDat_GroupLoop::set_pollinterval(::google::protobuf::uint32 value) {
  set_has_pollinterval();
  pollinterval_ = value;
}

// optional bool isOn = 3;
inline bool Packet_ElementDat_GroupLoop::has_ison() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Packet_ElementDat_GroupLoop::set_has_ison() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Packet_ElementDat_GroupLoop::clear_has_ison() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Packet_ElementDat_GroupLoop::clear_ison() {
  ison_ = false;
  clear_has_ison();
}
inline bool Packet_ElementDat_GroupLoop::ison() const {
  return ison_;
}
inline void Packet_ElementDat_GroupLoop::set_ison(bool value) {
  set_has_ison();
  ison_ = value;
}

// -------------------------------------------------------------------

// Packet_ElementDat

// repeated .TvWall.Packet.ElementDat.Screen screen = 1;
inline int Packet_ElementDat::screen_size() const {
  return screen_.size();
}
inline void Packet_ElementDat::clear_screen() {
  screen_.Clear();
}
inline const ::TvWall::Packet_ElementDat_Screen& Packet_ElementDat::screen(int index) const {
  return screen_.Get(index);
}
inline ::TvWall::Packet_ElementDat_Screen* Packet_ElementDat::mutable_screen(int index) {
  return screen_.Mutable(index);
}
inline ::TvWall::Packet_ElementDat_Screen* Packet_ElementDat::add_screen() {
  return screen_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TvWall::Packet_ElementDat_Screen >&
Packet_ElementDat::screen() const {
  return screen_;
}
inline ::google::protobuf::RepeatedPtrField< ::TvWall::Packet_ElementDat_Screen >*
Packet_ElementDat::mutable_screen() {
  return &screen_;
}

// repeated .TvWall.Packet.ElementDat.View view = 2;
inline int Packet_ElementDat::view_size() const {
  return view_.size();
}
inline void Packet_ElementDat::clear_view() {
  view_.Clear();
}
inline const ::TvWall::Packet_ElementDat_View& Packet_ElementDat::view(int index) const {
  return view_.Get(index);
}
inline ::TvWall::Packet_ElementDat_View* Packet_ElementDat::mutable_view(int index) {
  return view_.Mutable(index);
}
inline ::TvWall::Packet_ElementDat_View* Packet_ElementDat::add_view() {
  return view_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TvWall::Packet_ElementDat_View >&
Packet_ElementDat::view() const {
  return view_;
}
inline ::google::protobuf::RepeatedPtrField< ::TvWall::Packet_ElementDat_View >*
Packet_ElementDat::mutable_view() {
  return &view_;
}

// repeated .TvWall.Packet.ElementDat.CameraGrp camGrp = 3;
inline int Packet_ElementDat::camgrp_size() const {
  return camgrp_.size();
}
inline void Packet_ElementDat::clear_camgrp() {
  camgrp_.Clear();
}
inline const ::TvWall::Packet_ElementDat_CameraGrp& Packet_ElementDat::camgrp(int index) const {
  return camgrp_.Get(index);
}
inline ::TvWall::Packet_ElementDat_CameraGrp* Packet_ElementDat::mutable_camgrp(int index) {
  return camgrp_.Mutable(index);
}
inline ::TvWall::Packet_ElementDat_CameraGrp* Packet_ElementDat::add_camgrp() {
  return camgrp_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TvWall::Packet_ElementDat_CameraGrp >&
Packet_ElementDat::camgrp() const {
  return camgrp_;
}
inline ::google::protobuf::RepeatedPtrField< ::TvWall::Packet_ElementDat_CameraGrp >*
Packet_ElementDat::mutable_camgrp() {
  return &camgrp_;
}

// optional .TvWall.Packet.ElementDat.HotPoint hotPoint = 4;
inline bool Packet_ElementDat::has_hotpoint() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Packet_ElementDat::set_has_hotpoint() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Packet_ElementDat::clear_has_hotpoint() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Packet_ElementDat::clear_hotpoint() {
  if (hotpoint_ != NULL) hotpoint_->::TvWall::Packet_ElementDat_HotPoint::Clear();
  clear_has_hotpoint();
}
inline const ::TvWall::Packet_ElementDat_HotPoint& Packet_ElementDat::hotpoint() const {
  return hotpoint_ != NULL ? *hotpoint_ : *default_instance_->hotpoint_;
}
inline ::TvWall::Packet_ElementDat_HotPoint* Packet_ElementDat::mutable_hotpoint() {
  set_has_hotpoint();
  if (hotpoint_ == NULL) hotpoint_ = new ::TvWall::Packet_ElementDat_HotPoint;
  return hotpoint_;
}
inline ::TvWall::Packet_ElementDat_HotPoint* Packet_ElementDat::release_hotpoint() {
  clear_has_hotpoint();
  ::TvWall::Packet_ElementDat_HotPoint* temp = hotpoint_;
  hotpoint_ = NULL;
  return temp;
}
inline void Packet_ElementDat::set_allocated_hotpoint(::TvWall::Packet_ElementDat_HotPoint* hotpoint) {
  delete hotpoint_;
  hotpoint_ = hotpoint;
  if (hotpoint) {
    set_has_hotpoint();
  } else {
    clear_has_hotpoint();
  }
}

// repeated .TvWall.Packet.ElementDat.LocalMovie localMovie = 5;
inline int Packet_ElementDat::localmovie_size() const {
  return localmovie_.size();
}
inline void Packet_ElementDat::clear_localmovie() {
  localmovie_.Clear();
}
inline const ::TvWall::Packet_ElementDat_LocalMovie& Packet_ElementDat::localmovie(int index) const {
  return localmovie_.Get(index);
}
inline ::TvWall::Packet_ElementDat_LocalMovie* Packet_ElementDat::mutable_localmovie(int index) {
  return localmovie_.Mutable(index);
}
inline ::TvWall::Packet_ElementDat_LocalMovie* Packet_ElementDat::add_localmovie() {
  return localmovie_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TvWall::Packet_ElementDat_LocalMovie >&
Packet_ElementDat::localmovie() const {
  return localmovie_;
}
inline ::google::protobuf::RepeatedPtrField< ::TvWall::Packet_ElementDat_LocalMovie >*
Packet_ElementDat::mutable_localmovie() {
  return &localmovie_;
}

// repeated .TvWall.Packet.ElementDat.Flash flash = 6;
inline int Packet_ElementDat::flash_size() const {
  return flash_.size();
}
inline void Packet_ElementDat::clear_flash() {
  flash_.Clear();
}
inline const ::TvWall::Packet_ElementDat_Flash& Packet_ElementDat::flash(int index) const {
  return flash_.Get(index);
}
inline ::TvWall::Packet_ElementDat_Flash* Packet_ElementDat::mutable_flash(int index) {
  return flash_.Mutable(index);
}
inline ::TvWall::Packet_ElementDat_Flash* Packet_ElementDat::add_flash() {
  return flash_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TvWall::Packet_ElementDat_Flash >&
Packet_ElementDat::flash() const {
  return flash_;
}
inline ::google::protobuf::RepeatedPtrField< ::TvWall::Packet_ElementDat_Flash >*
Packet_ElementDat::mutable_flash() {
  return &flash_;
}

// required string serverName = 7;
inline bool Packet_ElementDat::has_servername() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Packet_ElementDat::set_has_servername() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Packet_ElementDat::clear_has_servername() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Packet_ElementDat::clear_servername() {
  if (servername_ != &::google::protobuf::internal::kEmptyString) {
    servername_->clear();
  }
  clear_has_servername();
}
inline const ::std::string& Packet_ElementDat::servername() const {
  return *servername_;
}
inline void Packet_ElementDat::set_servername(const ::std::string& value) {
  set_has_servername();
  if (servername_ == &::google::protobuf::internal::kEmptyString) {
    servername_ = new ::std::string;
  }
  servername_->assign(value);
}
inline void Packet_ElementDat::set_servername(const char* value) {
  set_has_servername();
  if (servername_ == &::google::protobuf::internal::kEmptyString) {
    servername_ = new ::std::string;
  }
  servername_->assign(value);
}
inline void Packet_ElementDat::set_servername(const char* value, size_t size) {
  set_has_servername();
  if (servername_ == &::google::protobuf::internal::kEmptyString) {
    servername_ = new ::std::string;
  }
  servername_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Packet_ElementDat::mutable_servername() {
  set_has_servername();
  if (servername_ == &::google::protobuf::internal::kEmptyString) {
    servername_ = new ::std::string;
  }
  return servername_;
}
inline ::std::string* Packet_ElementDat::release_servername() {
  clear_has_servername();
  if (servername_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = servername_;
    servername_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Packet_ElementDat::set_allocated_servername(::std::string* servername) {
  if (servername_ != &::google::protobuf::internal::kEmptyString) {
    delete servername_;
  }
  if (servername) {
    set_has_servername();
    servername_ = servername;
  } else {
    clear_has_servername();
    servername_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .TvWall.Packet.ElementDat.ServerLayout servLayout = 8;
inline int Packet_ElementDat::servlayout_size() const {
  return servlayout_.size();
}
inline void Packet_ElementDat::clear_servlayout() {
  servlayout_.Clear();
}
inline const ::TvWall::Packet_ElementDat_ServerLayout& Packet_ElementDat::servlayout(int index) const {
  return servlayout_.Get(index);
}
inline ::TvWall::Packet_ElementDat_ServerLayout* Packet_ElementDat::mutable_servlayout(int index) {
  return servlayout_.Mutable(index);
}
inline ::TvWall::Packet_ElementDat_ServerLayout* Packet_ElementDat::add_servlayout() {
  return servlayout_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TvWall::Packet_ElementDat_ServerLayout >&
Packet_ElementDat::servlayout() const {
  return servlayout_;
}
inline ::google::protobuf::RepeatedPtrField< ::TvWall::Packet_ElementDat_ServerLayout >*
Packet_ElementDat::mutable_servlayout() {
  return &servlayout_;
}

// optional .TvWall.Guid guid = 9;
inline bool Packet_ElementDat::has_guid() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Packet_ElementDat::set_has_guid() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Packet_ElementDat::clear_has_guid() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Packet_ElementDat::clear_guid() {
  if (guid_ != NULL) guid_->::TvWall::Guid::Clear();
  clear_has_guid();
}
inline const ::TvWall::Guid& Packet_ElementDat::guid() const {
  return guid_ != NULL ? *guid_ : *default_instance_->guid_;
}
inline ::TvWall::Guid* Packet_ElementDat::mutable_guid() {
  set_has_guid();
  if (guid_ == NULL) guid_ = new ::TvWall::Guid;
  return guid_;
}
inline ::TvWall::Guid* Packet_ElementDat::release_guid() {
  clear_has_guid();
  ::TvWall::Guid* temp = guid_;
  guid_ = NULL;
  return temp;
}
inline void Packet_ElementDat::set_allocated_guid(::TvWall::Guid* guid) {
  delete guid_;
  guid_ = guid;
  if (guid) {
    set_has_guid();
  } else {
    clear_has_guid();
  }
}

// repeated .TvWall.Packet.ElementDat.Map map = 10;
inline int Packet_ElementDat::map_size() const {
  return map_.size();
}
inline void Packet_ElementDat::clear_map() {
  map_.Clear();
}
inline const ::TvWall::Packet_ElementDat_Map& Packet_ElementDat::map(int index) const {
  return map_.Get(index);
}
inline ::TvWall::Packet_ElementDat_Map* Packet_ElementDat::mutable_map(int index) {
  return map_.Mutable(index);
}
inline ::TvWall::Packet_ElementDat_Map* Packet_ElementDat::add_map() {
  return map_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TvWall::Packet_ElementDat_Map >&
Packet_ElementDat::map() const {
  return map_;
}
inline ::google::protobuf::RepeatedPtrField< ::TvWall::Packet_ElementDat_Map >*
Packet_ElementDat::mutable_map() {
  return &map_;
}

// optional string currentLayout = 11;
inline bool Packet_ElementDat::has_currentlayout() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Packet_ElementDat::set_has_currentlayout() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Packet_ElementDat::clear_has_currentlayout() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Packet_ElementDat::clear_currentlayout() {
  if (currentlayout_ != &::google::protobuf::internal::kEmptyString) {
    currentlayout_->clear();
  }
  clear_has_currentlayout();
}
inline const ::std::string& Packet_ElementDat::currentlayout() const {
  return *currentlayout_;
}
inline void Packet_ElementDat::set_currentlayout(const ::std::string& value) {
  set_has_currentlayout();
  if (currentlayout_ == &::google::protobuf::internal::kEmptyString) {
    currentlayout_ = new ::std::string;
  }
  currentlayout_->assign(value);
}
inline void Packet_ElementDat::set_currentlayout(const char* value) {
  set_has_currentlayout();
  if (currentlayout_ == &::google::protobuf::internal::kEmptyString) {
    currentlayout_ = new ::std::string;
  }
  currentlayout_->assign(value);
}
inline void Packet_ElementDat::set_currentlayout(const char* value, size_t size) {
  set_has_currentlayout();
  if (currentlayout_ == &::google::protobuf::internal::kEmptyString) {
    currentlayout_ = new ::std::string;
  }
  currentlayout_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Packet_ElementDat::mutable_currentlayout() {
  set_has_currentlayout();
  if (currentlayout_ == &::google::protobuf::internal::kEmptyString) {
    currentlayout_ = new ::std::string;
  }
  return currentlayout_;
}
inline ::std::string* Packet_ElementDat::release_currentlayout() {
  clear_has_currentlayout();
  if (currentlayout_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = currentlayout_;
    currentlayout_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Packet_ElementDat::set_allocated_currentlayout(::std::string* currentlayout) {
  if (currentlayout_ != &::google::protobuf::internal::kEmptyString) {
    delete currentlayout_;
  }
  if (currentlayout) {
    set_has_currentlayout();
    currentlayout_ = currentlayout;
  } else {
    clear_has_currentlayout();
    currentlayout_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .TvWall.Packet.ElementDat.ServerLayoutLoop servLayoutLoop = 12;
inline int Packet_ElementDat::servlayoutloop_size() const {
  return servlayoutloop_.size();
}
inline void Packet_ElementDat::clear_servlayoutloop() {
  servlayoutloop_.Clear();
}
inline const ::TvWall::Packet_ElementDat_ServerLayoutLoop& Packet_ElementDat::servlayoutloop(int index) const {
  return servlayoutloop_.Get(index);
}
inline ::TvWall::Packet_ElementDat_ServerLayoutLoop* Packet_ElementDat::mutable_servlayoutloop(int index) {
  return servlayoutloop_.Mutable(index);
}
inline ::TvWall::Packet_ElementDat_ServerLayoutLoop* Packet_ElementDat::add_servlayoutloop() {
  return servlayoutloop_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TvWall::Packet_ElementDat_ServerLayoutLoop >&
Packet_ElementDat::servlayoutloop() const {
  return servlayoutloop_;
}
inline ::google::protobuf::RepeatedPtrField< ::TvWall::Packet_ElementDat_ServerLayoutLoop >*
Packet_ElementDat::mutable_servlayoutloop() {
  return &servlayoutloop_;
}

// optional string currentLayoutLoop = 13;
inline bool Packet_ElementDat::has_currentlayoutloop() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void Packet_ElementDat::set_has_currentlayoutloop() {
  _has_bits_[0] |= 0x00001000u;
}
inline void Packet_ElementDat::clear_has_currentlayoutloop() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void Packet_ElementDat::clear_currentlayoutloop() {
  if (currentlayoutloop_ != &::google::protobuf::internal::kEmptyString) {
    currentlayoutloop_->clear();
  }
  clear_has_currentlayoutloop();
}
inline const ::std::string& Packet_ElementDat::currentlayoutloop() const {
  return *currentlayoutloop_;
}
inline void Packet_ElementDat::set_currentlayoutloop(const ::std::string& value) {
  set_has_currentlayoutloop();
  if (currentlayoutloop_ == &::google::protobuf::internal::kEmptyString) {
    currentlayoutloop_ = new ::std::string;
  }
  currentlayoutloop_->assign(value);
}
inline void Packet_ElementDat::set_currentlayoutloop(const char* value) {
  set_has_currentlayoutloop();
  if (currentlayoutloop_ == &::google::protobuf::internal::kEmptyString) {
    currentlayoutloop_ = new ::std::string;
  }
  currentlayoutloop_->assign(value);
}
inline void Packet_ElementDat::set_currentlayoutloop(const char* value, size_t size) {
  set_has_currentlayoutloop();
  if (currentlayoutloop_ == &::google::protobuf::internal::kEmptyString) {
    currentlayoutloop_ = new ::std::string;
  }
  currentlayoutloop_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Packet_ElementDat::mutable_currentlayoutloop() {
  set_has_currentlayoutloop();
  if (currentlayoutloop_ == &::google::protobuf::internal::kEmptyString) {
    currentlayoutloop_ = new ::std::string;
  }
  return currentlayoutloop_;
}
inline ::std::string* Packet_ElementDat::release_currentlayoutloop() {
  clear_has_currentlayoutloop();
  if (currentlayoutloop_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = currentlayoutloop_;
    currentlayoutloop_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Packet_ElementDat::set_allocated_currentlayoutloop(::std::string* currentlayoutloop) {
  if (currentlayoutloop_ != &::google::protobuf::internal::kEmptyString) {
    delete currentlayoutloop_;
  }
  if (currentlayoutloop) {
    set_has_currentlayoutloop();
    currentlayoutloop_ = currentlayoutloop;
  } else {
    clear_has_currentlayoutloop();
    currentlayoutloop_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .TvWall.NVR nvrLst = 14;
inline int Packet_ElementDat::nvrlst_size() const {
  return nvrlst_.size();
}
inline void Packet_ElementDat::clear_nvrlst() {
  nvrlst_.Clear();
}
inline const ::TvWall::NVR& Packet_ElementDat::nvrlst(int index) const {
  return nvrlst_.Get(index);
}
inline ::TvWall::NVR* Packet_ElementDat::mutable_nvrlst(int index) {
  return nvrlst_.Mutable(index);
}
inline ::TvWall::NVR* Packet_ElementDat::add_nvrlst() {
  return nvrlst_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TvWall::NVR >&
Packet_ElementDat::nvrlst() const {
  return nvrlst_;
}
inline ::google::protobuf::RepeatedPtrField< ::TvWall::NVR >*
Packet_ElementDat::mutable_nvrlst() {
  return &nvrlst_;
}

// optional .TvWall.Packet.ElementDat.GroupLoop groupLoop = 15;
inline bool Packet_ElementDat::has_grouploop() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void Packet_ElementDat::set_has_grouploop() {
  _has_bits_[0] |= 0x00004000u;
}
inline void Packet_ElementDat::clear_has_grouploop() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void Packet_ElementDat::clear_grouploop() {
  if (grouploop_ != NULL) grouploop_->::TvWall::Packet_ElementDat_GroupLoop::Clear();
  clear_has_grouploop();
}
inline const ::TvWall::Packet_ElementDat_GroupLoop& Packet_ElementDat::grouploop() const {
  return grouploop_ != NULL ? *grouploop_ : *default_instance_->grouploop_;
}
inline ::TvWall::Packet_ElementDat_GroupLoop* Packet_ElementDat::mutable_grouploop() {
  set_has_grouploop();
  if (grouploop_ == NULL) grouploop_ = new ::TvWall::Packet_ElementDat_GroupLoop;
  return grouploop_;
}
inline ::TvWall::Packet_ElementDat_GroupLoop* Packet_ElementDat::release_grouploop() {
  clear_has_grouploop();
  ::TvWall::Packet_ElementDat_GroupLoop* temp = grouploop_;
  grouploop_ = NULL;
  return temp;
}
inline void Packet_ElementDat::set_allocated_grouploop(::TvWall::Packet_ElementDat_GroupLoop* grouploop) {
  delete grouploop_;
  grouploop_ = grouploop;
  if (grouploop) {
    set_has_grouploop();
  } else {
    clear_has_grouploop();
  }
}

// optional uint32 maxPlaybackRate = 16;
inline bool Packet_ElementDat::has_maxplaybackrate() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void Packet_ElementDat::set_has_maxplaybackrate() {
  _has_bits_[0] |= 0x00008000u;
}
inline void Packet_ElementDat::clear_has_maxplaybackrate() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void Packet_ElementDat::clear_maxplaybackrate() {
  maxplaybackrate_ = 0u;
  clear_has_maxplaybackrate();
}
inline ::google::protobuf::uint32 Packet_ElementDat::maxplaybackrate() const {
  return maxplaybackrate_;
}
inline void Packet_ElementDat::set_maxplaybackrate(::google::protobuf::uint32 value) {
  set_has_maxplaybackrate();
  maxplaybackrate_ = value;
}

// optional .TvWall.FMP fmp = 17;
inline bool Packet_ElementDat::has_fmp() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void Packet_ElementDat::set_has_fmp() {
  _has_bits_[0] |= 0x00010000u;
}
inline void Packet_ElementDat::clear_has_fmp() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void Packet_ElementDat::clear_fmp() {
  if (fmp_ != NULL) fmp_->::TvWall::FMP::Clear();
  clear_has_fmp();
}
inline const ::TvWall::FMP& Packet_ElementDat::fmp() const {
  return fmp_ != NULL ? *fmp_ : *default_instance_->fmp_;
}
inline ::TvWall::FMP* Packet_ElementDat::mutable_fmp() {
  set_has_fmp();
  if (fmp_ == NULL) fmp_ = new ::TvWall::FMP;
  return fmp_;
}
inline ::TvWall::FMP* Packet_ElementDat::release_fmp() {
  clear_has_fmp();
  ::TvWall::FMP* temp = fmp_;
  fmp_ = NULL;
  return temp;
}
inline void Packet_ElementDat::set_allocated_fmp(::TvWall::FMP* fmp) {
  delete fmp_;
  fmp_ = fmp;
  if (fmp) {
    set_has_fmp();
  } else {
    clear_has_fmp();
  }
}

// optional int32 tvwallindex = 18;
inline bool Packet_ElementDat::has_tvwallindex() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void Packet_ElementDat::set_has_tvwallindex() {
  _has_bits_[0] |= 0x00020000u;
}
inline void Packet_ElementDat::clear_has_tvwallindex() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void Packet_ElementDat::clear_tvwallindex() {
  tvwallindex_ = 0;
  clear_has_tvwallindex();
}
inline ::google::protobuf::int32 Packet_ElementDat::tvwallindex() const {
  return tvwallindex_;
}
inline void Packet_ElementDat::set_tvwallindex(::google::protobuf::int32 value) {
  set_has_tvwallindex();
  tvwallindex_ = value;
}

// optional string anoleVersion = 19;
inline bool Packet_ElementDat::has_anoleversion() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void Packet_ElementDat::set_has_anoleversion() {
  _has_bits_[0] |= 0x00040000u;
}
inline void Packet_ElementDat::clear_has_anoleversion() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void Packet_ElementDat::clear_anoleversion() {
  if (anoleversion_ != &::google::protobuf::internal::kEmptyString) {
    anoleversion_->clear();
  }
  clear_has_anoleversion();
}
inline const ::std::string& Packet_ElementDat::anoleversion() const {
  return *anoleversion_;
}
inline void Packet_ElementDat::set_anoleversion(const ::std::string& value) {
  set_has_anoleversion();
  if (anoleversion_ == &::google::protobuf::internal::kEmptyString) {
    anoleversion_ = new ::std::string;
  }
  anoleversion_->assign(value);
}
inline void Packet_ElementDat::set_anoleversion(const char* value) {
  set_has_anoleversion();
  if (anoleversion_ == &::google::protobuf::internal::kEmptyString) {
    anoleversion_ = new ::std::string;
  }
  anoleversion_->assign(value);
}
inline void Packet_ElementDat::set_anoleversion(const char* value, size_t size) {
  set_has_anoleversion();
  if (anoleversion_ == &::google::protobuf::internal::kEmptyString) {
    anoleversion_ = new ::std::string;
  }
  anoleversion_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Packet_ElementDat::mutable_anoleversion() {
  set_has_anoleversion();
  if (anoleversion_ == &::google::protobuf::internal::kEmptyString) {
    anoleversion_ = new ::std::string;
  }
  return anoleversion_;
}
inline ::std::string* Packet_ElementDat::release_anoleversion() {
  clear_has_anoleversion();
  if (anoleversion_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = anoleversion_;
    anoleversion_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Packet_ElementDat::set_allocated_anoleversion(::std::string* anoleversion) {
  if (anoleversion_ != &::google::protobuf::internal::kEmptyString) {
    delete anoleversion_;
  }
  if (anoleversion) {
    set_has_anoleversion();
    anoleversion_ = anoleversion;
  } else {
    clear_has_anoleversion();
    anoleversion_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string SN = 20;
inline bool Packet_ElementDat::has_sn() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void Packet_ElementDat::set_has_sn() {
  _has_bits_[0] |= 0x00080000u;
}
inline void Packet_ElementDat::clear_has_sn() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void Packet_ElementDat::clear_sn() {
  if (sn_ != &::google::protobuf::internal::kEmptyString) {
    sn_->clear();
  }
  clear_has_sn();
}
inline const ::std::string& Packet_ElementDat::sn() const {
  return *sn_;
}
inline void Packet_ElementDat::set_sn(const ::std::string& value) {
  set_has_sn();
  if (sn_ == &::google::protobuf::internal::kEmptyString) {
    sn_ = new ::std::string;
  }
  sn_->assign(value);
}
inline void Packet_ElementDat::set_sn(const char* value) {
  set_has_sn();
  if (sn_ == &::google::protobuf::internal::kEmptyString) {
    sn_ = new ::std::string;
  }
  sn_->assign(value);
}
inline void Packet_ElementDat::set_sn(const char* value, size_t size) {
  set_has_sn();
  if (sn_ == &::google::protobuf::internal::kEmptyString) {
    sn_ = new ::std::string;
  }
  sn_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Packet_ElementDat::mutable_sn() {
  set_has_sn();
  if (sn_ == &::google::protobuf::internal::kEmptyString) {
    sn_ = new ::std::string;
  }
  return sn_;
}
inline ::std::string* Packet_ElementDat::release_sn() {
  clear_has_sn();
  if (sn_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sn_;
    sn_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Packet_ElementDat::set_allocated_sn(::std::string* sn) {
  if (sn_ != &::google::protobuf::internal::kEmptyString) {
    delete sn_;
  }
  if (sn) {
    set_has_sn();
    sn_ = sn;
  } else {
    clear_has_sn();
    sn_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// Packet_ElementMaster_MasterLayout_ServerPos

// optional string serverName = 1;
inline bool Packet_ElementMaster_MasterLayout_ServerPos::has_servername() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Packet_ElementMaster_MasterLayout_ServerPos::set_has_servername() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Packet_ElementMaster_MasterLayout_ServerPos::clear_has_servername() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Packet_ElementMaster_MasterLayout_ServerPos::clear_servername() {
  if (servername_ != &::google::protobuf::internal::kEmptyString) {
    servername_->clear();
  }
  clear_has_servername();
}
inline const ::std::string& Packet_ElementMaster_MasterLayout_ServerPos::servername() const {
  return *servername_;
}
inline void Packet_ElementMaster_MasterLayout_ServerPos::set_servername(const ::std::string& value) {
  set_has_servername();
  if (servername_ == &::google::protobuf::internal::kEmptyString) {
    servername_ = new ::std::string;
  }
  servername_->assign(value);
}
inline void Packet_ElementMaster_MasterLayout_ServerPos::set_servername(const char* value) {
  set_has_servername();
  if (servername_ == &::google::protobuf::internal::kEmptyString) {
    servername_ = new ::std::string;
  }
  servername_->assign(value);
}
inline void Packet_ElementMaster_MasterLayout_ServerPos::set_servername(const char* value, size_t size) {
  set_has_servername();
  if (servername_ == &::google::protobuf::internal::kEmptyString) {
    servername_ = new ::std::string;
  }
  servername_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Packet_ElementMaster_MasterLayout_ServerPos::mutable_servername() {
  set_has_servername();
  if (servername_ == &::google::protobuf::internal::kEmptyString) {
    servername_ = new ::std::string;
  }
  return servername_;
}
inline ::std::string* Packet_ElementMaster_MasterLayout_ServerPos::release_servername() {
  clear_has_servername();
  if (servername_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = servername_;
    servername_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Packet_ElementMaster_MasterLayout_ServerPos::set_allocated_servername(::std::string* servername) {
  if (servername_ != &::google::protobuf::internal::kEmptyString) {
    delete servername_;
  }
  if (servername) {
    set_has_servername();
    servername_ = servername;
  } else {
    clear_has_servername();
    servername_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required .TvWall.Guid guid = 2;
inline bool Packet_ElementMaster_MasterLayout_ServerPos::has_guid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Packet_ElementMaster_MasterLayout_ServerPos::set_has_guid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Packet_ElementMaster_MasterLayout_ServerPos::clear_has_guid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Packet_ElementMaster_MasterLayout_ServerPos::clear_guid() {
  if (guid_ != NULL) guid_->::TvWall::Guid::Clear();
  clear_has_guid();
}
inline const ::TvWall::Guid& Packet_ElementMaster_MasterLayout_ServerPos::guid() const {
  return guid_ != NULL ? *guid_ : *default_instance_->guid_;
}
inline ::TvWall::Guid* Packet_ElementMaster_MasterLayout_ServerPos::mutable_guid() {
  set_has_guid();
  if (guid_ == NULL) guid_ = new ::TvWall::Guid;
  return guid_;
}
inline ::TvWall::Guid* Packet_ElementMaster_MasterLayout_ServerPos::release_guid() {
  clear_has_guid();
  ::TvWall::Guid* temp = guid_;
  guid_ = NULL;
  return temp;
}
inline void Packet_ElementMaster_MasterLayout_ServerPos::set_allocated_guid(::TvWall::Guid* guid) {
  delete guid_;
  guid_ = guid;
  if (guid) {
    set_has_guid();
  } else {
    clear_has_guid();
  }
}

// required .TvWall.Point point = 3;
inline bool Packet_ElementMaster_MasterLayout_ServerPos::has_point() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Packet_ElementMaster_MasterLayout_ServerPos::set_has_point() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Packet_ElementMaster_MasterLayout_ServerPos::clear_has_point() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Packet_ElementMaster_MasterLayout_ServerPos::clear_point() {
  if (point_ != NULL) point_->::TvWall::Point::Clear();
  clear_has_point();
}
inline const ::TvWall::Point& Packet_ElementMaster_MasterLayout_ServerPos::point() const {
  return point_ != NULL ? *point_ : *default_instance_->point_;
}
inline ::TvWall::Point* Packet_ElementMaster_MasterLayout_ServerPos::mutable_point() {
  set_has_point();
  if (point_ == NULL) point_ = new ::TvWall::Point;
  return point_;
}
inline ::TvWall::Point* Packet_ElementMaster_MasterLayout_ServerPos::release_point() {
  clear_has_point();
  ::TvWall::Point* temp = point_;
  point_ = NULL;
  return temp;
}
inline void Packet_ElementMaster_MasterLayout_ServerPos::set_allocated_point(::TvWall::Point* point) {
  delete point_;
  point_ = point;
  if (point) {
    set_has_point();
  } else {
    clear_has_point();
  }
}

// -------------------------------------------------------------------

// Packet_ElementMaster_MasterLayout_MasLayout

// required string lyoutName = 1;
inline bool Packet_ElementMaster_MasterLayout_MasLayout::has_lyoutname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Packet_ElementMaster_MasterLayout_MasLayout::set_has_lyoutname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Packet_ElementMaster_MasterLayout_MasLayout::clear_has_lyoutname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Packet_ElementMaster_MasterLayout_MasLayout::clear_lyoutname() {
  if (lyoutname_ != &::google::protobuf::internal::kEmptyString) {
    lyoutname_->clear();
  }
  clear_has_lyoutname();
}
inline const ::std::string& Packet_ElementMaster_MasterLayout_MasLayout::lyoutname() const {
  return *lyoutname_;
}
inline void Packet_ElementMaster_MasterLayout_MasLayout::set_lyoutname(const ::std::string& value) {
  set_has_lyoutname();
  if (lyoutname_ == &::google::protobuf::internal::kEmptyString) {
    lyoutname_ = new ::std::string;
  }
  lyoutname_->assign(value);
}
inline void Packet_ElementMaster_MasterLayout_MasLayout::set_lyoutname(const char* value) {
  set_has_lyoutname();
  if (lyoutname_ == &::google::protobuf::internal::kEmptyString) {
    lyoutname_ = new ::std::string;
  }
  lyoutname_->assign(value);
}
inline void Packet_ElementMaster_MasterLayout_MasLayout::set_lyoutname(const char* value, size_t size) {
  set_has_lyoutname();
  if (lyoutname_ == &::google::protobuf::internal::kEmptyString) {
    lyoutname_ = new ::std::string;
  }
  lyoutname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Packet_ElementMaster_MasterLayout_MasLayout::mutable_lyoutname() {
  set_has_lyoutname();
  if (lyoutname_ == &::google::protobuf::internal::kEmptyString) {
    lyoutname_ = new ::std::string;
  }
  return lyoutname_;
}
inline ::std::string* Packet_ElementMaster_MasterLayout_MasLayout::release_lyoutname() {
  clear_has_lyoutname();
  if (lyoutname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = lyoutname_;
    lyoutname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Packet_ElementMaster_MasterLayout_MasLayout::set_allocated_lyoutname(::std::string* lyoutname) {
  if (lyoutname_ != &::google::protobuf::internal::kEmptyString) {
    delete lyoutname_;
  }
  if (lyoutname) {
    set_has_lyoutname();
    lyoutname_ = lyoutname;
  } else {
    clear_has_lyoutname();
    lyoutname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .TvWall.Packet.ElementMaster.MasterLayout.ServerPos sp = 2;
inline int Packet_ElementMaster_MasterLayout_MasLayout::sp_size() const {
  return sp_.size();
}
inline void Packet_ElementMaster_MasterLayout_MasLayout::clear_sp() {
  sp_.Clear();
}
inline const ::TvWall::Packet_ElementMaster_MasterLayout_ServerPos& Packet_ElementMaster_MasterLayout_MasLayout::sp(int index) const {
  return sp_.Get(index);
}
inline ::TvWall::Packet_ElementMaster_MasterLayout_ServerPos* Packet_ElementMaster_MasterLayout_MasLayout::mutable_sp(int index) {
  return sp_.Mutable(index);
}
inline ::TvWall::Packet_ElementMaster_MasterLayout_ServerPos* Packet_ElementMaster_MasterLayout_MasLayout::add_sp() {
  return sp_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TvWall::Packet_ElementMaster_MasterLayout_ServerPos >&
Packet_ElementMaster_MasterLayout_MasLayout::sp() const {
  return sp_;
}
inline ::google::protobuf::RepeatedPtrField< ::TvWall::Packet_ElementMaster_MasterLayout_ServerPos >*
Packet_ElementMaster_MasterLayout_MasLayout::mutable_sp() {
  return &sp_;
}

// repeated string serverln = 3;
inline int Packet_ElementMaster_MasterLayout_MasLayout::serverln_size() const {
  return serverln_.size();
}
inline void Packet_ElementMaster_MasterLayout_MasLayout::clear_serverln() {
  serverln_.Clear();
}
inline const ::std::string& Packet_ElementMaster_MasterLayout_MasLayout::serverln(int index) const {
  return serverln_.Get(index);
}
inline ::std::string* Packet_ElementMaster_MasterLayout_MasLayout::mutable_serverln(int index) {
  return serverln_.Mutable(index);
}
inline void Packet_ElementMaster_MasterLayout_MasLayout::set_serverln(int index, const ::std::string& value) {
  serverln_.Mutable(index)->assign(value);
}
inline void Packet_ElementMaster_MasterLayout_MasLayout::set_serverln(int index, const char* value) {
  serverln_.Mutable(index)->assign(value);
}
inline void Packet_ElementMaster_MasterLayout_MasLayout::set_serverln(int index, const char* value, size_t size) {
  serverln_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Packet_ElementMaster_MasterLayout_MasLayout::add_serverln() {
  return serverln_.Add();
}
inline void Packet_ElementMaster_MasterLayout_MasLayout::add_serverln(const ::std::string& value) {
  serverln_.Add()->assign(value);
}
inline void Packet_ElementMaster_MasterLayout_MasLayout::add_serverln(const char* value) {
  serverln_.Add()->assign(value);
}
inline void Packet_ElementMaster_MasterLayout_MasLayout::add_serverln(const char* value, size_t size) {
  serverln_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Packet_ElementMaster_MasterLayout_MasLayout::serverln() const {
  return serverln_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Packet_ElementMaster_MasterLayout_MasLayout::mutable_serverln() {
  return &serverln_;
}

// -------------------------------------------------------------------

// Packet_ElementMaster_MasterLayout

// repeated .TvWall.Packet.ElementMaster.MasterLayout.MasLayout masterLayout = 1;
inline int Packet_ElementMaster_MasterLayout::masterlayout_size() const {
  return masterlayout_.size();
}
inline void Packet_ElementMaster_MasterLayout::clear_masterlayout() {
  masterlayout_.Clear();
}
inline const ::TvWall::Packet_ElementMaster_MasterLayout_MasLayout& Packet_ElementMaster_MasterLayout::masterlayout(int index) const {
  return masterlayout_.Get(index);
}
inline ::TvWall::Packet_ElementMaster_MasterLayout_MasLayout* Packet_ElementMaster_MasterLayout::mutable_masterlayout(int index) {
  return masterlayout_.Mutable(index);
}
inline ::TvWall::Packet_ElementMaster_MasterLayout_MasLayout* Packet_ElementMaster_MasterLayout::add_masterlayout() {
  return masterlayout_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TvWall::Packet_ElementMaster_MasterLayout_MasLayout >&
Packet_ElementMaster_MasterLayout::masterlayout() const {
  return masterlayout_;
}
inline ::google::protobuf::RepeatedPtrField< ::TvWall::Packet_ElementMaster_MasterLayout_MasLayout >*
Packet_ElementMaster_MasterLayout::mutable_masterlayout() {
  return &masterlayout_;
}

// -------------------------------------------------------------------

// Packet_ElementMaster

// required int32 token = 1;
inline bool Packet_ElementMaster::has_token() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Packet_ElementMaster::set_has_token() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Packet_ElementMaster::clear_has_token() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Packet_ElementMaster::clear_token() {
  token_ = 0;
  clear_has_token();
}
inline ::google::protobuf::int32 Packet_ElementMaster::token() const {
  return token_;
}
inline void Packet_ElementMaster::set_token(::google::protobuf::int32 value) {
  set_has_token();
  token_ = value;
}

// repeated .TvWall.Packet.Session.LoginMasterAck.Server ser = 2;
inline int Packet_ElementMaster::ser_size() const {
  return ser_.size();
}
inline void Packet_ElementMaster::clear_ser() {
  ser_.Clear();
}
inline const ::TvWall::Packet_Session_LoginMasterAck_Server& Packet_ElementMaster::ser(int index) const {
  return ser_.Get(index);
}
inline ::TvWall::Packet_Session_LoginMasterAck_Server* Packet_ElementMaster::mutable_ser(int index) {
  return ser_.Mutable(index);
}
inline ::TvWall::Packet_Session_LoginMasterAck_Server* Packet_ElementMaster::add_ser() {
  return ser_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TvWall::Packet_Session_LoginMasterAck_Server >&
Packet_ElementMaster::ser() const {
  return ser_;
}
inline ::google::protobuf::RepeatedPtrField< ::TvWall::Packet_Session_LoginMasterAck_Server >*
Packet_ElementMaster::mutable_ser() {
  return &ser_;
}

// required .TvWall.Packet.ElementMaster.MasterLayout masterlyout = 3;
inline bool Packet_ElementMaster::has_masterlyout() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Packet_ElementMaster::set_has_masterlyout() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Packet_ElementMaster::clear_has_masterlyout() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Packet_ElementMaster::clear_masterlyout() {
  if (masterlyout_ != NULL) masterlyout_->::TvWall::Packet_ElementMaster_MasterLayout::Clear();
  clear_has_masterlyout();
}
inline const ::TvWall::Packet_ElementMaster_MasterLayout& Packet_ElementMaster::masterlyout() const {
  return masterlyout_ != NULL ? *masterlyout_ : *default_instance_->masterlyout_;
}
inline ::TvWall::Packet_ElementMaster_MasterLayout* Packet_ElementMaster::mutable_masterlyout() {
  set_has_masterlyout();
  if (masterlyout_ == NULL) masterlyout_ = new ::TvWall::Packet_ElementMaster_MasterLayout;
  return masterlyout_;
}
inline ::TvWall::Packet_ElementMaster_MasterLayout* Packet_ElementMaster::release_masterlyout() {
  clear_has_masterlyout();
  ::TvWall::Packet_ElementMaster_MasterLayout* temp = masterlyout_;
  masterlyout_ = NULL;
  return temp;
}
inline void Packet_ElementMaster::set_allocated_masterlyout(::TvWall::Packet_ElementMaster_MasterLayout* masterlyout) {
  delete masterlyout_;
  masterlyout_ = masterlyout;
  if (masterlyout) {
    set_has_masterlyout();
  } else {
    clear_has_masterlyout();
  }
}

// -------------------------------------------------------------------

// Packet_Ctrl_ScreenSplitCtrl

// required int32 screenIndex = 2;
inline bool Packet_Ctrl_ScreenSplitCtrl::has_screenindex() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Packet_Ctrl_ScreenSplitCtrl::set_has_screenindex() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Packet_Ctrl_ScreenSplitCtrl::clear_has_screenindex() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Packet_Ctrl_ScreenSplitCtrl::clear_screenindex() {
  screenindex_ = 0;
  clear_has_screenindex();
}
inline ::google::protobuf::int32 Packet_Ctrl_ScreenSplitCtrl::screenindex() const {
  return screenindex_;
}
inline void Packet_Ctrl_ScreenSplitCtrl::set_screenindex(::google::protobuf::int32 value) {
  set_has_screenindex();
  screenindex_ = value;
}

// required int32 row = 3 [default = 1];
inline bool Packet_Ctrl_ScreenSplitCtrl::has_row() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Packet_Ctrl_ScreenSplitCtrl::set_has_row() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Packet_Ctrl_ScreenSplitCtrl::clear_has_row() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Packet_Ctrl_ScreenSplitCtrl::clear_row() {
  row_ = 1;
  clear_has_row();
}
inline ::google::protobuf::int32 Packet_Ctrl_ScreenSplitCtrl::row() const {
  return row_;
}
inline void Packet_Ctrl_ScreenSplitCtrl::set_row(::google::protobuf::int32 value) {
  set_has_row();
  row_ = value;
}

// required int32 col = 4 [default = 1];
inline bool Packet_Ctrl_ScreenSplitCtrl::has_col() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Packet_Ctrl_ScreenSplitCtrl::set_has_col() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Packet_Ctrl_ScreenSplitCtrl::clear_has_col() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Packet_Ctrl_ScreenSplitCtrl::clear_col() {
  col_ = 1;
  clear_has_col();
}
inline ::google::protobuf::int32 Packet_Ctrl_ScreenSplitCtrl::col() const {
  return col_;
}
inline void Packet_Ctrl_ScreenSplitCtrl::set_col(::google::protobuf::int32 value) {
  set_has_col();
  col_ = value;
}

// -------------------------------------------------------------------

// Packet_Ctrl_ViewCtrl_ViewGeomotryCtrl

// required .TvWall.Packet.Ctrl.ViewCtrl.ViewGeomotryCtrl.ViewGeomotryCtrlType type = 1;
inline bool Packet_Ctrl_ViewCtrl_ViewGeomotryCtrl::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Packet_Ctrl_ViewCtrl_ViewGeomotryCtrl::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Packet_Ctrl_ViewCtrl_ViewGeomotryCtrl::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Packet_Ctrl_ViewCtrl_ViewGeomotryCtrl::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::TvWall::Packet_Ctrl_ViewCtrl_ViewGeomotryCtrl_ViewGeomotryCtrlType Packet_Ctrl_ViewCtrl_ViewGeomotryCtrl::type() const {
  return static_cast< ::TvWall::Packet_Ctrl_ViewCtrl_ViewGeomotryCtrl_ViewGeomotryCtrlType >(type_);
}
inline void Packet_Ctrl_ViewCtrl_ViewGeomotryCtrl::set_type(::TvWall::Packet_Ctrl_ViewCtrl_ViewGeomotryCtrl_ViewGeomotryCtrlType value) {
  assert(::TvWall::Packet_Ctrl_ViewCtrl_ViewGeomotryCtrl_ViewGeomotryCtrlType_IsValid(value));
  set_has_type();
  type_ = value;
}

// required .TvWall.Packet.ElementDat.View view = 2;
inline bool Packet_Ctrl_ViewCtrl_ViewGeomotryCtrl::has_view() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Packet_Ctrl_ViewCtrl_ViewGeomotryCtrl::set_has_view() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Packet_Ctrl_ViewCtrl_ViewGeomotryCtrl::clear_has_view() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Packet_Ctrl_ViewCtrl_ViewGeomotryCtrl::clear_view() {
  if (view_ != NULL) view_->::TvWall::Packet_ElementDat_View::Clear();
  clear_has_view();
}
inline const ::TvWall::Packet_ElementDat_View& Packet_Ctrl_ViewCtrl_ViewGeomotryCtrl::view() const {
  return view_ != NULL ? *view_ : *default_instance_->view_;
}
inline ::TvWall::Packet_ElementDat_View* Packet_Ctrl_ViewCtrl_ViewGeomotryCtrl::mutable_view() {
  set_has_view();
  if (view_ == NULL) view_ = new ::TvWall::Packet_ElementDat_View;
  return view_;
}
inline ::TvWall::Packet_ElementDat_View* Packet_Ctrl_ViewCtrl_ViewGeomotryCtrl::release_view() {
  clear_has_view();
  ::TvWall::Packet_ElementDat_View* temp = view_;
  view_ = NULL;
  return temp;
}
inline void Packet_Ctrl_ViewCtrl_ViewGeomotryCtrl::set_allocated_view(::TvWall::Packet_ElementDat_View* view) {
  delete view_;
  view_ = view;
  if (view) {
    set_has_view();
  } else {
    clear_has_view();
  }
}

// -------------------------------------------------------------------

// Packet_Ctrl_ViewCtrl_VideoCtrl

// required .TvWall.Packet.Ctrl.ViewCtrl.VideoCtrl.VideoCtrlType type = 1;
inline bool Packet_Ctrl_ViewCtrl_VideoCtrl::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Packet_Ctrl_ViewCtrl_VideoCtrl::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Packet_Ctrl_ViewCtrl_VideoCtrl::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Packet_Ctrl_ViewCtrl_VideoCtrl::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::TvWall::Packet_Ctrl_ViewCtrl_VideoCtrl_VideoCtrlType Packet_Ctrl_ViewCtrl_VideoCtrl::type() const {
  return static_cast< ::TvWall::Packet_Ctrl_ViewCtrl_VideoCtrl_VideoCtrlType >(type_);
}
inline void Packet_Ctrl_ViewCtrl_VideoCtrl::set_type(::TvWall::Packet_Ctrl_ViewCtrl_VideoCtrl_VideoCtrlType value) {
  assert(::TvWall::Packet_Ctrl_ViewCtrl_VideoCtrl_VideoCtrlType_IsValid(value));
  set_has_type();
  type_ = value;
}

// required int32 winId = 2;
inline bool Packet_Ctrl_ViewCtrl_VideoCtrl::has_winid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Packet_Ctrl_ViewCtrl_VideoCtrl::set_has_winid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Packet_Ctrl_ViewCtrl_VideoCtrl::clear_has_winid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Packet_Ctrl_ViewCtrl_VideoCtrl::clear_winid() {
  winid_ = 0;
  clear_has_winid();
}
inline ::google::protobuf::int32 Packet_Ctrl_ViewCtrl_VideoCtrl::winid() const {
  return winid_;
}
inline void Packet_Ctrl_ViewCtrl_VideoCtrl::set_winid(::google::protobuf::int32 value) {
  set_has_winid();
  winid_ = value;
}

// repeated .TvWall.Guid cameraId = 3;
inline int Packet_Ctrl_ViewCtrl_VideoCtrl::cameraid_size() const {
  return cameraid_.size();
}
inline void Packet_Ctrl_ViewCtrl_VideoCtrl::clear_cameraid() {
  cameraid_.Clear();
}
inline const ::TvWall::Guid& Packet_Ctrl_ViewCtrl_VideoCtrl::cameraid(int index) const {
  return cameraid_.Get(index);
}
inline ::TvWall::Guid* Packet_Ctrl_ViewCtrl_VideoCtrl::mutable_cameraid(int index) {
  return cameraid_.Mutable(index);
}
inline ::TvWall::Guid* Packet_Ctrl_ViewCtrl_VideoCtrl::add_cameraid() {
  return cameraid_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TvWall::Guid >&
Packet_Ctrl_ViewCtrl_VideoCtrl::cameraid() const {
  return cameraid_;
}
inline ::google::protobuf::RepeatedPtrField< ::TvWall::Guid >*
Packet_Ctrl_ViewCtrl_VideoCtrl::mutable_cameraid() {
  return &cameraid_;
}

// optional int32 pollInterval = 4;
inline bool Packet_Ctrl_ViewCtrl_VideoCtrl::has_pollinterval() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Packet_Ctrl_ViewCtrl_VideoCtrl::set_has_pollinterval() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Packet_Ctrl_ViewCtrl_VideoCtrl::clear_has_pollinterval() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Packet_Ctrl_ViewCtrl_VideoCtrl::clear_pollinterval() {
  pollinterval_ = 0;
  clear_has_pollinterval();
}
inline ::google::protobuf::int32 Packet_Ctrl_ViewCtrl_VideoCtrl::pollinterval() const {
  return pollinterval_;
}
inline void Packet_Ctrl_ViewCtrl_VideoCtrl::set_pollinterval(::google::protobuf::int32 value) {
  set_has_pollinterval();
  pollinterval_ = value;
}

// optional bool keepStretch = 5;
inline bool Packet_Ctrl_ViewCtrl_VideoCtrl::has_keepstretch() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Packet_Ctrl_ViewCtrl_VideoCtrl::set_has_keepstretch() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Packet_Ctrl_ViewCtrl_VideoCtrl::clear_has_keepstretch() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Packet_Ctrl_ViewCtrl_VideoCtrl::clear_keepstretch() {
  keepstretch_ = false;
  clear_has_keepstretch();
}
inline bool Packet_Ctrl_ViewCtrl_VideoCtrl::keepstretch() const {
  return keepstretch_;
}
inline void Packet_Ctrl_ViewCtrl_VideoCtrl::set_keepstretch(bool value) {
  set_has_keepstretch();
  keepstretch_ = value;
}

// -------------------------------------------------------------------

// Packet_Ctrl_ViewCtrl_RecordCtrl

// required .TvWall.Packet.Ctrl.ViewCtrl.RecordCtrl.RecordCtrlType type = 1;
inline bool Packet_Ctrl_ViewCtrl_RecordCtrl::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Packet_Ctrl_ViewCtrl_RecordCtrl::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Packet_Ctrl_ViewCtrl_RecordCtrl::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Packet_Ctrl_ViewCtrl_RecordCtrl::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::TvWall::Packet_Ctrl_ViewCtrl_RecordCtrl_RecordCtrlType Packet_Ctrl_ViewCtrl_RecordCtrl::type() const {
  return static_cast< ::TvWall::Packet_Ctrl_ViewCtrl_RecordCtrl_RecordCtrlType >(type_);
}
inline void Packet_Ctrl_ViewCtrl_RecordCtrl::set_type(::TvWall::Packet_Ctrl_ViewCtrl_RecordCtrl_RecordCtrlType value) {
  assert(::TvWall::Packet_Ctrl_ViewCtrl_RecordCtrl_RecordCtrlType_IsValid(value));
  set_has_type();
  type_ = value;
}

// required int32 winId = 2;
inline bool Packet_Ctrl_ViewCtrl_RecordCtrl::has_winid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Packet_Ctrl_ViewCtrl_RecordCtrl::set_has_winid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Packet_Ctrl_ViewCtrl_RecordCtrl::clear_has_winid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Packet_Ctrl_ViewCtrl_RecordCtrl::clear_winid() {
  winid_ = 0;
  clear_has_winid();
}
inline ::google::protobuf::int32 Packet_Ctrl_ViewCtrl_RecordCtrl::winid() const {
  return winid_;
}
inline void Packet_Ctrl_ViewCtrl_RecordCtrl::set_winid(::google::protobuf::int32 value) {
  set_has_winid();
  winid_ = value;
}

// required .TvWall.Guid cameraId = 3;
inline bool Packet_Ctrl_ViewCtrl_RecordCtrl::has_cameraid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Packet_Ctrl_ViewCtrl_RecordCtrl::set_has_cameraid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Packet_Ctrl_ViewCtrl_RecordCtrl::clear_has_cameraid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Packet_Ctrl_ViewCtrl_RecordCtrl::clear_cameraid() {
  if (cameraid_ != NULL) cameraid_->::TvWall::Guid::Clear();
  clear_has_cameraid();
}
inline const ::TvWall::Guid& Packet_Ctrl_ViewCtrl_RecordCtrl::cameraid() const {
  return cameraid_ != NULL ? *cameraid_ : *default_instance_->cameraid_;
}
inline ::TvWall::Guid* Packet_Ctrl_ViewCtrl_RecordCtrl::mutable_cameraid() {
  set_has_cameraid();
  if (cameraid_ == NULL) cameraid_ = new ::TvWall::Guid;
  return cameraid_;
}
inline ::TvWall::Guid* Packet_Ctrl_ViewCtrl_RecordCtrl::release_cameraid() {
  clear_has_cameraid();
  ::TvWall::Guid* temp = cameraid_;
  cameraid_ = NULL;
  return temp;
}
inline void Packet_Ctrl_ViewCtrl_RecordCtrl::set_allocated_cameraid(::TvWall::Guid* cameraid) {
  delete cameraid_;
  cameraid_ = cameraid;
  if (cameraid) {
    set_has_cameraid();
  } else {
    clear_has_cameraid();
  }
}

// optional uint64 startTime = 4;
inline bool Packet_Ctrl_ViewCtrl_RecordCtrl::has_starttime() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Packet_Ctrl_ViewCtrl_RecordCtrl::set_has_starttime() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Packet_Ctrl_ViewCtrl_RecordCtrl::clear_has_starttime() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Packet_Ctrl_ViewCtrl_RecordCtrl::clear_starttime() {
  starttime_ = GOOGLE_ULONGLONG(0);
  clear_has_starttime();
}
inline ::google::protobuf::uint64 Packet_Ctrl_ViewCtrl_RecordCtrl::starttime() const {
  return starttime_;
}
inline void Packet_Ctrl_ViewCtrl_RecordCtrl::set_starttime(::google::protobuf::uint64 value) {
  set_has_starttime();
  starttime_ = value;
}

// optional bool keepStretch = 5;
inline bool Packet_Ctrl_ViewCtrl_RecordCtrl::has_keepstretch() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Packet_Ctrl_ViewCtrl_RecordCtrl::set_has_keepstretch() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Packet_Ctrl_ViewCtrl_RecordCtrl::clear_has_keepstretch() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Packet_Ctrl_ViewCtrl_RecordCtrl::clear_keepstretch() {
  keepstretch_ = false;
  clear_has_keepstretch();
}
inline bool Packet_Ctrl_ViewCtrl_RecordCtrl::keepstretch() const {
  return keepstretch_;
}
inline void Packet_Ctrl_ViewCtrl_RecordCtrl::set_keepstretch(bool value) {
  set_has_keepstretch();
  keepstretch_ = value;
}

// optional int32 rate = 6;
inline bool Packet_Ctrl_ViewCtrl_RecordCtrl::has_rate() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Packet_Ctrl_ViewCtrl_RecordCtrl::set_has_rate() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Packet_Ctrl_ViewCtrl_RecordCtrl::clear_has_rate() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Packet_Ctrl_ViewCtrl_RecordCtrl::clear_rate() {
  rate_ = 0;
  clear_has_rate();
}
inline ::google::protobuf::int32 Packet_Ctrl_ViewCtrl_RecordCtrl::rate() const {
  return rate_;
}
inline void Packet_Ctrl_ViewCtrl_RecordCtrl::set_rate(::google::protobuf::int32 value) {
  set_has_rate();
  rate_ = value;
}

// -------------------------------------------------------------------

// Packet_Ctrl_ViewCtrl_FlashCtrl

// required .TvWall.Packet.Ctrl.ViewCtrl.FlashCtrl.FlashCtrlType type = 1;
inline bool Packet_Ctrl_ViewCtrl_FlashCtrl::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Packet_Ctrl_ViewCtrl_FlashCtrl::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Packet_Ctrl_ViewCtrl_FlashCtrl::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Packet_Ctrl_ViewCtrl_FlashCtrl::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::TvWall::Packet_Ctrl_ViewCtrl_FlashCtrl_FlashCtrlType Packet_Ctrl_ViewCtrl_FlashCtrl::type() const {
  return static_cast< ::TvWall::Packet_Ctrl_ViewCtrl_FlashCtrl_FlashCtrlType >(type_);
}
inline void Packet_Ctrl_ViewCtrl_FlashCtrl::set_type(::TvWall::Packet_Ctrl_ViewCtrl_FlashCtrl_FlashCtrlType value) {
  assert(::TvWall::Packet_Ctrl_ViewCtrl_FlashCtrl_FlashCtrlType_IsValid(value));
  set_has_type();
  type_ = value;
}

// required int32 winId = 2;
inline bool Packet_Ctrl_ViewCtrl_FlashCtrl::has_winid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Packet_Ctrl_ViewCtrl_FlashCtrl::set_has_winid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Packet_Ctrl_ViewCtrl_FlashCtrl::clear_has_winid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Packet_Ctrl_ViewCtrl_FlashCtrl::clear_winid() {
  winid_ = 0;
  clear_has_winid();
}
inline ::google::protobuf::int32 Packet_Ctrl_ViewCtrl_FlashCtrl::winid() const {
  return winid_;
}
inline void Packet_Ctrl_ViewCtrl_FlashCtrl::set_winid(::google::protobuf::int32 value) {
  set_has_winid();
  winid_ = value;
}

// required string url = 3;
inline bool Packet_Ctrl_ViewCtrl_FlashCtrl::has_url() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Packet_Ctrl_ViewCtrl_FlashCtrl::set_has_url() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Packet_Ctrl_ViewCtrl_FlashCtrl::clear_has_url() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Packet_Ctrl_ViewCtrl_FlashCtrl::clear_url() {
  if (url_ != &::google::protobuf::internal::kEmptyString) {
    url_->clear();
  }
  clear_has_url();
}
inline const ::std::string& Packet_Ctrl_ViewCtrl_FlashCtrl::url() const {
  return *url_;
}
inline void Packet_Ctrl_ViewCtrl_FlashCtrl::set_url(const ::std::string& value) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  url_->assign(value);
}
inline void Packet_Ctrl_ViewCtrl_FlashCtrl::set_url(const char* value) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  url_->assign(value);
}
inline void Packet_Ctrl_ViewCtrl_FlashCtrl::set_url(const char* value, size_t size) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  url_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Packet_Ctrl_ViewCtrl_FlashCtrl::mutable_url() {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  return url_;
}
inline ::std::string* Packet_Ctrl_ViewCtrl_FlashCtrl::release_url() {
  clear_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = url_;
    url_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Packet_Ctrl_ViewCtrl_FlashCtrl::set_allocated_url(::std::string* url) {
  if (url_ != &::google::protobuf::internal::kEmptyString) {
    delete url_;
  }
  if (url) {
    set_has_url();
    url_ = url;
  } else {
    clear_has_url();
    url_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// Packet_Ctrl_ViewCtrl_HTMLCtrl

// required .TvWall.Packet.Ctrl.ViewCtrl.HTMLCtrl.HTMLCtrlType type = 1;
inline bool Packet_Ctrl_ViewCtrl_HTMLCtrl::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Packet_Ctrl_ViewCtrl_HTMLCtrl::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Packet_Ctrl_ViewCtrl_HTMLCtrl::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Packet_Ctrl_ViewCtrl_HTMLCtrl::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::TvWall::Packet_Ctrl_ViewCtrl_HTMLCtrl_HTMLCtrlType Packet_Ctrl_ViewCtrl_HTMLCtrl::type() const {
  return static_cast< ::TvWall::Packet_Ctrl_ViewCtrl_HTMLCtrl_HTMLCtrlType >(type_);
}
inline void Packet_Ctrl_ViewCtrl_HTMLCtrl::set_type(::TvWall::Packet_Ctrl_ViewCtrl_HTMLCtrl_HTMLCtrlType value) {
  assert(::TvWall::Packet_Ctrl_ViewCtrl_HTMLCtrl_HTMLCtrlType_IsValid(value));
  set_has_type();
  type_ = value;
}

// required int32 winId = 2;
inline bool Packet_Ctrl_ViewCtrl_HTMLCtrl::has_winid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Packet_Ctrl_ViewCtrl_HTMLCtrl::set_has_winid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Packet_Ctrl_ViewCtrl_HTMLCtrl::clear_has_winid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Packet_Ctrl_ViewCtrl_HTMLCtrl::clear_winid() {
  winid_ = 0;
  clear_has_winid();
}
inline ::google::protobuf::int32 Packet_Ctrl_ViewCtrl_HTMLCtrl::winid() const {
  return winid_;
}
inline void Packet_Ctrl_ViewCtrl_HTMLCtrl::set_winid(::google::protobuf::int32 value) {
  set_has_winid();
  winid_ = value;
}

// required string url = 3;
inline bool Packet_Ctrl_ViewCtrl_HTMLCtrl::has_url() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Packet_Ctrl_ViewCtrl_HTMLCtrl::set_has_url() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Packet_Ctrl_ViewCtrl_HTMLCtrl::clear_has_url() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Packet_Ctrl_ViewCtrl_HTMLCtrl::clear_url() {
  if (url_ != &::google::protobuf::internal::kEmptyString) {
    url_->clear();
  }
  clear_has_url();
}
inline const ::std::string& Packet_Ctrl_ViewCtrl_HTMLCtrl::url() const {
  return *url_;
}
inline void Packet_Ctrl_ViewCtrl_HTMLCtrl::set_url(const ::std::string& value) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  url_->assign(value);
}
inline void Packet_Ctrl_ViewCtrl_HTMLCtrl::set_url(const char* value) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  url_->assign(value);
}
inline void Packet_Ctrl_ViewCtrl_HTMLCtrl::set_url(const char* value, size_t size) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  url_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Packet_Ctrl_ViewCtrl_HTMLCtrl::mutable_url() {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  return url_;
}
inline ::std::string* Packet_Ctrl_ViewCtrl_HTMLCtrl::release_url() {
  clear_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = url_;
    url_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Packet_Ctrl_ViewCtrl_HTMLCtrl::set_allocated_url(::std::string* url) {
  if (url_ != &::google::protobuf::internal::kEmptyString) {
    delete url_;
  }
  if (url) {
    set_has_url();
    url_ = url;
  } else {
    clear_has_url();
    url_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// Packet_Ctrl_ViewCtrl_LocalMovieCtrl

// required .TvWall.Packet.Ctrl.ViewCtrl.LocalMovieCtrl.LocalMovieType type = 1;
inline bool Packet_Ctrl_ViewCtrl_LocalMovieCtrl::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Packet_Ctrl_ViewCtrl_LocalMovieCtrl::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Packet_Ctrl_ViewCtrl_LocalMovieCtrl::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Packet_Ctrl_ViewCtrl_LocalMovieCtrl::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::TvWall::Packet_Ctrl_ViewCtrl_LocalMovieCtrl_LocalMovieType Packet_Ctrl_ViewCtrl_LocalMovieCtrl::type() const {
  return static_cast< ::TvWall::Packet_Ctrl_ViewCtrl_LocalMovieCtrl_LocalMovieType >(type_);
}
inline void Packet_Ctrl_ViewCtrl_LocalMovieCtrl::set_type(::TvWall::Packet_Ctrl_ViewCtrl_LocalMovieCtrl_LocalMovieType value) {
  assert(::TvWall::Packet_Ctrl_ViewCtrl_LocalMovieCtrl_LocalMovieType_IsValid(value));
  set_has_type();
  type_ = value;
}

// required int32 winId = 2;
inline bool Packet_Ctrl_ViewCtrl_LocalMovieCtrl::has_winid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Packet_Ctrl_ViewCtrl_LocalMovieCtrl::set_has_winid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Packet_Ctrl_ViewCtrl_LocalMovieCtrl::clear_has_winid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Packet_Ctrl_ViewCtrl_LocalMovieCtrl::clear_winid() {
  winid_ = 0;
  clear_has_winid();
}
inline ::google::protobuf::int32 Packet_Ctrl_ViewCtrl_LocalMovieCtrl::winid() const {
  return winid_;
}
inline void Packet_Ctrl_ViewCtrl_LocalMovieCtrl::set_winid(::google::protobuf::int32 value) {
  set_has_winid();
  winid_ = value;
}

// optional string url = 3;
inline bool Packet_Ctrl_ViewCtrl_LocalMovieCtrl::has_url() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Packet_Ctrl_ViewCtrl_LocalMovieCtrl::set_has_url() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Packet_Ctrl_ViewCtrl_LocalMovieCtrl::clear_has_url() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Packet_Ctrl_ViewCtrl_LocalMovieCtrl::clear_url() {
  if (url_ != &::google::protobuf::internal::kEmptyString) {
    url_->clear();
  }
  clear_has_url();
}
inline const ::std::string& Packet_Ctrl_ViewCtrl_LocalMovieCtrl::url() const {
  return *url_;
}
inline void Packet_Ctrl_ViewCtrl_LocalMovieCtrl::set_url(const ::std::string& value) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  url_->assign(value);
}
inline void Packet_Ctrl_ViewCtrl_LocalMovieCtrl::set_url(const char* value) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  url_->assign(value);
}
inline void Packet_Ctrl_ViewCtrl_LocalMovieCtrl::set_url(const char* value, size_t size) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  url_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Packet_Ctrl_ViewCtrl_LocalMovieCtrl::mutable_url() {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  return url_;
}
inline ::std::string* Packet_Ctrl_ViewCtrl_LocalMovieCtrl::release_url() {
  clear_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = url_;
    url_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Packet_Ctrl_ViewCtrl_LocalMovieCtrl::set_allocated_url(::std::string* url) {
  if (url_ != &::google::protobuf::internal::kEmptyString) {
    delete url_;
  }
  if (url) {
    set_has_url();
    url_ = url;
  } else {
    clear_has_url();
    url_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 volume = 4;
inline bool Packet_Ctrl_ViewCtrl_LocalMovieCtrl::has_volume() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Packet_Ctrl_ViewCtrl_LocalMovieCtrl::set_has_volume() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Packet_Ctrl_ViewCtrl_LocalMovieCtrl::clear_has_volume() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Packet_Ctrl_ViewCtrl_LocalMovieCtrl::clear_volume() {
  volume_ = 0;
  clear_has_volume();
}
inline ::google::protobuf::int32 Packet_Ctrl_ViewCtrl_LocalMovieCtrl::volume() const {
  return volume_;
}
inline void Packet_Ctrl_ViewCtrl_LocalMovieCtrl::set_volume(::google::protobuf::int32 value) {
  set_has_volume();
  volume_ = value;
}

// optional int64 timeStamp = 5;
inline bool Packet_Ctrl_ViewCtrl_LocalMovieCtrl::has_timestamp() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Packet_Ctrl_ViewCtrl_LocalMovieCtrl::set_has_timestamp() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Packet_Ctrl_ViewCtrl_LocalMovieCtrl::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Packet_Ctrl_ViewCtrl_LocalMovieCtrl::clear_timestamp() {
  timestamp_ = GOOGLE_LONGLONG(0);
  clear_has_timestamp();
}
inline ::google::protobuf::int64 Packet_Ctrl_ViewCtrl_LocalMovieCtrl::timestamp() const {
  return timestamp_;
}
inline void Packet_Ctrl_ViewCtrl_LocalMovieCtrl::set_timestamp(::google::protobuf::int64 value) {
  set_has_timestamp();
  timestamp_ = value;
}

// -------------------------------------------------------------------

// Packet_Ctrl_ViewCtrl_TextCtrl

// required .TvWall.Packet.Ctrl.ViewCtrl.TextCtrl.TextCtrlType type = 1;
inline bool Packet_Ctrl_ViewCtrl_TextCtrl::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Packet_Ctrl_ViewCtrl_TextCtrl::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Packet_Ctrl_ViewCtrl_TextCtrl::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Packet_Ctrl_ViewCtrl_TextCtrl::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::TvWall::Packet_Ctrl_ViewCtrl_TextCtrl_TextCtrlType Packet_Ctrl_ViewCtrl_TextCtrl::type() const {
  return static_cast< ::TvWall::Packet_Ctrl_ViewCtrl_TextCtrl_TextCtrlType >(type_);
}
inline void Packet_Ctrl_ViewCtrl_TextCtrl::set_type(::TvWall::Packet_Ctrl_ViewCtrl_TextCtrl_TextCtrlType value) {
  assert(::TvWall::Packet_Ctrl_ViewCtrl_TextCtrl_TextCtrlType_IsValid(value));
  set_has_type();
  type_ = value;
}

// required int32 winId = 2;
inline bool Packet_Ctrl_ViewCtrl_TextCtrl::has_winid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Packet_Ctrl_ViewCtrl_TextCtrl::set_has_winid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Packet_Ctrl_ViewCtrl_TextCtrl::clear_has_winid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Packet_Ctrl_ViewCtrl_TextCtrl::clear_winid() {
  winid_ = 0;
  clear_has_winid();
}
inline ::google::protobuf::int32 Packet_Ctrl_ViewCtrl_TextCtrl::winid() const {
  return winid_;
}
inline void Packet_Ctrl_ViewCtrl_TextCtrl::set_winid(::google::protobuf::int32 value) {
  set_has_winid();
  winid_ = value;
}

// optional string text = 3;
inline bool Packet_Ctrl_ViewCtrl_TextCtrl::has_text() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Packet_Ctrl_ViewCtrl_TextCtrl::set_has_text() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Packet_Ctrl_ViewCtrl_TextCtrl::clear_has_text() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Packet_Ctrl_ViewCtrl_TextCtrl::clear_text() {
  if (text_ != &::google::protobuf::internal::kEmptyString) {
    text_->clear();
  }
  clear_has_text();
}
inline const ::std::string& Packet_Ctrl_ViewCtrl_TextCtrl::text() const {
  return *text_;
}
inline void Packet_Ctrl_ViewCtrl_TextCtrl::set_text(const ::std::string& value) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(value);
}
inline void Packet_Ctrl_ViewCtrl_TextCtrl::set_text(const char* value) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(value);
}
inline void Packet_Ctrl_ViewCtrl_TextCtrl::set_text(const char* value, size_t size) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Packet_Ctrl_ViewCtrl_TextCtrl::mutable_text() {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  return text_;
}
inline ::std::string* Packet_Ctrl_ViewCtrl_TextCtrl::release_text() {
  clear_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = text_;
    text_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Packet_Ctrl_ViewCtrl_TextCtrl::set_allocated_text(::std::string* text) {
  if (text_ != &::google::protobuf::internal::kEmptyString) {
    delete text_;
  }
  if (text) {
    set_has_text();
    text_ = text;
  } else {
    clear_has_text();
    text_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// Packet_Ctrl_ViewCtrl_MapCtrl

// required .TvWall.Packet.Ctrl.ViewCtrl.MapCtrl.MapCtrlType type = 1;
inline bool Packet_Ctrl_ViewCtrl_MapCtrl::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Packet_Ctrl_ViewCtrl_MapCtrl::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Packet_Ctrl_ViewCtrl_MapCtrl::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Packet_Ctrl_ViewCtrl_MapCtrl::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::TvWall::Packet_Ctrl_ViewCtrl_MapCtrl_MapCtrlType Packet_Ctrl_ViewCtrl_MapCtrl::type() const {
  return static_cast< ::TvWall::Packet_Ctrl_ViewCtrl_MapCtrl_MapCtrlType >(type_);
}
inline void Packet_Ctrl_ViewCtrl_MapCtrl::set_type(::TvWall::Packet_Ctrl_ViewCtrl_MapCtrl_MapCtrlType value) {
  assert(::TvWall::Packet_Ctrl_ViewCtrl_MapCtrl_MapCtrlType_IsValid(value));
  set_has_type();
  type_ = value;
}

// required int32 winId = 2;
inline bool Packet_Ctrl_ViewCtrl_MapCtrl::has_winid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Packet_Ctrl_ViewCtrl_MapCtrl::set_has_winid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Packet_Ctrl_ViewCtrl_MapCtrl::clear_has_winid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Packet_Ctrl_ViewCtrl_MapCtrl::clear_winid() {
  winid_ = 0;
  clear_has_winid();
}
inline ::google::protobuf::int32 Packet_Ctrl_ViewCtrl_MapCtrl::winid() const {
  return winid_;
}
inline void Packet_Ctrl_ViewCtrl_MapCtrl::set_winid(::google::protobuf::int32 value) {
  set_has_winid();
  winid_ = value;
}

// optional string url = 3;
inline bool Packet_Ctrl_ViewCtrl_MapCtrl::has_url() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Packet_Ctrl_ViewCtrl_MapCtrl::set_has_url() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Packet_Ctrl_ViewCtrl_MapCtrl::clear_has_url() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Packet_Ctrl_ViewCtrl_MapCtrl::clear_url() {
  if (url_ != &::google::protobuf::internal::kEmptyString) {
    url_->clear();
  }
  clear_has_url();
}
inline const ::std::string& Packet_Ctrl_ViewCtrl_MapCtrl::url() const {
  return *url_;
}
inline void Packet_Ctrl_ViewCtrl_MapCtrl::set_url(const ::std::string& value) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  url_->assign(value);
}
inline void Packet_Ctrl_ViewCtrl_MapCtrl::set_url(const char* value) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  url_->assign(value);
}
inline void Packet_Ctrl_ViewCtrl_MapCtrl::set_url(const char* value, size_t size) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  url_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Packet_Ctrl_ViewCtrl_MapCtrl::mutable_url() {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  return url_;
}
inline ::std::string* Packet_Ctrl_ViewCtrl_MapCtrl::release_url() {
  clear_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = url_;
    url_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Packet_Ctrl_ViewCtrl_MapCtrl::set_allocated_url(::std::string* url) {
  if (url_ != &::google::protobuf::internal::kEmptyString) {
    delete url_;
  }
  if (url) {
    set_has_url();
    url_ = url;
  } else {
    clear_has_url();
    url_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// Packet_Ctrl_ViewCtrl_OthersCtrl

// required .TvWall.Packet.Ctrl.ViewCtrl.OthersCtrl.OthersCtrlType type = 1;
inline bool Packet_Ctrl_ViewCtrl_OthersCtrl::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Packet_Ctrl_ViewCtrl_OthersCtrl::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Packet_Ctrl_ViewCtrl_OthersCtrl::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Packet_Ctrl_ViewCtrl_OthersCtrl::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::TvWall::Packet_Ctrl_ViewCtrl_OthersCtrl_OthersCtrlType Packet_Ctrl_ViewCtrl_OthersCtrl::type() const {
  return static_cast< ::TvWall::Packet_Ctrl_ViewCtrl_OthersCtrl_OthersCtrlType >(type_);
}
inline void Packet_Ctrl_ViewCtrl_OthersCtrl::set_type(::TvWall::Packet_Ctrl_ViewCtrl_OthersCtrl_OthersCtrlType value) {
  assert(::TvWall::Packet_Ctrl_ViewCtrl_OthersCtrl_OthersCtrlType_IsValid(value));
  set_has_type();
  type_ = value;
}

// required int32 winId = 2;
inline bool Packet_Ctrl_ViewCtrl_OthersCtrl::has_winid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Packet_Ctrl_ViewCtrl_OthersCtrl::set_has_winid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Packet_Ctrl_ViewCtrl_OthersCtrl::clear_has_winid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Packet_Ctrl_ViewCtrl_OthersCtrl::clear_winid() {
  winid_ = 0;
  clear_has_winid();
}
inline ::google::protobuf::int32 Packet_Ctrl_ViewCtrl_OthersCtrl::winid() const {
  return winid_;
}
inline void Packet_Ctrl_ViewCtrl_OthersCtrl::set_winid(::google::protobuf::int32 value) {
  set_has_winid();
  winid_ = value;
}

// -------------------------------------------------------------------

// Packet_Ctrl_ViewCtrl

// optional .TvWall.Packet.Ctrl.ViewCtrl.VideoCtrl videoCtrl = 1;
inline bool Packet_Ctrl_ViewCtrl::has_videoctrl() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Packet_Ctrl_ViewCtrl::set_has_videoctrl() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Packet_Ctrl_ViewCtrl::clear_has_videoctrl() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Packet_Ctrl_ViewCtrl::clear_videoctrl() {
  if (videoctrl_ != NULL) videoctrl_->::TvWall::Packet_Ctrl_ViewCtrl_VideoCtrl::Clear();
  clear_has_videoctrl();
}
inline const ::TvWall::Packet_Ctrl_ViewCtrl_VideoCtrl& Packet_Ctrl_ViewCtrl::videoctrl() const {
  return videoctrl_ != NULL ? *videoctrl_ : *default_instance_->videoctrl_;
}
inline ::TvWall::Packet_Ctrl_ViewCtrl_VideoCtrl* Packet_Ctrl_ViewCtrl::mutable_videoctrl() {
  set_has_videoctrl();
  if (videoctrl_ == NULL) videoctrl_ = new ::TvWall::Packet_Ctrl_ViewCtrl_VideoCtrl;
  return videoctrl_;
}
inline ::TvWall::Packet_Ctrl_ViewCtrl_VideoCtrl* Packet_Ctrl_ViewCtrl::release_videoctrl() {
  clear_has_videoctrl();
  ::TvWall::Packet_Ctrl_ViewCtrl_VideoCtrl* temp = videoctrl_;
  videoctrl_ = NULL;
  return temp;
}
inline void Packet_Ctrl_ViewCtrl::set_allocated_videoctrl(::TvWall::Packet_Ctrl_ViewCtrl_VideoCtrl* videoctrl) {
  delete videoctrl_;
  videoctrl_ = videoctrl;
  if (videoctrl) {
    set_has_videoctrl();
  } else {
    clear_has_videoctrl();
  }
}

// optional .TvWall.Packet.Ctrl.ViewCtrl.FlashCtrl flashCtrl = 2;
inline bool Packet_Ctrl_ViewCtrl::has_flashctrl() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Packet_Ctrl_ViewCtrl::set_has_flashctrl() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Packet_Ctrl_ViewCtrl::clear_has_flashctrl() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Packet_Ctrl_ViewCtrl::clear_flashctrl() {
  if (flashctrl_ != NULL) flashctrl_->::TvWall::Packet_Ctrl_ViewCtrl_FlashCtrl::Clear();
  clear_has_flashctrl();
}
inline const ::TvWall::Packet_Ctrl_ViewCtrl_FlashCtrl& Packet_Ctrl_ViewCtrl::flashctrl() const {
  return flashctrl_ != NULL ? *flashctrl_ : *default_instance_->flashctrl_;
}
inline ::TvWall::Packet_Ctrl_ViewCtrl_FlashCtrl* Packet_Ctrl_ViewCtrl::mutable_flashctrl() {
  set_has_flashctrl();
  if (flashctrl_ == NULL) flashctrl_ = new ::TvWall::Packet_Ctrl_ViewCtrl_FlashCtrl;
  return flashctrl_;
}
inline ::TvWall::Packet_Ctrl_ViewCtrl_FlashCtrl* Packet_Ctrl_ViewCtrl::release_flashctrl() {
  clear_has_flashctrl();
  ::TvWall::Packet_Ctrl_ViewCtrl_FlashCtrl* temp = flashctrl_;
  flashctrl_ = NULL;
  return temp;
}
inline void Packet_Ctrl_ViewCtrl::set_allocated_flashctrl(::TvWall::Packet_Ctrl_ViewCtrl_FlashCtrl* flashctrl) {
  delete flashctrl_;
  flashctrl_ = flashctrl;
  if (flashctrl) {
    set_has_flashctrl();
  } else {
    clear_has_flashctrl();
  }
}

// optional .TvWall.Packet.Ctrl.ViewCtrl.HTMLCtrl htmlCtrl = 3;
inline bool Packet_Ctrl_ViewCtrl::has_htmlctrl() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Packet_Ctrl_ViewCtrl::set_has_htmlctrl() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Packet_Ctrl_ViewCtrl::clear_has_htmlctrl() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Packet_Ctrl_ViewCtrl::clear_htmlctrl() {
  if (htmlctrl_ != NULL) htmlctrl_->::TvWall::Packet_Ctrl_ViewCtrl_HTMLCtrl::Clear();
  clear_has_htmlctrl();
}
inline const ::TvWall::Packet_Ctrl_ViewCtrl_HTMLCtrl& Packet_Ctrl_ViewCtrl::htmlctrl() const {
  return htmlctrl_ != NULL ? *htmlctrl_ : *default_instance_->htmlctrl_;
}
inline ::TvWall::Packet_Ctrl_ViewCtrl_HTMLCtrl* Packet_Ctrl_ViewCtrl::mutable_htmlctrl() {
  set_has_htmlctrl();
  if (htmlctrl_ == NULL) htmlctrl_ = new ::TvWall::Packet_Ctrl_ViewCtrl_HTMLCtrl;
  return htmlctrl_;
}
inline ::TvWall::Packet_Ctrl_ViewCtrl_HTMLCtrl* Packet_Ctrl_ViewCtrl::release_htmlctrl() {
  clear_has_htmlctrl();
  ::TvWall::Packet_Ctrl_ViewCtrl_HTMLCtrl* temp = htmlctrl_;
  htmlctrl_ = NULL;
  return temp;
}
inline void Packet_Ctrl_ViewCtrl::set_allocated_htmlctrl(::TvWall::Packet_Ctrl_ViewCtrl_HTMLCtrl* htmlctrl) {
  delete htmlctrl_;
  htmlctrl_ = htmlctrl;
  if (htmlctrl) {
    set_has_htmlctrl();
  } else {
    clear_has_htmlctrl();
  }
}

// optional .TvWall.Packet.Ctrl.ViewCtrl.TextCtrl textCtrl = 4;
inline bool Packet_Ctrl_ViewCtrl::has_textctrl() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Packet_Ctrl_ViewCtrl::set_has_textctrl() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Packet_Ctrl_ViewCtrl::clear_has_textctrl() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Packet_Ctrl_ViewCtrl::clear_textctrl() {
  if (textctrl_ != NULL) textctrl_->::TvWall::Packet_Ctrl_ViewCtrl_TextCtrl::Clear();
  clear_has_textctrl();
}
inline const ::TvWall::Packet_Ctrl_ViewCtrl_TextCtrl& Packet_Ctrl_ViewCtrl::textctrl() const {
  return textctrl_ != NULL ? *textctrl_ : *default_instance_->textctrl_;
}
inline ::TvWall::Packet_Ctrl_ViewCtrl_TextCtrl* Packet_Ctrl_ViewCtrl::mutable_textctrl() {
  set_has_textctrl();
  if (textctrl_ == NULL) textctrl_ = new ::TvWall::Packet_Ctrl_ViewCtrl_TextCtrl;
  return textctrl_;
}
inline ::TvWall::Packet_Ctrl_ViewCtrl_TextCtrl* Packet_Ctrl_ViewCtrl::release_textctrl() {
  clear_has_textctrl();
  ::TvWall::Packet_Ctrl_ViewCtrl_TextCtrl* temp = textctrl_;
  textctrl_ = NULL;
  return temp;
}
inline void Packet_Ctrl_ViewCtrl::set_allocated_textctrl(::TvWall::Packet_Ctrl_ViewCtrl_TextCtrl* textctrl) {
  delete textctrl_;
  textctrl_ = textctrl;
  if (textctrl) {
    set_has_textctrl();
  } else {
    clear_has_textctrl();
  }
}

// optional .TvWall.Packet.Ctrl.ViewCtrl.OthersCtrl othersCtrl = 5;
inline bool Packet_Ctrl_ViewCtrl::has_othersctrl() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Packet_Ctrl_ViewCtrl::set_has_othersctrl() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Packet_Ctrl_ViewCtrl::clear_has_othersctrl() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Packet_Ctrl_ViewCtrl::clear_othersctrl() {
  if (othersctrl_ != NULL) othersctrl_->::TvWall::Packet_Ctrl_ViewCtrl_OthersCtrl::Clear();
  clear_has_othersctrl();
}
inline const ::TvWall::Packet_Ctrl_ViewCtrl_OthersCtrl& Packet_Ctrl_ViewCtrl::othersctrl() const {
  return othersctrl_ != NULL ? *othersctrl_ : *default_instance_->othersctrl_;
}
inline ::TvWall::Packet_Ctrl_ViewCtrl_OthersCtrl* Packet_Ctrl_ViewCtrl::mutable_othersctrl() {
  set_has_othersctrl();
  if (othersctrl_ == NULL) othersctrl_ = new ::TvWall::Packet_Ctrl_ViewCtrl_OthersCtrl;
  return othersctrl_;
}
inline ::TvWall::Packet_Ctrl_ViewCtrl_OthersCtrl* Packet_Ctrl_ViewCtrl::release_othersctrl() {
  clear_has_othersctrl();
  ::TvWall::Packet_Ctrl_ViewCtrl_OthersCtrl* temp = othersctrl_;
  othersctrl_ = NULL;
  return temp;
}
inline void Packet_Ctrl_ViewCtrl::set_allocated_othersctrl(::TvWall::Packet_Ctrl_ViewCtrl_OthersCtrl* othersctrl) {
  delete othersctrl_;
  othersctrl_ = othersctrl;
  if (othersctrl) {
    set_has_othersctrl();
  } else {
    clear_has_othersctrl();
  }
}

// optional .TvWall.Packet.Ctrl.ViewCtrl.LocalMovieCtrl localMovie = 6;
inline bool Packet_Ctrl_ViewCtrl::has_localmovie() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Packet_Ctrl_ViewCtrl::set_has_localmovie() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Packet_Ctrl_ViewCtrl::clear_has_localmovie() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Packet_Ctrl_ViewCtrl::clear_localmovie() {
  if (localmovie_ != NULL) localmovie_->::TvWall::Packet_Ctrl_ViewCtrl_LocalMovieCtrl::Clear();
  clear_has_localmovie();
}
inline const ::TvWall::Packet_Ctrl_ViewCtrl_LocalMovieCtrl& Packet_Ctrl_ViewCtrl::localmovie() const {
  return localmovie_ != NULL ? *localmovie_ : *default_instance_->localmovie_;
}
inline ::TvWall::Packet_Ctrl_ViewCtrl_LocalMovieCtrl* Packet_Ctrl_ViewCtrl::mutable_localmovie() {
  set_has_localmovie();
  if (localmovie_ == NULL) localmovie_ = new ::TvWall::Packet_Ctrl_ViewCtrl_LocalMovieCtrl;
  return localmovie_;
}
inline ::TvWall::Packet_Ctrl_ViewCtrl_LocalMovieCtrl* Packet_Ctrl_ViewCtrl::release_localmovie() {
  clear_has_localmovie();
  ::TvWall::Packet_Ctrl_ViewCtrl_LocalMovieCtrl* temp = localmovie_;
  localmovie_ = NULL;
  return temp;
}
inline void Packet_Ctrl_ViewCtrl::set_allocated_localmovie(::TvWall::Packet_Ctrl_ViewCtrl_LocalMovieCtrl* localmovie) {
  delete localmovie_;
  localmovie_ = localmovie;
  if (localmovie) {
    set_has_localmovie();
  } else {
    clear_has_localmovie();
  }
}

// optional .TvWall.Packet.Ctrl.ViewCtrl.ViewGeomotryCtrl viewGeomotryCtrl = 7;
inline bool Packet_Ctrl_ViewCtrl::has_viewgeomotryctrl() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Packet_Ctrl_ViewCtrl::set_has_viewgeomotryctrl() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Packet_Ctrl_ViewCtrl::clear_has_viewgeomotryctrl() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Packet_Ctrl_ViewCtrl::clear_viewgeomotryctrl() {
  if (viewgeomotryctrl_ != NULL) viewgeomotryctrl_->::TvWall::Packet_Ctrl_ViewCtrl_ViewGeomotryCtrl::Clear();
  clear_has_viewgeomotryctrl();
}
inline const ::TvWall::Packet_Ctrl_ViewCtrl_ViewGeomotryCtrl& Packet_Ctrl_ViewCtrl::viewgeomotryctrl() const {
  return viewgeomotryctrl_ != NULL ? *viewgeomotryctrl_ : *default_instance_->viewgeomotryctrl_;
}
inline ::TvWall::Packet_Ctrl_ViewCtrl_ViewGeomotryCtrl* Packet_Ctrl_ViewCtrl::mutable_viewgeomotryctrl() {
  set_has_viewgeomotryctrl();
  if (viewgeomotryctrl_ == NULL) viewgeomotryctrl_ = new ::TvWall::Packet_Ctrl_ViewCtrl_ViewGeomotryCtrl;
  return viewgeomotryctrl_;
}
inline ::TvWall::Packet_Ctrl_ViewCtrl_ViewGeomotryCtrl* Packet_Ctrl_ViewCtrl::release_viewgeomotryctrl() {
  clear_has_viewgeomotryctrl();
  ::TvWall::Packet_Ctrl_ViewCtrl_ViewGeomotryCtrl* temp = viewgeomotryctrl_;
  viewgeomotryctrl_ = NULL;
  return temp;
}
inline void Packet_Ctrl_ViewCtrl::set_allocated_viewgeomotryctrl(::TvWall::Packet_Ctrl_ViewCtrl_ViewGeomotryCtrl* viewgeomotryctrl) {
  delete viewgeomotryctrl_;
  viewgeomotryctrl_ = viewgeomotryctrl;
  if (viewgeomotryctrl) {
    set_has_viewgeomotryctrl();
  } else {
    clear_has_viewgeomotryctrl();
  }
}

// optional .TvWall.Packet.Ctrl.ViewCtrl.MapCtrl mapCtrl = 8;
inline bool Packet_Ctrl_ViewCtrl::has_mapctrl() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Packet_Ctrl_ViewCtrl::set_has_mapctrl() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Packet_Ctrl_ViewCtrl::clear_has_mapctrl() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Packet_Ctrl_ViewCtrl::clear_mapctrl() {
  if (mapctrl_ != NULL) mapctrl_->::TvWall::Packet_Ctrl_ViewCtrl_MapCtrl::Clear();
  clear_has_mapctrl();
}
inline const ::TvWall::Packet_Ctrl_ViewCtrl_MapCtrl& Packet_Ctrl_ViewCtrl::mapctrl() const {
  return mapctrl_ != NULL ? *mapctrl_ : *default_instance_->mapctrl_;
}
inline ::TvWall::Packet_Ctrl_ViewCtrl_MapCtrl* Packet_Ctrl_ViewCtrl::mutable_mapctrl() {
  set_has_mapctrl();
  if (mapctrl_ == NULL) mapctrl_ = new ::TvWall::Packet_Ctrl_ViewCtrl_MapCtrl;
  return mapctrl_;
}
inline ::TvWall::Packet_Ctrl_ViewCtrl_MapCtrl* Packet_Ctrl_ViewCtrl::release_mapctrl() {
  clear_has_mapctrl();
  ::TvWall::Packet_Ctrl_ViewCtrl_MapCtrl* temp = mapctrl_;
  mapctrl_ = NULL;
  return temp;
}
inline void Packet_Ctrl_ViewCtrl::set_allocated_mapctrl(::TvWall::Packet_Ctrl_ViewCtrl_MapCtrl* mapctrl) {
  delete mapctrl_;
  mapctrl_ = mapctrl;
  if (mapctrl) {
    set_has_mapctrl();
  } else {
    clear_has_mapctrl();
  }
}

// optional .TvWall.Packet.Ctrl.ViewCtrl.RecordCtrl recordCtrl = 9;
inline bool Packet_Ctrl_ViewCtrl::has_recordctrl() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Packet_Ctrl_ViewCtrl::set_has_recordctrl() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Packet_Ctrl_ViewCtrl::clear_has_recordctrl() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Packet_Ctrl_ViewCtrl::clear_recordctrl() {
  if (recordctrl_ != NULL) recordctrl_->::TvWall::Packet_Ctrl_ViewCtrl_RecordCtrl::Clear();
  clear_has_recordctrl();
}
inline const ::TvWall::Packet_Ctrl_ViewCtrl_RecordCtrl& Packet_Ctrl_ViewCtrl::recordctrl() const {
  return recordctrl_ != NULL ? *recordctrl_ : *default_instance_->recordctrl_;
}
inline ::TvWall::Packet_Ctrl_ViewCtrl_RecordCtrl* Packet_Ctrl_ViewCtrl::mutable_recordctrl() {
  set_has_recordctrl();
  if (recordctrl_ == NULL) recordctrl_ = new ::TvWall::Packet_Ctrl_ViewCtrl_RecordCtrl;
  return recordctrl_;
}
inline ::TvWall::Packet_Ctrl_ViewCtrl_RecordCtrl* Packet_Ctrl_ViewCtrl::release_recordctrl() {
  clear_has_recordctrl();
  ::TvWall::Packet_Ctrl_ViewCtrl_RecordCtrl* temp = recordctrl_;
  recordctrl_ = NULL;
  return temp;
}
inline void Packet_Ctrl_ViewCtrl::set_allocated_recordctrl(::TvWall::Packet_Ctrl_ViewCtrl_RecordCtrl* recordctrl) {
  delete recordctrl_;
  recordctrl_ = recordctrl;
  if (recordctrl) {
    set_has_recordctrl();
  } else {
    clear_has_recordctrl();
  }
}

// -------------------------------------------------------------------

// Packet_Ctrl_CameraCtrl

// required .TvWall.Packet.Ctrl.CameraCtrl.PTZ_TYPE type = 1;
inline bool Packet_Ctrl_CameraCtrl::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Packet_Ctrl_CameraCtrl::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Packet_Ctrl_CameraCtrl::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Packet_Ctrl_CameraCtrl::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::TvWall::Packet_Ctrl_CameraCtrl_PTZ_TYPE Packet_Ctrl_CameraCtrl::type() const {
  return static_cast< ::TvWall::Packet_Ctrl_CameraCtrl_PTZ_TYPE >(type_);
}
inline void Packet_Ctrl_CameraCtrl::set_type(::TvWall::Packet_Ctrl_CameraCtrl_PTZ_TYPE value) {
  assert(::TvWall::Packet_Ctrl_CameraCtrl_PTZ_TYPE_IsValid(value));
  set_has_type();
  type_ = value;
}

// required .TvWall.Guid cameraId = 2;
inline bool Packet_Ctrl_CameraCtrl::has_cameraid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Packet_Ctrl_CameraCtrl::set_has_cameraid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Packet_Ctrl_CameraCtrl::clear_has_cameraid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Packet_Ctrl_CameraCtrl::clear_cameraid() {
  if (cameraid_ != NULL) cameraid_->::TvWall::Guid::Clear();
  clear_has_cameraid();
}
inline const ::TvWall::Guid& Packet_Ctrl_CameraCtrl::cameraid() const {
  return cameraid_ != NULL ? *cameraid_ : *default_instance_->cameraid_;
}
inline ::TvWall::Guid* Packet_Ctrl_CameraCtrl::mutable_cameraid() {
  set_has_cameraid();
  if (cameraid_ == NULL) cameraid_ = new ::TvWall::Guid;
  return cameraid_;
}
inline ::TvWall::Guid* Packet_Ctrl_CameraCtrl::release_cameraid() {
  clear_has_cameraid();
  ::TvWall::Guid* temp = cameraid_;
  cameraid_ = NULL;
  return temp;
}
inline void Packet_Ctrl_CameraCtrl::set_allocated_cameraid(::TvWall::Guid* cameraid) {
  delete cameraid_;
  cameraid_ = cameraid;
  if (cameraid) {
    set_has_cameraid();
  } else {
    clear_has_cameraid();
  }
}

// -------------------------------------------------------------------

// Packet_Ctrl_HotPointCtrl

// required .TvWall.Packet.Ctrl.HotPointCtrl.HotPointCtrlType type = 1;
inline bool Packet_Ctrl_HotPointCtrl::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Packet_Ctrl_HotPointCtrl::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Packet_Ctrl_HotPointCtrl::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Packet_Ctrl_HotPointCtrl::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::TvWall::Packet_Ctrl_HotPointCtrl_HotPointCtrlType Packet_Ctrl_HotPointCtrl::type() const {
  return static_cast< ::TvWall::Packet_Ctrl_HotPointCtrl_HotPointCtrlType >(type_);
}
inline void Packet_Ctrl_HotPointCtrl::set_type(::TvWall::Packet_Ctrl_HotPointCtrl_HotPointCtrlType value) {
  assert(::TvWall::Packet_Ctrl_HotPointCtrl_HotPointCtrlType_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional .TvWall.Packet.ElementDat.HotPoint hotPoint = 2;
inline bool Packet_Ctrl_HotPointCtrl::has_hotpoint() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Packet_Ctrl_HotPointCtrl::set_has_hotpoint() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Packet_Ctrl_HotPointCtrl::clear_has_hotpoint() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Packet_Ctrl_HotPointCtrl::clear_hotpoint() {
  if (hotpoint_ != NULL) hotpoint_->::TvWall::Packet_ElementDat_HotPoint::Clear();
  clear_has_hotpoint();
}
inline const ::TvWall::Packet_ElementDat_HotPoint& Packet_Ctrl_HotPointCtrl::hotpoint() const {
  return hotpoint_ != NULL ? *hotpoint_ : *default_instance_->hotpoint_;
}
inline ::TvWall::Packet_ElementDat_HotPoint* Packet_Ctrl_HotPointCtrl::mutable_hotpoint() {
  set_has_hotpoint();
  if (hotpoint_ == NULL) hotpoint_ = new ::TvWall::Packet_ElementDat_HotPoint;
  return hotpoint_;
}
inline ::TvWall::Packet_ElementDat_HotPoint* Packet_Ctrl_HotPointCtrl::release_hotpoint() {
  clear_has_hotpoint();
  ::TvWall::Packet_ElementDat_HotPoint* temp = hotpoint_;
  hotpoint_ = NULL;
  return temp;
}
inline void Packet_Ctrl_HotPointCtrl::set_allocated_hotpoint(::TvWall::Packet_ElementDat_HotPoint* hotpoint) {
  delete hotpoint_;
  hotpoint_ = hotpoint;
  if (hotpoint) {
    set_has_hotpoint();
  } else {
    clear_has_hotpoint();
  }
}

// -------------------------------------------------------------------

// Packet_Ctrl_LayoutCtrl

// required string lyoutName = 1;
inline bool Packet_Ctrl_LayoutCtrl::has_lyoutname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Packet_Ctrl_LayoutCtrl::set_has_lyoutname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Packet_Ctrl_LayoutCtrl::clear_has_lyoutname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Packet_Ctrl_LayoutCtrl::clear_lyoutname() {
  if (lyoutname_ != &::google::protobuf::internal::kEmptyString) {
    lyoutname_->clear();
  }
  clear_has_lyoutname();
}
inline const ::std::string& Packet_Ctrl_LayoutCtrl::lyoutname() const {
  return *lyoutname_;
}
inline void Packet_Ctrl_LayoutCtrl::set_lyoutname(const ::std::string& value) {
  set_has_lyoutname();
  if (lyoutname_ == &::google::protobuf::internal::kEmptyString) {
    lyoutname_ = new ::std::string;
  }
  lyoutname_->assign(value);
}
inline void Packet_Ctrl_LayoutCtrl::set_lyoutname(const char* value) {
  set_has_lyoutname();
  if (lyoutname_ == &::google::protobuf::internal::kEmptyString) {
    lyoutname_ = new ::std::string;
  }
  lyoutname_->assign(value);
}
inline void Packet_Ctrl_LayoutCtrl::set_lyoutname(const char* value, size_t size) {
  set_has_lyoutname();
  if (lyoutname_ == &::google::protobuf::internal::kEmptyString) {
    lyoutname_ = new ::std::string;
  }
  lyoutname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Packet_Ctrl_LayoutCtrl::mutable_lyoutname() {
  set_has_lyoutname();
  if (lyoutname_ == &::google::protobuf::internal::kEmptyString) {
    lyoutname_ = new ::std::string;
  }
  return lyoutname_;
}
inline ::std::string* Packet_Ctrl_LayoutCtrl::release_lyoutname() {
  clear_has_lyoutname();
  if (lyoutname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = lyoutname_;
    lyoutname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Packet_Ctrl_LayoutCtrl::set_allocated_lyoutname(::std::string* lyoutname) {
  if (lyoutname_ != &::google::protobuf::internal::kEmptyString) {
    delete lyoutname_;
  }
  if (lyoutname) {
    set_has_lyoutname();
    lyoutname_ = lyoutname;
  } else {
    clear_has_lyoutname();
    lyoutname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required .TvWall.Packet.Ctrl.LayoutCtrl.LayoutCtrlType type = 3;
inline bool Packet_Ctrl_LayoutCtrl::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Packet_Ctrl_LayoutCtrl::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Packet_Ctrl_LayoutCtrl::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Packet_Ctrl_LayoutCtrl::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::TvWall::Packet_Ctrl_LayoutCtrl_LayoutCtrlType Packet_Ctrl_LayoutCtrl::type() const {
  return static_cast< ::TvWall::Packet_Ctrl_LayoutCtrl_LayoutCtrlType >(type_);
}
inline void Packet_Ctrl_LayoutCtrl::set_type(::TvWall::Packet_Ctrl_LayoutCtrl_LayoutCtrlType value) {
  assert(::TvWall::Packet_Ctrl_LayoutCtrl_LayoutCtrlType_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional bool isalarm = 2;
inline bool Packet_Ctrl_LayoutCtrl::has_isalarm() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Packet_Ctrl_LayoutCtrl::set_has_isalarm() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Packet_Ctrl_LayoutCtrl::clear_has_isalarm() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Packet_Ctrl_LayoutCtrl::clear_isalarm() {
  isalarm_ = false;
  clear_has_isalarm();
}
inline bool Packet_Ctrl_LayoutCtrl::isalarm() const {
  return isalarm_;
}
inline void Packet_Ctrl_LayoutCtrl::set_isalarm(bool value) {
  set_has_isalarm();
  isalarm_ = value;
}

// optional int32 alarmInterval = 4;
inline bool Packet_Ctrl_LayoutCtrl::has_alarminterval() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Packet_Ctrl_LayoutCtrl::set_has_alarminterval() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Packet_Ctrl_LayoutCtrl::clear_has_alarminterval() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Packet_Ctrl_LayoutCtrl::clear_alarminterval() {
  alarminterval_ = 0;
  clear_has_alarminterval();
}
inline ::google::protobuf::int32 Packet_Ctrl_LayoutCtrl::alarminterval() const {
  return alarminterval_;
}
inline void Packet_Ctrl_LayoutCtrl::set_alarminterval(::google::protobuf::int32 value) {
  set_has_alarminterval();
  alarminterval_ = value;
}

// -------------------------------------------------------------------

// Packet_Ctrl_LayoutLoopCtrl

// required string lyoutLoopName = 1;
inline bool Packet_Ctrl_LayoutLoopCtrl::has_lyoutloopname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Packet_Ctrl_LayoutLoopCtrl::set_has_lyoutloopname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Packet_Ctrl_LayoutLoopCtrl::clear_has_lyoutloopname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Packet_Ctrl_LayoutLoopCtrl::clear_lyoutloopname() {
  if (lyoutloopname_ != &::google::protobuf::internal::kEmptyString) {
    lyoutloopname_->clear();
  }
  clear_has_lyoutloopname();
}
inline const ::std::string& Packet_Ctrl_LayoutLoopCtrl::lyoutloopname() const {
  return *lyoutloopname_;
}
inline void Packet_Ctrl_LayoutLoopCtrl::set_lyoutloopname(const ::std::string& value) {
  set_has_lyoutloopname();
  if (lyoutloopname_ == &::google::protobuf::internal::kEmptyString) {
    lyoutloopname_ = new ::std::string;
  }
  lyoutloopname_->assign(value);
}
inline void Packet_Ctrl_LayoutLoopCtrl::set_lyoutloopname(const char* value) {
  set_has_lyoutloopname();
  if (lyoutloopname_ == &::google::protobuf::internal::kEmptyString) {
    lyoutloopname_ = new ::std::string;
  }
  lyoutloopname_->assign(value);
}
inline void Packet_Ctrl_LayoutLoopCtrl::set_lyoutloopname(const char* value, size_t size) {
  set_has_lyoutloopname();
  if (lyoutloopname_ == &::google::protobuf::internal::kEmptyString) {
    lyoutloopname_ = new ::std::string;
  }
  lyoutloopname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Packet_Ctrl_LayoutLoopCtrl::mutable_lyoutloopname() {
  set_has_lyoutloopname();
  if (lyoutloopname_ == &::google::protobuf::internal::kEmptyString) {
    lyoutloopname_ = new ::std::string;
  }
  return lyoutloopname_;
}
inline ::std::string* Packet_Ctrl_LayoutLoopCtrl::release_lyoutloopname() {
  clear_has_lyoutloopname();
  if (lyoutloopname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = lyoutloopname_;
    lyoutloopname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Packet_Ctrl_LayoutLoopCtrl::set_allocated_lyoutloopname(::std::string* lyoutloopname) {
  if (lyoutloopname_ != &::google::protobuf::internal::kEmptyString) {
    delete lyoutloopname_;
  }
  if (lyoutloopname) {
    set_has_lyoutloopname();
    lyoutloopname_ = lyoutloopname;
  } else {
    clear_has_lyoutloopname();
    lyoutloopname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required .TvWall.Packet.Ctrl.LayoutLoopCtrl.LayoutLoopCtrlType type = 2;
inline bool Packet_Ctrl_LayoutLoopCtrl::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Packet_Ctrl_LayoutLoopCtrl::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Packet_Ctrl_LayoutLoopCtrl::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Packet_Ctrl_LayoutLoopCtrl::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::TvWall::Packet_Ctrl_LayoutLoopCtrl_LayoutLoopCtrlType Packet_Ctrl_LayoutLoopCtrl::type() const {
  return static_cast< ::TvWall::Packet_Ctrl_LayoutLoopCtrl_LayoutLoopCtrlType >(type_);
}
inline void Packet_Ctrl_LayoutLoopCtrl::set_type(::TvWall::Packet_Ctrl_LayoutLoopCtrl_LayoutLoopCtrlType value) {
  assert(::TvWall::Packet_Ctrl_LayoutLoopCtrl_LayoutLoopCtrlType_IsValid(value));
  set_has_type();
  type_ = value;
}

// repeated string layoutName = 3;
inline int Packet_Ctrl_LayoutLoopCtrl::layoutname_size() const {
  return layoutname_.size();
}
inline void Packet_Ctrl_LayoutLoopCtrl::clear_layoutname() {
  layoutname_.Clear();
}
inline const ::std::string& Packet_Ctrl_LayoutLoopCtrl::layoutname(int index) const {
  return layoutname_.Get(index);
}
inline ::std::string* Packet_Ctrl_LayoutLoopCtrl::mutable_layoutname(int index) {
  return layoutname_.Mutable(index);
}
inline void Packet_Ctrl_LayoutLoopCtrl::set_layoutname(int index, const ::std::string& value) {
  layoutname_.Mutable(index)->assign(value);
}
inline void Packet_Ctrl_LayoutLoopCtrl::set_layoutname(int index, const char* value) {
  layoutname_.Mutable(index)->assign(value);
}
inline void Packet_Ctrl_LayoutLoopCtrl::set_layoutname(int index, const char* value, size_t size) {
  layoutname_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Packet_Ctrl_LayoutLoopCtrl::add_layoutname() {
  return layoutname_.Add();
}
inline void Packet_Ctrl_LayoutLoopCtrl::add_layoutname(const ::std::string& value) {
  layoutname_.Add()->assign(value);
}
inline void Packet_Ctrl_LayoutLoopCtrl::add_layoutname(const char* value) {
  layoutname_.Add()->assign(value);
}
inline void Packet_Ctrl_LayoutLoopCtrl::add_layoutname(const char* value, size_t size) {
  layoutname_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Packet_Ctrl_LayoutLoopCtrl::layoutname() const {
  return layoutname_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Packet_Ctrl_LayoutLoopCtrl::mutable_layoutname() {
  return &layoutname_;
}

// optional uint32 loop = 4;
inline bool Packet_Ctrl_LayoutLoopCtrl::has_loop() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Packet_Ctrl_LayoutLoopCtrl::set_has_loop() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Packet_Ctrl_LayoutLoopCtrl::clear_has_loop() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Packet_Ctrl_LayoutLoopCtrl::clear_loop() {
  loop_ = 0u;
  clear_has_loop();
}
inline ::google::protobuf::uint32 Packet_Ctrl_LayoutLoopCtrl::loop() const {
  return loop_;
}
inline void Packet_Ctrl_LayoutLoopCtrl::set_loop(::google::protobuf::uint32 value) {
  set_has_loop();
  loop_ = value;
}

// -------------------------------------------------------------------

// Packet_Ctrl_CtrlMaster_CtrlMasterLyout

// required .TvWall.Packet.Ctrl.CtrlMaster.CtrlMasterLyout.CMLType type = 1;
inline bool Packet_Ctrl_CtrlMaster_CtrlMasterLyout::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Packet_Ctrl_CtrlMaster_CtrlMasterLyout::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Packet_Ctrl_CtrlMaster_CtrlMasterLyout::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Packet_Ctrl_CtrlMaster_CtrlMasterLyout::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::TvWall::Packet_Ctrl_CtrlMaster_CtrlMasterLyout_CMLType Packet_Ctrl_CtrlMaster_CtrlMasterLyout::type() const {
  return static_cast< ::TvWall::Packet_Ctrl_CtrlMaster_CtrlMasterLyout_CMLType >(type_);
}
inline void Packet_Ctrl_CtrlMaster_CtrlMasterLyout::set_type(::TvWall::Packet_Ctrl_CtrlMaster_CtrlMasterLyout_CMLType value) {
  assert(::TvWall::Packet_Ctrl_CtrlMaster_CtrlMasterLyout_CMLType_IsValid(value));
  set_has_type();
  type_ = value;
}

// required .TvWall.Packet.ElementMaster.MasterLayout.MasLayout masterLayout = 2;
inline bool Packet_Ctrl_CtrlMaster_CtrlMasterLyout::has_masterlayout() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Packet_Ctrl_CtrlMaster_CtrlMasterLyout::set_has_masterlayout() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Packet_Ctrl_CtrlMaster_CtrlMasterLyout::clear_has_masterlayout() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Packet_Ctrl_CtrlMaster_CtrlMasterLyout::clear_masterlayout() {
  if (masterlayout_ != NULL) masterlayout_->::TvWall::Packet_ElementMaster_MasterLayout_MasLayout::Clear();
  clear_has_masterlayout();
}
inline const ::TvWall::Packet_ElementMaster_MasterLayout_MasLayout& Packet_Ctrl_CtrlMaster_CtrlMasterLyout::masterlayout() const {
  return masterlayout_ != NULL ? *masterlayout_ : *default_instance_->masterlayout_;
}
inline ::TvWall::Packet_ElementMaster_MasterLayout_MasLayout* Packet_Ctrl_CtrlMaster_CtrlMasterLyout::mutable_masterlayout() {
  set_has_masterlayout();
  if (masterlayout_ == NULL) masterlayout_ = new ::TvWall::Packet_ElementMaster_MasterLayout_MasLayout;
  return masterlayout_;
}
inline ::TvWall::Packet_ElementMaster_MasterLayout_MasLayout* Packet_Ctrl_CtrlMaster_CtrlMasterLyout::release_masterlayout() {
  clear_has_masterlayout();
  ::TvWall::Packet_ElementMaster_MasterLayout_MasLayout* temp = masterlayout_;
  masterlayout_ = NULL;
  return temp;
}
inline void Packet_Ctrl_CtrlMaster_CtrlMasterLyout::set_allocated_masterlayout(::TvWall::Packet_ElementMaster_MasterLayout_MasLayout* masterlayout) {
  delete masterlayout_;
  masterlayout_ = masterlayout;
  if (masterlayout) {
    set_has_masterlayout();
  } else {
    clear_has_masterlayout();
  }
}

// -------------------------------------------------------------------

// Packet_Ctrl_CtrlMaster

// optional .TvWall.Packet.Ctrl.CtrlMaster.CtrlMasterLyout ctrlLyout = 1;
inline bool Packet_Ctrl_CtrlMaster::has_ctrllyout() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Packet_Ctrl_CtrlMaster::set_has_ctrllyout() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Packet_Ctrl_CtrlMaster::clear_has_ctrllyout() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Packet_Ctrl_CtrlMaster::clear_ctrllyout() {
  if (ctrllyout_ != NULL) ctrllyout_->::TvWall::Packet_Ctrl_CtrlMaster_CtrlMasterLyout::Clear();
  clear_has_ctrllyout();
}
inline const ::TvWall::Packet_Ctrl_CtrlMaster_CtrlMasterLyout& Packet_Ctrl_CtrlMaster::ctrllyout() const {
  return ctrllyout_ != NULL ? *ctrllyout_ : *default_instance_->ctrllyout_;
}
inline ::TvWall::Packet_Ctrl_CtrlMaster_CtrlMasterLyout* Packet_Ctrl_CtrlMaster::mutable_ctrllyout() {
  set_has_ctrllyout();
  if (ctrllyout_ == NULL) ctrllyout_ = new ::TvWall::Packet_Ctrl_CtrlMaster_CtrlMasterLyout;
  return ctrllyout_;
}
inline ::TvWall::Packet_Ctrl_CtrlMaster_CtrlMasterLyout* Packet_Ctrl_CtrlMaster::release_ctrllyout() {
  clear_has_ctrllyout();
  ::TvWall::Packet_Ctrl_CtrlMaster_CtrlMasterLyout* temp = ctrllyout_;
  ctrllyout_ = NULL;
  return temp;
}
inline void Packet_Ctrl_CtrlMaster::set_allocated_ctrllyout(::TvWall::Packet_Ctrl_CtrlMaster_CtrlMasterLyout* ctrllyout) {
  delete ctrllyout_;
  ctrllyout_ = ctrllyout;
  if (ctrllyout) {
    set_has_ctrllyout();
  } else {
    clear_has_ctrllyout();
  }
}

// -------------------------------------------------------------------

// Packet_Ctrl_MachineCtrl

// required .TvWall.Packet.Ctrl.MachineCtrl.MachineCtrlType type = 1;
inline bool Packet_Ctrl_MachineCtrl::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Packet_Ctrl_MachineCtrl::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Packet_Ctrl_MachineCtrl::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Packet_Ctrl_MachineCtrl::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::TvWall::Packet_Ctrl_MachineCtrl_MachineCtrlType Packet_Ctrl_MachineCtrl::type() const {
  return static_cast< ::TvWall::Packet_Ctrl_MachineCtrl_MachineCtrlType >(type_);
}
inline void Packet_Ctrl_MachineCtrl::set_type(::TvWall::Packet_Ctrl_MachineCtrl_MachineCtrlType value) {
  assert(::TvWall::Packet_Ctrl_MachineCtrl_MachineCtrlType_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional string screenMode = 2;
inline bool Packet_Ctrl_MachineCtrl::has_screenmode() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Packet_Ctrl_MachineCtrl::set_has_screenmode() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Packet_Ctrl_MachineCtrl::clear_has_screenmode() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Packet_Ctrl_MachineCtrl::clear_screenmode() {
  if (screenmode_ != &::google::protobuf::internal::kEmptyString) {
    screenmode_->clear();
  }
  clear_has_screenmode();
}
inline const ::std::string& Packet_Ctrl_MachineCtrl::screenmode() const {
  return *screenmode_;
}
inline void Packet_Ctrl_MachineCtrl::set_screenmode(const ::std::string& value) {
  set_has_screenmode();
  if (screenmode_ == &::google::protobuf::internal::kEmptyString) {
    screenmode_ = new ::std::string;
  }
  screenmode_->assign(value);
}
inline void Packet_Ctrl_MachineCtrl::set_screenmode(const char* value) {
  set_has_screenmode();
  if (screenmode_ == &::google::protobuf::internal::kEmptyString) {
    screenmode_ = new ::std::string;
  }
  screenmode_->assign(value);
}
inline void Packet_Ctrl_MachineCtrl::set_screenmode(const char* value, size_t size) {
  set_has_screenmode();
  if (screenmode_ == &::google::protobuf::internal::kEmptyString) {
    screenmode_ = new ::std::string;
  }
  screenmode_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Packet_Ctrl_MachineCtrl::mutable_screenmode() {
  set_has_screenmode();
  if (screenmode_ == &::google::protobuf::internal::kEmptyString) {
    screenmode_ = new ::std::string;
  }
  return screenmode_;
}
inline ::std::string* Packet_Ctrl_MachineCtrl::release_screenmode() {
  clear_has_screenmode();
  if (screenmode_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = screenmode_;
    screenmode_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Packet_Ctrl_MachineCtrl::set_allocated_screenmode(::std::string* screenmode) {
  if (screenmode_ != &::google::protobuf::internal::kEmptyString) {
    delete screenmode_;
  }
  if (screenmode) {
    set_has_screenmode();
    screenmode_ = screenmode;
  } else {
    clear_has_screenmode();
    screenmode_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .TvWall.NetInterface netInterface = 3;
inline bool Packet_Ctrl_MachineCtrl::has_netinterface() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Packet_Ctrl_MachineCtrl::set_has_netinterface() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Packet_Ctrl_MachineCtrl::clear_has_netinterface() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Packet_Ctrl_MachineCtrl::clear_netinterface() {
  if (netinterface_ != NULL) netinterface_->::TvWall::NetInterface::Clear();
  clear_has_netinterface();
}
inline const ::TvWall::NetInterface& Packet_Ctrl_MachineCtrl::netinterface() const {
  return netinterface_ != NULL ? *netinterface_ : *default_instance_->netinterface_;
}
inline ::TvWall::NetInterface* Packet_Ctrl_MachineCtrl::mutable_netinterface() {
  set_has_netinterface();
  if (netinterface_ == NULL) netinterface_ = new ::TvWall::NetInterface;
  return netinterface_;
}
inline ::TvWall::NetInterface* Packet_Ctrl_MachineCtrl::release_netinterface() {
  clear_has_netinterface();
  ::TvWall::NetInterface* temp = netinterface_;
  netinterface_ = NULL;
  return temp;
}
inline void Packet_Ctrl_MachineCtrl::set_allocated_netinterface(::TvWall::NetInterface* netinterface) {
  delete netinterface_;
  netinterface_ = netinterface;
  if (netinterface) {
    set_has_netinterface();
  } else {
    clear_has_netinterface();
  }
}

// optional .TvWall.Network network = 4;
inline bool Packet_Ctrl_MachineCtrl::has_network() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Packet_Ctrl_MachineCtrl::set_has_network() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Packet_Ctrl_MachineCtrl::clear_has_network() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Packet_Ctrl_MachineCtrl::clear_network() {
  if (network_ != NULL) network_->::TvWall::Network::Clear();
  clear_has_network();
}
inline const ::TvWall::Network& Packet_Ctrl_MachineCtrl::network() const {
  return network_ != NULL ? *network_ : *default_instance_->network_;
}
inline ::TvWall::Network* Packet_Ctrl_MachineCtrl::mutable_network() {
  set_has_network();
  if (network_ == NULL) network_ = new ::TvWall::Network;
  return network_;
}
inline ::TvWall::Network* Packet_Ctrl_MachineCtrl::release_network() {
  clear_has_network();
  ::TvWall::Network* temp = network_;
  network_ = NULL;
  return temp;
}
inline void Packet_Ctrl_MachineCtrl::set_allocated_network(::TvWall::Network* network) {
  delete network_;
  network_ = network;
  if (network) {
    set_has_network();
  } else {
    clear_has_network();
  }
}

// optional .TvWall.NVR nvr = 5;
inline bool Packet_Ctrl_MachineCtrl::has_nvr() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Packet_Ctrl_MachineCtrl::set_has_nvr() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Packet_Ctrl_MachineCtrl::clear_has_nvr() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Packet_Ctrl_MachineCtrl::clear_nvr() {
  if (nvr_ != NULL) nvr_->::TvWall::NVR::Clear();
  clear_has_nvr();
}
inline const ::TvWall::NVR& Packet_Ctrl_MachineCtrl::nvr() const {
  return nvr_ != NULL ? *nvr_ : *default_instance_->nvr_;
}
inline ::TvWall::NVR* Packet_Ctrl_MachineCtrl::mutable_nvr() {
  set_has_nvr();
  if (nvr_ == NULL) nvr_ = new ::TvWall::NVR;
  return nvr_;
}
inline ::TvWall::NVR* Packet_Ctrl_MachineCtrl::release_nvr() {
  clear_has_nvr();
  ::TvWall::NVR* temp = nvr_;
  nvr_ = NULL;
  return temp;
}
inline void Packet_Ctrl_MachineCtrl::set_allocated_nvr(::TvWall::NVR* nvr) {
  delete nvr_;
  nvr_ = nvr;
  if (nvr) {
    set_has_nvr();
  } else {
    clear_has_nvr();
  }
}

// optional .TvWall.FMP fmp = 6;
inline bool Packet_Ctrl_MachineCtrl::has_fmp() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Packet_Ctrl_MachineCtrl::set_has_fmp() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Packet_Ctrl_MachineCtrl::clear_has_fmp() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Packet_Ctrl_MachineCtrl::clear_fmp() {
  if (fmp_ != NULL) fmp_->::TvWall::FMP::Clear();
  clear_has_fmp();
}
inline const ::TvWall::FMP& Packet_Ctrl_MachineCtrl::fmp() const {
  return fmp_ != NULL ? *fmp_ : *default_instance_->fmp_;
}
inline ::TvWall::FMP* Packet_Ctrl_MachineCtrl::mutable_fmp() {
  set_has_fmp();
  if (fmp_ == NULL) fmp_ = new ::TvWall::FMP;
  return fmp_;
}
inline ::TvWall::FMP* Packet_Ctrl_MachineCtrl::release_fmp() {
  clear_has_fmp();
  ::TvWall::FMP* temp = fmp_;
  fmp_ = NULL;
  return temp;
}
inline void Packet_Ctrl_MachineCtrl::set_allocated_fmp(::TvWall::FMP* fmp) {
  delete fmp_;
  fmp_ = fmp;
  if (fmp) {
    set_has_fmp();
  } else {
    clear_has_fmp();
  }
}

// optional int32 tvwallindex = 7;
inline bool Packet_Ctrl_MachineCtrl::has_tvwallindex() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Packet_Ctrl_MachineCtrl::set_has_tvwallindex() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Packet_Ctrl_MachineCtrl::clear_has_tvwallindex() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Packet_Ctrl_MachineCtrl::clear_tvwallindex() {
  tvwallindex_ = 0;
  clear_has_tvwallindex();
}
inline ::google::protobuf::int32 Packet_Ctrl_MachineCtrl::tvwallindex() const {
  return tvwallindex_;
}
inline void Packet_Ctrl_MachineCtrl::set_tvwallindex(::google::protobuf::int32 value) {
  set_has_tvwallindex();
  tvwallindex_ = value;
}

// -------------------------------------------------------------------

// Packet_Ctrl_KeyCtrl

// required .TvWall.Packet.Ctrl.KeyCtrl.KeyType type = 1;
inline bool Packet_Ctrl_KeyCtrl::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Packet_Ctrl_KeyCtrl::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Packet_Ctrl_KeyCtrl::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Packet_Ctrl_KeyCtrl::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::TvWall::Packet_Ctrl_KeyCtrl_KeyType Packet_Ctrl_KeyCtrl::type() const {
  return static_cast< ::TvWall::Packet_Ctrl_KeyCtrl_KeyType >(type_);
}
inline void Packet_Ctrl_KeyCtrl::set_type(::TvWall::Packet_Ctrl_KeyCtrl_KeyType value) {
  assert(::TvWall::Packet_Ctrl_KeyCtrl_KeyType_IsValid(value));
  set_has_type();
  type_ = value;
}

// required int32 key = 2;
inline bool Packet_Ctrl_KeyCtrl::has_key() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Packet_Ctrl_KeyCtrl::set_has_key() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Packet_Ctrl_KeyCtrl::clear_has_key() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Packet_Ctrl_KeyCtrl::clear_key() {
  key_ = 0;
  clear_has_key();
}
inline ::google::protobuf::int32 Packet_Ctrl_KeyCtrl::key() const {
  return key_;
}
inline void Packet_Ctrl_KeyCtrl::set_key(::google::protobuf::int32 value) {
  set_has_key();
  key_ = value;
}

// required int32 modifiers = 3;
inline bool Packet_Ctrl_KeyCtrl::has_modifiers() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Packet_Ctrl_KeyCtrl::set_has_modifiers() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Packet_Ctrl_KeyCtrl::clear_has_modifiers() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Packet_Ctrl_KeyCtrl::clear_modifiers() {
  modifiers_ = 0;
  clear_has_modifiers();
}
inline ::google::protobuf::int32 Packet_Ctrl_KeyCtrl::modifiers() const {
  return modifiers_;
}
inline void Packet_Ctrl_KeyCtrl::set_modifiers(::google::protobuf::int32 value) {
  set_has_modifiers();
  modifiers_ = value;
}

// optional string text = 4;
inline bool Packet_Ctrl_KeyCtrl::has_text() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Packet_Ctrl_KeyCtrl::set_has_text() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Packet_Ctrl_KeyCtrl::clear_has_text() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Packet_Ctrl_KeyCtrl::clear_text() {
  if (text_ != &::google::protobuf::internal::kEmptyString) {
    text_->clear();
  }
  clear_has_text();
}
inline const ::std::string& Packet_Ctrl_KeyCtrl::text() const {
  return *text_;
}
inline void Packet_Ctrl_KeyCtrl::set_text(const ::std::string& value) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(value);
}
inline void Packet_Ctrl_KeyCtrl::set_text(const char* value) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(value);
}
inline void Packet_Ctrl_KeyCtrl::set_text(const char* value, size_t size) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Packet_Ctrl_KeyCtrl::mutable_text() {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  return text_;
}
inline ::std::string* Packet_Ctrl_KeyCtrl::release_text() {
  clear_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = text_;
    text_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Packet_Ctrl_KeyCtrl::set_allocated_text(::std::string* text) {
  if (text_ != &::google::protobuf::internal::kEmptyString) {
    delete text_;
  }
  if (text) {
    set_has_text();
    text_ = text;
  } else {
    clear_has_text();
    text_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool autoRepeat = 5;
inline bool Packet_Ctrl_KeyCtrl::has_autorepeat() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Packet_Ctrl_KeyCtrl::set_has_autorepeat() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Packet_Ctrl_KeyCtrl::clear_has_autorepeat() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Packet_Ctrl_KeyCtrl::clear_autorepeat() {
  autorepeat_ = false;
  clear_has_autorepeat();
}
inline bool Packet_Ctrl_KeyCtrl::autorepeat() const {
  return autorepeat_;
}
inline void Packet_Ctrl_KeyCtrl::set_autorepeat(bool value) {
  set_has_autorepeat();
  autorepeat_ = value;
}

// optional int32 count = 6;
inline bool Packet_Ctrl_KeyCtrl::has_count() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Packet_Ctrl_KeyCtrl::set_has_count() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Packet_Ctrl_KeyCtrl::clear_has_count() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Packet_Ctrl_KeyCtrl::clear_count() {
  count_ = 0;
  clear_has_count();
}
inline ::google::protobuf::int32 Packet_Ctrl_KeyCtrl::count() const {
  return count_;
}
inline void Packet_Ctrl_KeyCtrl::set_count(::google::protobuf::int32 value) {
  set_has_count();
  count_ = value;
}

// -------------------------------------------------------------------

// Packet_Ctrl_KeyCmdCtrl

// optional .TvWall.Packet.Ctrl.KeyCmdCtrl.KeyCmdType type = 1;
inline bool Packet_Ctrl_KeyCmdCtrl::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Packet_Ctrl_KeyCmdCtrl::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Packet_Ctrl_KeyCmdCtrl::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Packet_Ctrl_KeyCmdCtrl::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::TvWall::Packet_Ctrl_KeyCmdCtrl_KeyCmdType Packet_Ctrl_KeyCmdCtrl::type() const {
  return static_cast< ::TvWall::Packet_Ctrl_KeyCmdCtrl_KeyCmdType >(type_);
}
inline void Packet_Ctrl_KeyCmdCtrl::set_type(::TvWall::Packet_Ctrl_KeyCmdCtrl_KeyCmdType value) {
  assert(::TvWall::Packet_Ctrl_KeyCmdCtrl_KeyCmdType_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional int32 screenIdx = 2;
inline bool Packet_Ctrl_KeyCmdCtrl::has_screenidx() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Packet_Ctrl_KeyCmdCtrl::set_has_screenidx() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Packet_Ctrl_KeyCmdCtrl::clear_has_screenidx() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Packet_Ctrl_KeyCmdCtrl::clear_screenidx() {
  screenidx_ = 0;
  clear_has_screenidx();
}
inline ::google::protobuf::int32 Packet_Ctrl_KeyCmdCtrl::screenidx() const {
  return screenidx_;
}
inline void Packet_Ctrl_KeyCmdCtrl::set_screenidx(::google::protobuf::int32 value) {
  set_has_screenidx();
  screenidx_ = value;
}

// optional int32 camPosIdx = 3;
inline bool Packet_Ctrl_KeyCmdCtrl::has_camposidx() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Packet_Ctrl_KeyCmdCtrl::set_has_camposidx() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Packet_Ctrl_KeyCmdCtrl::clear_has_camposidx() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Packet_Ctrl_KeyCmdCtrl::clear_camposidx() {
  camposidx_ = 0;
  clear_has_camposidx();
}
inline ::google::protobuf::int32 Packet_Ctrl_KeyCmdCtrl::camposidx() const {
  return camposidx_;
}
inline void Packet_Ctrl_KeyCmdCtrl::set_camposidx(::google::protobuf::int32 value) {
  set_has_camposidx();
  camposidx_ = value;
}

// optional int32 key = 4;
inline bool Packet_Ctrl_KeyCmdCtrl::has_key() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Packet_Ctrl_KeyCmdCtrl::set_has_key() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Packet_Ctrl_KeyCmdCtrl::clear_has_key() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Packet_Ctrl_KeyCmdCtrl::clear_key() {
  key_ = 0;
  clear_has_key();
}
inline ::google::protobuf::int32 Packet_Ctrl_KeyCmdCtrl::key() const {
  return key_;
}
inline void Packet_Ctrl_KeyCmdCtrl::set_key(::google::protobuf::int32 value) {
  set_has_key();
  key_ = value;
}

// optional .TvWall.Packet.Ctrl.KeyCmdCtrl.KeyType keyType = 5;
inline bool Packet_Ctrl_KeyCmdCtrl::has_keytype() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Packet_Ctrl_KeyCmdCtrl::set_has_keytype() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Packet_Ctrl_KeyCmdCtrl::clear_has_keytype() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Packet_Ctrl_KeyCmdCtrl::clear_keytype() {
  keytype_ = 0;
  clear_has_keytype();
}
inline ::TvWall::Packet_Ctrl_KeyCmdCtrl_KeyType Packet_Ctrl_KeyCmdCtrl::keytype() const {
  return static_cast< ::TvWall::Packet_Ctrl_KeyCmdCtrl_KeyType >(keytype_);
}
inline void Packet_Ctrl_KeyCmdCtrl::set_keytype(::TvWall::Packet_Ctrl_KeyCmdCtrl_KeyType value) {
  assert(::TvWall::Packet_Ctrl_KeyCmdCtrl_KeyType_IsValid(value));
  set_has_keytype();
  keytype_ = value;
}

// optional string text = 6;
inline bool Packet_Ctrl_KeyCmdCtrl::has_text() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Packet_Ctrl_KeyCmdCtrl::set_has_text() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Packet_Ctrl_KeyCmdCtrl::clear_has_text() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Packet_Ctrl_KeyCmdCtrl::clear_text() {
  if (text_ != &::google::protobuf::internal::kEmptyString) {
    text_->clear();
  }
  clear_has_text();
}
inline const ::std::string& Packet_Ctrl_KeyCmdCtrl::text() const {
  return *text_;
}
inline void Packet_Ctrl_KeyCmdCtrl::set_text(const ::std::string& value) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(value);
}
inline void Packet_Ctrl_KeyCmdCtrl::set_text(const char* value) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(value);
}
inline void Packet_Ctrl_KeyCmdCtrl::set_text(const char* value, size_t size) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Packet_Ctrl_KeyCmdCtrl::mutable_text() {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  return text_;
}
inline ::std::string* Packet_Ctrl_KeyCmdCtrl::release_text() {
  clear_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = text_;
    text_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Packet_Ctrl_KeyCmdCtrl::set_allocated_text(::std::string* text) {
  if (text_ != &::google::protobuf::internal::kEmptyString) {
    delete text_;
  }
  if (text) {
    set_has_text();
    text_ = text;
  } else {
    clear_has_text();
    text_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string cam_guid = 7;
inline bool Packet_Ctrl_KeyCmdCtrl::has_cam_guid() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Packet_Ctrl_KeyCmdCtrl::set_has_cam_guid() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Packet_Ctrl_KeyCmdCtrl::clear_has_cam_guid() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Packet_Ctrl_KeyCmdCtrl::clear_cam_guid() {
  if (cam_guid_ != &::google::protobuf::internal::kEmptyString) {
    cam_guid_->clear();
  }
  clear_has_cam_guid();
}
inline const ::std::string& Packet_Ctrl_KeyCmdCtrl::cam_guid() const {
  return *cam_guid_;
}
inline void Packet_Ctrl_KeyCmdCtrl::set_cam_guid(const ::std::string& value) {
  set_has_cam_guid();
  if (cam_guid_ == &::google::protobuf::internal::kEmptyString) {
    cam_guid_ = new ::std::string;
  }
  cam_guid_->assign(value);
}
inline void Packet_Ctrl_KeyCmdCtrl::set_cam_guid(const char* value) {
  set_has_cam_guid();
  if (cam_guid_ == &::google::protobuf::internal::kEmptyString) {
    cam_guid_ = new ::std::string;
  }
  cam_guid_->assign(value);
}
inline void Packet_Ctrl_KeyCmdCtrl::set_cam_guid(const char* value, size_t size) {
  set_has_cam_guid();
  if (cam_guid_ == &::google::protobuf::internal::kEmptyString) {
    cam_guid_ = new ::std::string;
  }
  cam_guid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Packet_Ctrl_KeyCmdCtrl::mutable_cam_guid() {
  set_has_cam_guid();
  if (cam_guid_ == &::google::protobuf::internal::kEmptyString) {
    cam_guid_ = new ::std::string;
  }
  return cam_guid_;
}
inline ::std::string* Packet_Ctrl_KeyCmdCtrl::release_cam_guid() {
  clear_has_cam_guid();
  if (cam_guid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = cam_guid_;
    cam_guid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Packet_Ctrl_KeyCmdCtrl::set_allocated_cam_guid(::std::string* cam_guid) {
  if (cam_guid_ != &::google::protobuf::internal::kEmptyString) {
    delete cam_guid_;
  }
  if (cam_guid) {
    set_has_cam_guid();
    cam_guid_ = cam_guid;
  } else {
    clear_has_cam_guid();
    cam_guid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// Packet_Ctrl_AlarmCtrl

// required string alarmSource = 1;
inline bool Packet_Ctrl_AlarmCtrl::has_alarmsource() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Packet_Ctrl_AlarmCtrl::set_has_alarmsource() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Packet_Ctrl_AlarmCtrl::clear_has_alarmsource() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Packet_Ctrl_AlarmCtrl::clear_alarmsource() {
  if (alarmsource_ != &::google::protobuf::internal::kEmptyString) {
    alarmsource_->clear();
  }
  clear_has_alarmsource();
}
inline const ::std::string& Packet_Ctrl_AlarmCtrl::alarmsource() const {
  return *alarmsource_;
}
inline void Packet_Ctrl_AlarmCtrl::set_alarmsource(const ::std::string& value) {
  set_has_alarmsource();
  if (alarmsource_ == &::google::protobuf::internal::kEmptyString) {
    alarmsource_ = new ::std::string;
  }
  alarmsource_->assign(value);
}
inline void Packet_Ctrl_AlarmCtrl::set_alarmsource(const char* value) {
  set_has_alarmsource();
  if (alarmsource_ == &::google::protobuf::internal::kEmptyString) {
    alarmsource_ = new ::std::string;
  }
  alarmsource_->assign(value);
}
inline void Packet_Ctrl_AlarmCtrl::set_alarmsource(const char* value, size_t size) {
  set_has_alarmsource();
  if (alarmsource_ == &::google::protobuf::internal::kEmptyString) {
    alarmsource_ = new ::std::string;
  }
  alarmsource_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Packet_Ctrl_AlarmCtrl::mutable_alarmsource() {
  set_has_alarmsource();
  if (alarmsource_ == &::google::protobuf::internal::kEmptyString) {
    alarmsource_ = new ::std::string;
  }
  return alarmsource_;
}
inline ::std::string* Packet_Ctrl_AlarmCtrl::release_alarmsource() {
  clear_has_alarmsource();
  if (alarmsource_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = alarmsource_;
    alarmsource_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Packet_Ctrl_AlarmCtrl::set_allocated_alarmsource(::std::string* alarmsource) {
  if (alarmsource_ != &::google::protobuf::internal::kEmptyString) {
    delete alarmsource_;
  }
  if (alarmsource) {
    set_has_alarmsource();
    alarmsource_ = alarmsource;
  } else {
    clear_has_alarmsource();
    alarmsource_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required bool alarmClear = 2;
inline bool Packet_Ctrl_AlarmCtrl::has_alarmclear() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Packet_Ctrl_AlarmCtrl::set_has_alarmclear() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Packet_Ctrl_AlarmCtrl::clear_has_alarmclear() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Packet_Ctrl_AlarmCtrl::clear_alarmclear() {
  alarmclear_ = false;
  clear_has_alarmclear();
}
inline bool Packet_Ctrl_AlarmCtrl::alarmclear() const {
  return alarmclear_;
}
inline void Packet_Ctrl_AlarmCtrl::set_alarmclear(bool value) {
  set_has_alarmclear();
  alarmclear_ = value;
}

// -------------------------------------------------------------------

// Packet_Ctrl_SyncClockCtrl

// optional int32 clock = 1;
inline bool Packet_Ctrl_SyncClockCtrl::has_clock() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Packet_Ctrl_SyncClockCtrl::set_has_clock() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Packet_Ctrl_SyncClockCtrl::clear_has_clock() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Packet_Ctrl_SyncClockCtrl::clear_clock() {
  clock_ = 0;
  clear_has_clock();
}
inline ::google::protobuf::int32 Packet_Ctrl_SyncClockCtrl::clock() const {
  return clock_;
}
inline void Packet_Ctrl_SyncClockCtrl::set_clock(::google::protobuf::int32 value) {
  set_has_clock();
  clock_ = value;
}

// optional .TvWall.Packet.Ctrl.SyncClockCtrl.SyncType type = 2;
inline bool Packet_Ctrl_SyncClockCtrl::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Packet_Ctrl_SyncClockCtrl::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Packet_Ctrl_SyncClockCtrl::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Packet_Ctrl_SyncClockCtrl::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::TvWall::Packet_Ctrl_SyncClockCtrl_SyncType Packet_Ctrl_SyncClockCtrl::type() const {
  return static_cast< ::TvWall::Packet_Ctrl_SyncClockCtrl_SyncType >(type_);
}
inline void Packet_Ctrl_SyncClockCtrl::set_type(::TvWall::Packet_Ctrl_SyncClockCtrl_SyncType value) {
  assert(::TvWall::Packet_Ctrl_SyncClockCtrl_SyncType_IsValid(value));
  set_has_type();
  type_ = value;
}

// -------------------------------------------------------------------

// Packet_Ctrl_TextContextCtrl

// required .TvWall.Packet.Ctrl.TextContextCtrl.TextContextType type = 1;
inline bool Packet_Ctrl_TextContextCtrl::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Packet_Ctrl_TextContextCtrl::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Packet_Ctrl_TextContextCtrl::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Packet_Ctrl_TextContextCtrl::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::TvWall::Packet_Ctrl_TextContextCtrl_TextContextType Packet_Ctrl_TextContextCtrl::type() const {
  return static_cast< ::TvWall::Packet_Ctrl_TextContextCtrl_TextContextType >(type_);
}
inline void Packet_Ctrl_TextContextCtrl::set_type(::TvWall::Packet_Ctrl_TextContextCtrl_TextContextType value) {
  assert(::TvWall::Packet_Ctrl_TextContextCtrl_TextContextType_IsValid(value));
  set_has_type();
  type_ = value;
}

// required string oldText = 2;
inline bool Packet_Ctrl_TextContextCtrl::has_oldtext() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Packet_Ctrl_TextContextCtrl::set_has_oldtext() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Packet_Ctrl_TextContextCtrl::clear_has_oldtext() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Packet_Ctrl_TextContextCtrl::clear_oldtext() {
  if (oldtext_ != &::google::protobuf::internal::kEmptyString) {
    oldtext_->clear();
  }
  clear_has_oldtext();
}
inline const ::std::string& Packet_Ctrl_TextContextCtrl::oldtext() const {
  return *oldtext_;
}
inline void Packet_Ctrl_TextContextCtrl::set_oldtext(const ::std::string& value) {
  set_has_oldtext();
  if (oldtext_ == &::google::protobuf::internal::kEmptyString) {
    oldtext_ = new ::std::string;
  }
  oldtext_->assign(value);
}
inline void Packet_Ctrl_TextContextCtrl::set_oldtext(const char* value) {
  set_has_oldtext();
  if (oldtext_ == &::google::protobuf::internal::kEmptyString) {
    oldtext_ = new ::std::string;
  }
  oldtext_->assign(value);
}
inline void Packet_Ctrl_TextContextCtrl::set_oldtext(const char* value, size_t size) {
  set_has_oldtext();
  if (oldtext_ == &::google::protobuf::internal::kEmptyString) {
    oldtext_ = new ::std::string;
  }
  oldtext_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Packet_Ctrl_TextContextCtrl::mutable_oldtext() {
  set_has_oldtext();
  if (oldtext_ == &::google::protobuf::internal::kEmptyString) {
    oldtext_ = new ::std::string;
  }
  return oldtext_;
}
inline ::std::string* Packet_Ctrl_TextContextCtrl::release_oldtext() {
  clear_has_oldtext();
  if (oldtext_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = oldtext_;
    oldtext_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Packet_Ctrl_TextContextCtrl::set_allocated_oldtext(::std::string* oldtext) {
  if (oldtext_ != &::google::protobuf::internal::kEmptyString) {
    delete oldtext_;
  }
  if (oldtext) {
    set_has_oldtext();
    oldtext_ = oldtext;
  } else {
    clear_has_oldtext();
    oldtext_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string newText = 3;
inline bool Packet_Ctrl_TextContextCtrl::has_newtext() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Packet_Ctrl_TextContextCtrl::set_has_newtext() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Packet_Ctrl_TextContextCtrl::clear_has_newtext() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Packet_Ctrl_TextContextCtrl::clear_newtext() {
  if (newtext_ != &::google::protobuf::internal::kEmptyString) {
    newtext_->clear();
  }
  clear_has_newtext();
}
inline const ::std::string& Packet_Ctrl_TextContextCtrl::newtext() const {
  return *newtext_;
}
inline void Packet_Ctrl_TextContextCtrl::set_newtext(const ::std::string& value) {
  set_has_newtext();
  if (newtext_ == &::google::protobuf::internal::kEmptyString) {
    newtext_ = new ::std::string;
  }
  newtext_->assign(value);
}
inline void Packet_Ctrl_TextContextCtrl::set_newtext(const char* value) {
  set_has_newtext();
  if (newtext_ == &::google::protobuf::internal::kEmptyString) {
    newtext_ = new ::std::string;
  }
  newtext_->assign(value);
}
inline void Packet_Ctrl_TextContextCtrl::set_newtext(const char* value, size_t size) {
  set_has_newtext();
  if (newtext_ == &::google::protobuf::internal::kEmptyString) {
    newtext_ = new ::std::string;
  }
  newtext_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Packet_Ctrl_TextContextCtrl::mutable_newtext() {
  set_has_newtext();
  if (newtext_ == &::google::protobuf::internal::kEmptyString) {
    newtext_ = new ::std::string;
  }
  return newtext_;
}
inline ::std::string* Packet_Ctrl_TextContextCtrl::release_newtext() {
  clear_has_newtext();
  if (newtext_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = newtext_;
    newtext_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Packet_Ctrl_TextContextCtrl::set_allocated_newtext(::std::string* newtext) {
  if (newtext_ != &::google::protobuf::internal::kEmptyString) {
    delete newtext_;
  }
  if (newtext) {
    set_has_newtext();
    newtext_ = newtext;
  } else {
    clear_has_newtext();
    newtext_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// Packet_Ctrl_GroupLoopCtrl

// required .TvWall.Packet.Ctrl.GroupLoopCtrl.GroupLoopCtrlType type = 1;
inline bool Packet_Ctrl_GroupLoopCtrl::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Packet_Ctrl_GroupLoopCtrl::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Packet_Ctrl_GroupLoopCtrl::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Packet_Ctrl_GroupLoopCtrl::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::TvWall::Packet_Ctrl_GroupLoopCtrl_GroupLoopCtrlType Packet_Ctrl_GroupLoopCtrl::type() const {
  return static_cast< ::TvWall::Packet_Ctrl_GroupLoopCtrl_GroupLoopCtrlType >(type_);
}
inline void Packet_Ctrl_GroupLoopCtrl::set_type(::TvWall::Packet_Ctrl_GroupLoopCtrl_GroupLoopCtrlType value) {
  assert(::TvWall::Packet_Ctrl_GroupLoopCtrl_GroupLoopCtrlType_IsValid(value));
  set_has_type();
  type_ = value;
}

// required .TvWall.Packet.ElementDat.GroupLoop groupLoop = 2;
inline bool Packet_Ctrl_GroupLoopCtrl::has_grouploop() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Packet_Ctrl_GroupLoopCtrl::set_has_grouploop() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Packet_Ctrl_GroupLoopCtrl::clear_has_grouploop() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Packet_Ctrl_GroupLoopCtrl::clear_grouploop() {
  if (grouploop_ != NULL) grouploop_->::TvWall::Packet_ElementDat_GroupLoop::Clear();
  clear_has_grouploop();
}
inline const ::TvWall::Packet_ElementDat_GroupLoop& Packet_Ctrl_GroupLoopCtrl::grouploop() const {
  return grouploop_ != NULL ? *grouploop_ : *default_instance_->grouploop_;
}
inline ::TvWall::Packet_ElementDat_GroupLoop* Packet_Ctrl_GroupLoopCtrl::mutable_grouploop() {
  set_has_grouploop();
  if (grouploop_ == NULL) grouploop_ = new ::TvWall::Packet_ElementDat_GroupLoop;
  return grouploop_;
}
inline ::TvWall::Packet_ElementDat_GroupLoop* Packet_Ctrl_GroupLoopCtrl::release_grouploop() {
  clear_has_grouploop();
  ::TvWall::Packet_ElementDat_GroupLoop* temp = grouploop_;
  grouploop_ = NULL;
  return temp;
}
inline void Packet_Ctrl_GroupLoopCtrl::set_allocated_grouploop(::TvWall::Packet_ElementDat_GroupLoop* grouploop) {
  delete grouploop_;
  grouploop_ = grouploop;
  if (grouploop) {
    set_has_grouploop();
  } else {
    clear_has_grouploop();
  }
}

// -------------------------------------------------------------------

// Packet_Ctrl

// optional .TvWall.Packet.Ctrl.ViewCtrl viewCtrl = 1;
inline bool Packet_Ctrl::has_viewctrl() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Packet_Ctrl::set_has_viewctrl() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Packet_Ctrl::clear_has_viewctrl() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Packet_Ctrl::clear_viewctrl() {
  if (viewctrl_ != NULL) viewctrl_->::TvWall::Packet_Ctrl_ViewCtrl::Clear();
  clear_has_viewctrl();
}
inline const ::TvWall::Packet_Ctrl_ViewCtrl& Packet_Ctrl::viewctrl() const {
  return viewctrl_ != NULL ? *viewctrl_ : *default_instance_->viewctrl_;
}
inline ::TvWall::Packet_Ctrl_ViewCtrl* Packet_Ctrl::mutable_viewctrl() {
  set_has_viewctrl();
  if (viewctrl_ == NULL) viewctrl_ = new ::TvWall::Packet_Ctrl_ViewCtrl;
  return viewctrl_;
}
inline ::TvWall::Packet_Ctrl_ViewCtrl* Packet_Ctrl::release_viewctrl() {
  clear_has_viewctrl();
  ::TvWall::Packet_Ctrl_ViewCtrl* temp = viewctrl_;
  viewctrl_ = NULL;
  return temp;
}
inline void Packet_Ctrl::set_allocated_viewctrl(::TvWall::Packet_Ctrl_ViewCtrl* viewctrl) {
  delete viewctrl_;
  viewctrl_ = viewctrl;
  if (viewctrl) {
    set_has_viewctrl();
  } else {
    clear_has_viewctrl();
  }
}

// optional .TvWall.Packet.Ctrl.CameraCtrl cameraCtrl = 2;
inline bool Packet_Ctrl::has_cameractrl() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Packet_Ctrl::set_has_cameractrl() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Packet_Ctrl::clear_has_cameractrl() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Packet_Ctrl::clear_cameractrl() {
  if (cameractrl_ != NULL) cameractrl_->::TvWall::Packet_Ctrl_CameraCtrl::Clear();
  clear_has_cameractrl();
}
inline const ::TvWall::Packet_Ctrl_CameraCtrl& Packet_Ctrl::cameractrl() const {
  return cameractrl_ != NULL ? *cameractrl_ : *default_instance_->cameractrl_;
}
inline ::TvWall::Packet_Ctrl_CameraCtrl* Packet_Ctrl::mutable_cameractrl() {
  set_has_cameractrl();
  if (cameractrl_ == NULL) cameractrl_ = new ::TvWall::Packet_Ctrl_CameraCtrl;
  return cameractrl_;
}
inline ::TvWall::Packet_Ctrl_CameraCtrl* Packet_Ctrl::release_cameractrl() {
  clear_has_cameractrl();
  ::TvWall::Packet_Ctrl_CameraCtrl* temp = cameractrl_;
  cameractrl_ = NULL;
  return temp;
}
inline void Packet_Ctrl::set_allocated_cameractrl(::TvWall::Packet_Ctrl_CameraCtrl* cameractrl) {
  delete cameractrl_;
  cameractrl_ = cameractrl;
  if (cameractrl) {
    set_has_cameractrl();
  } else {
    clear_has_cameractrl();
  }
}

// optional .TvWall.Packet.Ctrl.HotPointCtrl hotPointCtrl = 3;
inline bool Packet_Ctrl::has_hotpointctrl() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Packet_Ctrl::set_has_hotpointctrl() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Packet_Ctrl::clear_has_hotpointctrl() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Packet_Ctrl::clear_hotpointctrl() {
  if (hotpointctrl_ != NULL) hotpointctrl_->::TvWall::Packet_Ctrl_HotPointCtrl::Clear();
  clear_has_hotpointctrl();
}
inline const ::TvWall::Packet_Ctrl_HotPointCtrl& Packet_Ctrl::hotpointctrl() const {
  return hotpointctrl_ != NULL ? *hotpointctrl_ : *default_instance_->hotpointctrl_;
}
inline ::TvWall::Packet_Ctrl_HotPointCtrl* Packet_Ctrl::mutable_hotpointctrl() {
  set_has_hotpointctrl();
  if (hotpointctrl_ == NULL) hotpointctrl_ = new ::TvWall::Packet_Ctrl_HotPointCtrl;
  return hotpointctrl_;
}
inline ::TvWall::Packet_Ctrl_HotPointCtrl* Packet_Ctrl::release_hotpointctrl() {
  clear_has_hotpointctrl();
  ::TvWall::Packet_Ctrl_HotPointCtrl* temp = hotpointctrl_;
  hotpointctrl_ = NULL;
  return temp;
}
inline void Packet_Ctrl::set_allocated_hotpointctrl(::TvWall::Packet_Ctrl_HotPointCtrl* hotpointctrl) {
  delete hotpointctrl_;
  hotpointctrl_ = hotpointctrl;
  if (hotpointctrl) {
    set_has_hotpointctrl();
  } else {
    clear_has_hotpointctrl();
  }
}

// optional .TvWall.Packet.Ctrl.LayoutCtrl lyoutCtrl = 4;
inline bool Packet_Ctrl::has_lyoutctrl() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Packet_Ctrl::set_has_lyoutctrl() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Packet_Ctrl::clear_has_lyoutctrl() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Packet_Ctrl::clear_lyoutctrl() {
  if (lyoutctrl_ != NULL) lyoutctrl_->::TvWall::Packet_Ctrl_LayoutCtrl::Clear();
  clear_has_lyoutctrl();
}
inline const ::TvWall::Packet_Ctrl_LayoutCtrl& Packet_Ctrl::lyoutctrl() const {
  return lyoutctrl_ != NULL ? *lyoutctrl_ : *default_instance_->lyoutctrl_;
}
inline ::TvWall::Packet_Ctrl_LayoutCtrl* Packet_Ctrl::mutable_lyoutctrl() {
  set_has_lyoutctrl();
  if (lyoutctrl_ == NULL) lyoutctrl_ = new ::TvWall::Packet_Ctrl_LayoutCtrl;
  return lyoutctrl_;
}
inline ::TvWall::Packet_Ctrl_LayoutCtrl* Packet_Ctrl::release_lyoutctrl() {
  clear_has_lyoutctrl();
  ::TvWall::Packet_Ctrl_LayoutCtrl* temp = lyoutctrl_;
  lyoutctrl_ = NULL;
  return temp;
}
inline void Packet_Ctrl::set_allocated_lyoutctrl(::TvWall::Packet_Ctrl_LayoutCtrl* lyoutctrl) {
  delete lyoutctrl_;
  lyoutctrl_ = lyoutctrl;
  if (lyoutctrl) {
    set_has_lyoutctrl();
  } else {
    clear_has_lyoutctrl();
  }
}

// optional .TvWall.Packet.Ctrl.CtrlMaster masterCtrl = 5;
inline bool Packet_Ctrl::has_masterctrl() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Packet_Ctrl::set_has_masterctrl() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Packet_Ctrl::clear_has_masterctrl() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Packet_Ctrl::clear_masterctrl() {
  if (masterctrl_ != NULL) masterctrl_->::TvWall::Packet_Ctrl_CtrlMaster::Clear();
  clear_has_masterctrl();
}
inline const ::TvWall::Packet_Ctrl_CtrlMaster& Packet_Ctrl::masterctrl() const {
  return masterctrl_ != NULL ? *masterctrl_ : *default_instance_->masterctrl_;
}
inline ::TvWall::Packet_Ctrl_CtrlMaster* Packet_Ctrl::mutable_masterctrl() {
  set_has_masterctrl();
  if (masterctrl_ == NULL) masterctrl_ = new ::TvWall::Packet_Ctrl_CtrlMaster;
  return masterctrl_;
}
inline ::TvWall::Packet_Ctrl_CtrlMaster* Packet_Ctrl::release_masterctrl() {
  clear_has_masterctrl();
  ::TvWall::Packet_Ctrl_CtrlMaster* temp = masterctrl_;
  masterctrl_ = NULL;
  return temp;
}
inline void Packet_Ctrl::set_allocated_masterctrl(::TvWall::Packet_Ctrl_CtrlMaster* masterctrl) {
  delete masterctrl_;
  masterctrl_ = masterctrl;
  if (masterctrl) {
    set_has_masterctrl();
  } else {
    clear_has_masterctrl();
  }
}

// optional .TvWall.Packet.Ctrl.ScreenSplitCtrl screenCtrl = 6;
inline bool Packet_Ctrl::has_screenctrl() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Packet_Ctrl::set_has_screenctrl() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Packet_Ctrl::clear_has_screenctrl() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Packet_Ctrl::clear_screenctrl() {
  if (screenctrl_ != NULL) screenctrl_->::TvWall::Packet_Ctrl_ScreenSplitCtrl::Clear();
  clear_has_screenctrl();
}
inline const ::TvWall::Packet_Ctrl_ScreenSplitCtrl& Packet_Ctrl::screenctrl() const {
  return screenctrl_ != NULL ? *screenctrl_ : *default_instance_->screenctrl_;
}
inline ::TvWall::Packet_Ctrl_ScreenSplitCtrl* Packet_Ctrl::mutable_screenctrl() {
  set_has_screenctrl();
  if (screenctrl_ == NULL) screenctrl_ = new ::TvWall::Packet_Ctrl_ScreenSplitCtrl;
  return screenctrl_;
}
inline ::TvWall::Packet_Ctrl_ScreenSplitCtrl* Packet_Ctrl::release_screenctrl() {
  clear_has_screenctrl();
  ::TvWall::Packet_Ctrl_ScreenSplitCtrl* temp = screenctrl_;
  screenctrl_ = NULL;
  return temp;
}
inline void Packet_Ctrl::set_allocated_screenctrl(::TvWall::Packet_Ctrl_ScreenSplitCtrl* screenctrl) {
  delete screenctrl_;
  screenctrl_ = screenctrl;
  if (screenctrl) {
    set_has_screenctrl();
  } else {
    clear_has_screenctrl();
  }
}

// optional .TvWall.Packet.Ctrl.LayoutLoopCtrl lyoutLoopCtrl = 7;
inline bool Packet_Ctrl::has_lyoutloopctrl() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Packet_Ctrl::set_has_lyoutloopctrl() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Packet_Ctrl::clear_has_lyoutloopctrl() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Packet_Ctrl::clear_lyoutloopctrl() {
  if (lyoutloopctrl_ != NULL) lyoutloopctrl_->::TvWall::Packet_Ctrl_LayoutLoopCtrl::Clear();
  clear_has_lyoutloopctrl();
}
inline const ::TvWall::Packet_Ctrl_LayoutLoopCtrl& Packet_Ctrl::lyoutloopctrl() const {
  return lyoutloopctrl_ != NULL ? *lyoutloopctrl_ : *default_instance_->lyoutloopctrl_;
}
inline ::TvWall::Packet_Ctrl_LayoutLoopCtrl* Packet_Ctrl::mutable_lyoutloopctrl() {
  set_has_lyoutloopctrl();
  if (lyoutloopctrl_ == NULL) lyoutloopctrl_ = new ::TvWall::Packet_Ctrl_LayoutLoopCtrl;
  return lyoutloopctrl_;
}
inline ::TvWall::Packet_Ctrl_LayoutLoopCtrl* Packet_Ctrl::release_lyoutloopctrl() {
  clear_has_lyoutloopctrl();
  ::TvWall::Packet_Ctrl_LayoutLoopCtrl* temp = lyoutloopctrl_;
  lyoutloopctrl_ = NULL;
  return temp;
}
inline void Packet_Ctrl::set_allocated_lyoutloopctrl(::TvWall::Packet_Ctrl_LayoutLoopCtrl* lyoutloopctrl) {
  delete lyoutloopctrl_;
  lyoutloopctrl_ = lyoutloopctrl;
  if (lyoutloopctrl) {
    set_has_lyoutloopctrl();
  } else {
    clear_has_lyoutloopctrl();
  }
}

// optional .TvWall.Packet.Ctrl.MachineCtrl machineCtrl = 8;
inline bool Packet_Ctrl::has_machinectrl() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Packet_Ctrl::set_has_machinectrl() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Packet_Ctrl::clear_has_machinectrl() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Packet_Ctrl::clear_machinectrl() {
  if (machinectrl_ != NULL) machinectrl_->::TvWall::Packet_Ctrl_MachineCtrl::Clear();
  clear_has_machinectrl();
}
inline const ::TvWall::Packet_Ctrl_MachineCtrl& Packet_Ctrl::machinectrl() const {
  return machinectrl_ != NULL ? *machinectrl_ : *default_instance_->machinectrl_;
}
inline ::TvWall::Packet_Ctrl_MachineCtrl* Packet_Ctrl::mutable_machinectrl() {
  set_has_machinectrl();
  if (machinectrl_ == NULL) machinectrl_ = new ::TvWall::Packet_Ctrl_MachineCtrl;
  return machinectrl_;
}
inline ::TvWall::Packet_Ctrl_MachineCtrl* Packet_Ctrl::release_machinectrl() {
  clear_has_machinectrl();
  ::TvWall::Packet_Ctrl_MachineCtrl* temp = machinectrl_;
  machinectrl_ = NULL;
  return temp;
}
inline void Packet_Ctrl::set_allocated_machinectrl(::TvWall::Packet_Ctrl_MachineCtrl* machinectrl) {
  delete machinectrl_;
  machinectrl_ = machinectrl;
  if (machinectrl) {
    set_has_machinectrl();
  } else {
    clear_has_machinectrl();
  }
}

// optional .TvWall.Packet.Ctrl.KeyCtrl keyCtrl = 9;
inline bool Packet_Ctrl::has_keyctrl() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Packet_Ctrl::set_has_keyctrl() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Packet_Ctrl::clear_has_keyctrl() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Packet_Ctrl::clear_keyctrl() {
  if (keyctrl_ != NULL) keyctrl_->::TvWall::Packet_Ctrl_KeyCtrl::Clear();
  clear_has_keyctrl();
}
inline const ::TvWall::Packet_Ctrl_KeyCtrl& Packet_Ctrl::keyctrl() const {
  return keyctrl_ != NULL ? *keyctrl_ : *default_instance_->keyctrl_;
}
inline ::TvWall::Packet_Ctrl_KeyCtrl* Packet_Ctrl::mutable_keyctrl() {
  set_has_keyctrl();
  if (keyctrl_ == NULL) keyctrl_ = new ::TvWall::Packet_Ctrl_KeyCtrl;
  return keyctrl_;
}
inline ::TvWall::Packet_Ctrl_KeyCtrl* Packet_Ctrl::release_keyctrl() {
  clear_has_keyctrl();
  ::TvWall::Packet_Ctrl_KeyCtrl* temp = keyctrl_;
  keyctrl_ = NULL;
  return temp;
}
inline void Packet_Ctrl::set_allocated_keyctrl(::TvWall::Packet_Ctrl_KeyCtrl* keyctrl) {
  delete keyctrl_;
  keyctrl_ = keyctrl;
  if (keyctrl) {
    set_has_keyctrl();
  } else {
    clear_has_keyctrl();
  }
}

// optional .TvWall.Packet.Ctrl.KeyCmdCtrl keyCmdCtrl = 10;
inline bool Packet_Ctrl::has_keycmdctrl() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Packet_Ctrl::set_has_keycmdctrl() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Packet_Ctrl::clear_has_keycmdctrl() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Packet_Ctrl::clear_keycmdctrl() {
  if (keycmdctrl_ != NULL) keycmdctrl_->::TvWall::Packet_Ctrl_KeyCmdCtrl::Clear();
  clear_has_keycmdctrl();
}
inline const ::TvWall::Packet_Ctrl_KeyCmdCtrl& Packet_Ctrl::keycmdctrl() const {
  return keycmdctrl_ != NULL ? *keycmdctrl_ : *default_instance_->keycmdctrl_;
}
inline ::TvWall::Packet_Ctrl_KeyCmdCtrl* Packet_Ctrl::mutable_keycmdctrl() {
  set_has_keycmdctrl();
  if (keycmdctrl_ == NULL) keycmdctrl_ = new ::TvWall::Packet_Ctrl_KeyCmdCtrl;
  return keycmdctrl_;
}
inline ::TvWall::Packet_Ctrl_KeyCmdCtrl* Packet_Ctrl::release_keycmdctrl() {
  clear_has_keycmdctrl();
  ::TvWall::Packet_Ctrl_KeyCmdCtrl* temp = keycmdctrl_;
  keycmdctrl_ = NULL;
  return temp;
}
inline void Packet_Ctrl::set_allocated_keycmdctrl(::TvWall::Packet_Ctrl_KeyCmdCtrl* keycmdctrl) {
  delete keycmdctrl_;
  keycmdctrl_ = keycmdctrl;
  if (keycmdctrl) {
    set_has_keycmdctrl();
  } else {
    clear_has_keycmdctrl();
  }
}

// optional .TvWall.Packet.Ctrl.AlarmCtrl alarmCtrl = 11;
inline bool Packet_Ctrl::has_alarmctrl() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Packet_Ctrl::set_has_alarmctrl() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Packet_Ctrl::clear_has_alarmctrl() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Packet_Ctrl::clear_alarmctrl() {
  if (alarmctrl_ != NULL) alarmctrl_->::TvWall::Packet_Ctrl_AlarmCtrl::Clear();
  clear_has_alarmctrl();
}
inline const ::TvWall::Packet_Ctrl_AlarmCtrl& Packet_Ctrl::alarmctrl() const {
  return alarmctrl_ != NULL ? *alarmctrl_ : *default_instance_->alarmctrl_;
}
inline ::TvWall::Packet_Ctrl_AlarmCtrl* Packet_Ctrl::mutable_alarmctrl() {
  set_has_alarmctrl();
  if (alarmctrl_ == NULL) alarmctrl_ = new ::TvWall::Packet_Ctrl_AlarmCtrl;
  return alarmctrl_;
}
inline ::TvWall::Packet_Ctrl_AlarmCtrl* Packet_Ctrl::release_alarmctrl() {
  clear_has_alarmctrl();
  ::TvWall::Packet_Ctrl_AlarmCtrl* temp = alarmctrl_;
  alarmctrl_ = NULL;
  return temp;
}
inline void Packet_Ctrl::set_allocated_alarmctrl(::TvWall::Packet_Ctrl_AlarmCtrl* alarmctrl) {
  delete alarmctrl_;
  alarmctrl_ = alarmctrl;
  if (alarmctrl) {
    set_has_alarmctrl();
  } else {
    clear_has_alarmctrl();
  }
}

// optional .TvWall.Packet.Ctrl.SyncClockCtrl syncCtrl = 12;
inline bool Packet_Ctrl::has_syncctrl() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Packet_Ctrl::set_has_syncctrl() {
  _has_bits_[0] |= 0x00000800u;
}
inline void Packet_Ctrl::clear_has_syncctrl() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void Packet_Ctrl::clear_syncctrl() {
  if (syncctrl_ != NULL) syncctrl_->::TvWall::Packet_Ctrl_SyncClockCtrl::Clear();
  clear_has_syncctrl();
}
inline const ::TvWall::Packet_Ctrl_SyncClockCtrl& Packet_Ctrl::syncctrl() const {
  return syncctrl_ != NULL ? *syncctrl_ : *default_instance_->syncctrl_;
}
inline ::TvWall::Packet_Ctrl_SyncClockCtrl* Packet_Ctrl::mutable_syncctrl() {
  set_has_syncctrl();
  if (syncctrl_ == NULL) syncctrl_ = new ::TvWall::Packet_Ctrl_SyncClockCtrl;
  return syncctrl_;
}
inline ::TvWall::Packet_Ctrl_SyncClockCtrl* Packet_Ctrl::release_syncctrl() {
  clear_has_syncctrl();
  ::TvWall::Packet_Ctrl_SyncClockCtrl* temp = syncctrl_;
  syncctrl_ = NULL;
  return temp;
}
inline void Packet_Ctrl::set_allocated_syncctrl(::TvWall::Packet_Ctrl_SyncClockCtrl* syncctrl) {
  delete syncctrl_;
  syncctrl_ = syncctrl;
  if (syncctrl) {
    set_has_syncctrl();
  } else {
    clear_has_syncctrl();
  }
}

// optional .TvWall.Packet.Ctrl.TextContextCtrl txtContextCtrl = 13;
inline bool Packet_Ctrl::has_txtcontextctrl() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void Packet_Ctrl::set_has_txtcontextctrl() {
  _has_bits_[0] |= 0x00001000u;
}
inline void Packet_Ctrl::clear_has_txtcontextctrl() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void Packet_Ctrl::clear_txtcontextctrl() {
  if (txtcontextctrl_ != NULL) txtcontextctrl_->::TvWall::Packet_Ctrl_TextContextCtrl::Clear();
  clear_has_txtcontextctrl();
}
inline const ::TvWall::Packet_Ctrl_TextContextCtrl& Packet_Ctrl::txtcontextctrl() const {
  return txtcontextctrl_ != NULL ? *txtcontextctrl_ : *default_instance_->txtcontextctrl_;
}
inline ::TvWall::Packet_Ctrl_TextContextCtrl* Packet_Ctrl::mutable_txtcontextctrl() {
  set_has_txtcontextctrl();
  if (txtcontextctrl_ == NULL) txtcontextctrl_ = new ::TvWall::Packet_Ctrl_TextContextCtrl;
  return txtcontextctrl_;
}
inline ::TvWall::Packet_Ctrl_TextContextCtrl* Packet_Ctrl::release_txtcontextctrl() {
  clear_has_txtcontextctrl();
  ::TvWall::Packet_Ctrl_TextContextCtrl* temp = txtcontextctrl_;
  txtcontextctrl_ = NULL;
  return temp;
}
inline void Packet_Ctrl::set_allocated_txtcontextctrl(::TvWall::Packet_Ctrl_TextContextCtrl* txtcontextctrl) {
  delete txtcontextctrl_;
  txtcontextctrl_ = txtcontextctrl;
  if (txtcontextctrl) {
    set_has_txtcontextctrl();
  } else {
    clear_has_txtcontextctrl();
  }
}

// optional .TvWall.Packet.Ctrl.GroupLoopCtrl groupLoopCtrl = 14;
inline bool Packet_Ctrl::has_grouploopctrl() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void Packet_Ctrl::set_has_grouploopctrl() {
  _has_bits_[0] |= 0x00002000u;
}
inline void Packet_Ctrl::clear_has_grouploopctrl() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void Packet_Ctrl::clear_grouploopctrl() {
  if (grouploopctrl_ != NULL) grouploopctrl_->::TvWall::Packet_Ctrl_GroupLoopCtrl::Clear();
  clear_has_grouploopctrl();
}
inline const ::TvWall::Packet_Ctrl_GroupLoopCtrl& Packet_Ctrl::grouploopctrl() const {
  return grouploopctrl_ != NULL ? *grouploopctrl_ : *default_instance_->grouploopctrl_;
}
inline ::TvWall::Packet_Ctrl_GroupLoopCtrl* Packet_Ctrl::mutable_grouploopctrl() {
  set_has_grouploopctrl();
  if (grouploopctrl_ == NULL) grouploopctrl_ = new ::TvWall::Packet_Ctrl_GroupLoopCtrl;
  return grouploopctrl_;
}
inline ::TvWall::Packet_Ctrl_GroupLoopCtrl* Packet_Ctrl::release_grouploopctrl() {
  clear_has_grouploopctrl();
  ::TvWall::Packet_Ctrl_GroupLoopCtrl* temp = grouploopctrl_;
  grouploopctrl_ = NULL;
  return temp;
}
inline void Packet_Ctrl::set_allocated_grouploopctrl(::TvWall::Packet_Ctrl_GroupLoopCtrl* grouploopctrl) {
  delete grouploopctrl_;
  grouploopctrl_ = grouploopctrl;
  if (grouploopctrl) {
    set_has_grouploopctrl();
  } else {
    clear_has_grouploopctrl();
  }
}

// -------------------------------------------------------------------

// Packet_RequireSession_ClientRequire

// required .TvWall.Packet.RequireSession.ClientRequireType type = 1;
inline bool Packet_RequireSession_ClientRequire::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Packet_RequireSession_ClientRequire::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Packet_RequireSession_ClientRequire::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Packet_RequireSession_ClientRequire::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::TvWall::Packet_RequireSession_ClientRequireType Packet_RequireSession_ClientRequire::type() const {
  return static_cast< ::TvWall::Packet_RequireSession_ClientRequireType >(type_);
}
inline void Packet_RequireSession_ClientRequire::set_type(::TvWall::Packet_RequireSession_ClientRequireType value) {
  assert(::TvWall::Packet_RequireSession_ClientRequireType_IsValid(value));
  set_has_type();
  type_ = value;
}

// -------------------------------------------------------------------

// Packet_RequireSession_ClientRequireAck

// required .TvWall.Packet.RequireSession.ClientRequireType type = 1;
inline bool Packet_RequireSession_ClientRequireAck::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Packet_RequireSession_ClientRequireAck::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Packet_RequireSession_ClientRequireAck::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Packet_RequireSession_ClientRequireAck::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::TvWall::Packet_RequireSession_ClientRequireType Packet_RequireSession_ClientRequireAck::type() const {
  return static_cast< ::TvWall::Packet_RequireSession_ClientRequireType >(type_);
}
inline void Packet_RequireSession_ClientRequireAck::set_type(::TvWall::Packet_RequireSession_ClientRequireType value) {
  assert(::TvWall::Packet_RequireSession_ClientRequireType_IsValid(value));
  set_has_type();
  type_ = value;
}

// required .TvWall.Packet.ElementDat elementData = 2;
inline bool Packet_RequireSession_ClientRequireAck::has_elementdata() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Packet_RequireSession_ClientRequireAck::set_has_elementdata() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Packet_RequireSession_ClientRequireAck::clear_has_elementdata() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Packet_RequireSession_ClientRequireAck::clear_elementdata() {
  if (elementdata_ != NULL) elementdata_->::TvWall::Packet_ElementDat::Clear();
  clear_has_elementdata();
}
inline const ::TvWall::Packet_ElementDat& Packet_RequireSession_ClientRequireAck::elementdata() const {
  return elementdata_ != NULL ? *elementdata_ : *default_instance_->elementdata_;
}
inline ::TvWall::Packet_ElementDat* Packet_RequireSession_ClientRequireAck::mutable_elementdata() {
  set_has_elementdata();
  if (elementdata_ == NULL) elementdata_ = new ::TvWall::Packet_ElementDat;
  return elementdata_;
}
inline ::TvWall::Packet_ElementDat* Packet_RequireSession_ClientRequireAck::release_elementdata() {
  clear_has_elementdata();
  ::TvWall::Packet_ElementDat* temp = elementdata_;
  elementdata_ = NULL;
  return temp;
}
inline void Packet_RequireSession_ClientRequireAck::set_allocated_elementdata(::TvWall::Packet_ElementDat* elementdata) {
  delete elementdata_;
  elementdata_ = elementdata;
  if (elementdata) {
    set_has_elementdata();
  } else {
    clear_has_elementdata();
  }
}

// -------------------------------------------------------------------

// Packet_RequireSession_LocalMovieSession

// required int32 winId = 1;
inline bool Packet_RequireSession_LocalMovieSession::has_winid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Packet_RequireSession_LocalMovieSession::set_has_winid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Packet_RequireSession_LocalMovieSession::clear_has_winid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Packet_RequireSession_LocalMovieSession::clear_winid() {
  winid_ = 0;
  clear_has_winid();
}
inline ::google::protobuf::int32 Packet_RequireSession_LocalMovieSession::winid() const {
  return winid_;
}
inline void Packet_RequireSession_LocalMovieSession::set_winid(::google::protobuf::int32 value) {
  set_has_winid();
  winid_ = value;
}

// required bool needAlwaysAck = 2;
inline bool Packet_RequireSession_LocalMovieSession::has_needalwaysack() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Packet_RequireSession_LocalMovieSession::set_has_needalwaysack() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Packet_RequireSession_LocalMovieSession::clear_has_needalwaysack() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Packet_RequireSession_LocalMovieSession::clear_needalwaysack() {
  needalwaysack_ = false;
  clear_has_needalwaysack();
}
inline bool Packet_RequireSession_LocalMovieSession::needalwaysack() const {
  return needalwaysack_;
}
inline void Packet_RequireSession_LocalMovieSession::set_needalwaysack(bool value) {
  set_has_needalwaysack();
  needalwaysack_ = value;
}

// -------------------------------------------------------------------

// Packet_RequireSession_LocalMovieSessionAck

// required int32 winId = 1;
inline bool Packet_RequireSession_LocalMovieSessionAck::has_winid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Packet_RequireSession_LocalMovieSessionAck::set_has_winid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Packet_RequireSession_LocalMovieSessionAck::clear_has_winid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Packet_RequireSession_LocalMovieSessionAck::clear_winid() {
  winid_ = 0;
  clear_has_winid();
}
inline ::google::protobuf::int32 Packet_RequireSession_LocalMovieSessionAck::winid() const {
  return winid_;
}
inline void Packet_RequireSession_LocalMovieSessionAck::set_winid(::google::protobuf::int32 value) {
  set_has_winid();
  winid_ = value;
}

// optional string url = 2;
inline bool Packet_RequireSession_LocalMovieSessionAck::has_url() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Packet_RequireSession_LocalMovieSessionAck::set_has_url() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Packet_RequireSession_LocalMovieSessionAck::clear_has_url() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Packet_RequireSession_LocalMovieSessionAck::clear_url() {
  if (url_ != &::google::protobuf::internal::kEmptyString) {
    url_->clear();
  }
  clear_has_url();
}
inline const ::std::string& Packet_RequireSession_LocalMovieSessionAck::url() const {
  return *url_;
}
inline void Packet_RequireSession_LocalMovieSessionAck::set_url(const ::std::string& value) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  url_->assign(value);
}
inline void Packet_RequireSession_LocalMovieSessionAck::set_url(const char* value) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  url_->assign(value);
}
inline void Packet_RequireSession_LocalMovieSessionAck::set_url(const char* value, size_t size) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  url_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Packet_RequireSession_LocalMovieSessionAck::mutable_url() {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  return url_;
}
inline ::std::string* Packet_RequireSession_LocalMovieSessionAck::release_url() {
  clear_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = url_;
    url_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Packet_RequireSession_LocalMovieSessionAck::set_allocated_url(::std::string* url) {
  if (url_ != &::google::protobuf::internal::kEmptyString) {
    delete url_;
  }
  if (url) {
    set_has_url();
    url_ = url;
  } else {
    clear_has_url();
    url_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 volume = 3;
inline bool Packet_RequireSession_LocalMovieSessionAck::has_volume() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Packet_RequireSession_LocalMovieSessionAck::set_has_volume() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Packet_RequireSession_LocalMovieSessionAck::clear_has_volume() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Packet_RequireSession_LocalMovieSessionAck::clear_volume() {
  volume_ = 0;
  clear_has_volume();
}
inline ::google::protobuf::int32 Packet_RequireSession_LocalMovieSessionAck::volume() const {
  return volume_;
}
inline void Packet_RequireSession_LocalMovieSessionAck::set_volume(::google::protobuf::int32 value) {
  set_has_volume();
  volume_ = value;
}

// optional int64 timeStamp = 4;
inline bool Packet_RequireSession_LocalMovieSessionAck::has_timestamp() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Packet_RequireSession_LocalMovieSessionAck::set_has_timestamp() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Packet_RequireSession_LocalMovieSessionAck::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Packet_RequireSession_LocalMovieSessionAck::clear_timestamp() {
  timestamp_ = GOOGLE_LONGLONG(0);
  clear_has_timestamp();
}
inline ::google::protobuf::int64 Packet_RequireSession_LocalMovieSessionAck::timestamp() const {
  return timestamp_;
}
inline void Packet_RequireSession_LocalMovieSessionAck::set_timestamp(::google::protobuf::int64 value) {
  set_has_timestamp();
  timestamp_ = value;
}

// required .TvWall.Packet.RequireSession.LocalMovieSessionAck.MovieStat movieStat = 5;
inline bool Packet_RequireSession_LocalMovieSessionAck::has_moviestat() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Packet_RequireSession_LocalMovieSessionAck::set_has_moviestat() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Packet_RequireSession_LocalMovieSessionAck::clear_has_moviestat() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Packet_RequireSession_LocalMovieSessionAck::clear_moviestat() {
  moviestat_ = 0;
  clear_has_moviestat();
}
inline ::TvWall::Packet_RequireSession_LocalMovieSessionAck_MovieStat Packet_RequireSession_LocalMovieSessionAck::moviestat() const {
  return static_cast< ::TvWall::Packet_RequireSession_LocalMovieSessionAck_MovieStat >(moviestat_);
}
inline void Packet_RequireSession_LocalMovieSessionAck::set_moviestat(::TvWall::Packet_RequireSession_LocalMovieSessionAck_MovieStat value) {
  assert(::TvWall::Packet_RequireSession_LocalMovieSessionAck_MovieStat_IsValid(value));
  set_has_moviestat();
  moviestat_ = value;
}

// -------------------------------------------------------------------

// Packet_RequireSession_RecordRequire

// required .TvWall.Packet.RequireSession.RecordRequire.RecordRequireType type = 1;
inline bool Packet_RequireSession_RecordRequire::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Packet_RequireSession_RecordRequire::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Packet_RequireSession_RecordRequire::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Packet_RequireSession_RecordRequire::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::TvWall::Packet_RequireSession_RecordRequire_RecordRequireType Packet_RequireSession_RecordRequire::type() const {
  return static_cast< ::TvWall::Packet_RequireSession_RecordRequire_RecordRequireType >(type_);
}
inline void Packet_RequireSession_RecordRequire::set_type(::TvWall::Packet_RequireSession_RecordRequire_RecordRequireType value) {
  assert(::TvWall::Packet_RequireSession_RecordRequire_RecordRequireType_IsValid(value));
  set_has_type();
  type_ = value;
}

// required int32 winId = 2;
inline bool Packet_RequireSession_RecordRequire::has_winid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Packet_RequireSession_RecordRequire::set_has_winid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Packet_RequireSession_RecordRequire::clear_has_winid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Packet_RequireSession_RecordRequire::clear_winid() {
  winid_ = 0;
  clear_has_winid();
}
inline ::google::protobuf::int32 Packet_RequireSession_RecordRequire::winid() const {
  return winid_;
}
inline void Packet_RequireSession_RecordRequire::set_winid(::google::protobuf::int32 value) {
  set_has_winid();
  winid_ = value;
}

// required .TvWall.Guid CameraId = 3;
inline bool Packet_RequireSession_RecordRequire::has_cameraid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Packet_RequireSession_RecordRequire::set_has_cameraid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Packet_RequireSession_RecordRequire::clear_has_cameraid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Packet_RequireSession_RecordRequire::clear_cameraid() {
  if (cameraid_ != NULL) cameraid_->::TvWall::Guid::Clear();
  clear_has_cameraid();
}
inline const ::TvWall::Guid& Packet_RequireSession_RecordRequire::cameraid() const {
  return cameraid_ != NULL ? *cameraid_ : *default_instance_->cameraid_;
}
inline ::TvWall::Guid* Packet_RequireSession_RecordRequire::mutable_cameraid() {
  set_has_cameraid();
  if (cameraid_ == NULL) cameraid_ = new ::TvWall::Guid;
  return cameraid_;
}
inline ::TvWall::Guid* Packet_RequireSession_RecordRequire::release_cameraid() {
  clear_has_cameraid();
  ::TvWall::Guid* temp = cameraid_;
  cameraid_ = NULL;
  return temp;
}
inline void Packet_RequireSession_RecordRequire::set_allocated_cameraid(::TvWall::Guid* cameraid) {
  delete cameraid_;
  cameraid_ = cameraid;
  if (cameraid) {
    set_has_cameraid();
  } else {
    clear_has_cameraid();
  }
}

// -------------------------------------------------------------------

// Packet_RequireSession_RecordRequireAck

// required int32 winId = 1;
inline bool Packet_RequireSession_RecordRequireAck::has_winid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Packet_RequireSession_RecordRequireAck::set_has_winid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Packet_RequireSession_RecordRequireAck::clear_has_winid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Packet_RequireSession_RecordRequireAck::clear_winid() {
  winid_ = 0;
  clear_has_winid();
}
inline ::google::protobuf::int32 Packet_RequireSession_RecordRequireAck::winid() const {
  return winid_;
}
inline void Packet_RequireSession_RecordRequireAck::set_winid(::google::protobuf::int32 value) {
  set_has_winid();
  winid_ = value;
}

// required .TvWall.Guid CameraId = 2;
inline bool Packet_RequireSession_RecordRequireAck::has_cameraid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Packet_RequireSession_RecordRequireAck::set_has_cameraid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Packet_RequireSession_RecordRequireAck::clear_has_cameraid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Packet_RequireSession_RecordRequireAck::clear_cameraid() {
  if (cameraid_ != NULL) cameraid_->::TvWall::Guid::Clear();
  clear_has_cameraid();
}
inline const ::TvWall::Guid& Packet_RequireSession_RecordRequireAck::cameraid() const {
  return cameraid_ != NULL ? *cameraid_ : *default_instance_->cameraid_;
}
inline ::TvWall::Guid* Packet_RequireSession_RecordRequireAck::mutable_cameraid() {
  set_has_cameraid();
  if (cameraid_ == NULL) cameraid_ = new ::TvWall::Guid;
  return cameraid_;
}
inline ::TvWall::Guid* Packet_RequireSession_RecordRequireAck::release_cameraid() {
  clear_has_cameraid();
  ::TvWall::Guid* temp = cameraid_;
  cameraid_ = NULL;
  return temp;
}
inline void Packet_RequireSession_RecordRequireAck::set_allocated_cameraid(::TvWall::Guid* cameraid) {
  delete cameraid_;
  cameraid_ = cameraid;
  if (cameraid) {
    set_has_cameraid();
  } else {
    clear_has_cameraid();
  }
}

// optional uint64 currentTime = 3;
inline bool Packet_RequireSession_RecordRequireAck::has_currenttime() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Packet_RequireSession_RecordRequireAck::set_has_currenttime() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Packet_RequireSession_RecordRequireAck::clear_has_currenttime() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Packet_RequireSession_RecordRequireAck::clear_currenttime() {
  currenttime_ = GOOGLE_ULONGLONG(0);
  clear_has_currenttime();
}
inline ::google::protobuf::uint64 Packet_RequireSession_RecordRequireAck::currenttime() const {
  return currenttime_;
}
inline void Packet_RequireSession_RecordRequireAck::set_currenttime(::google::protobuf::uint64 value) {
  set_has_currenttime();
  currenttime_ = value;
}

// optional int32 vary = 4;
inline bool Packet_RequireSession_RecordRequireAck::has_vary() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Packet_RequireSession_RecordRequireAck::set_has_vary() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Packet_RequireSession_RecordRequireAck::clear_has_vary() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Packet_RequireSession_RecordRequireAck::clear_vary() {
  vary_ = 0;
  clear_has_vary();
}
inline ::google::protobuf::int32 Packet_RequireSession_RecordRequireAck::vary() const {
  return vary_;
}
inline void Packet_RequireSession_RecordRequireAck::set_vary(::google::protobuf::int32 value) {
  set_has_vary();
  vary_ = value;
}

// optional bool isPause = 5;
inline bool Packet_RequireSession_RecordRequireAck::has_ispause() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Packet_RequireSession_RecordRequireAck::set_has_ispause() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Packet_RequireSession_RecordRequireAck::clear_has_ispause() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Packet_RequireSession_RecordRequireAck::clear_ispause() {
  ispause_ = false;
  clear_has_ispause();
}
inline bool Packet_RequireSession_RecordRequireAck::ispause() const {
  return ispause_;
}
inline void Packet_RequireSession_RecordRequireAck::set_ispause(bool value) {
  set_has_ispause();
  ispause_ = value;
}

// -------------------------------------------------------------------

// Packet_RequireSession_NetRequire

// -------------------------------------------------------------------

// Packet_RequireSession_NetRequireAck

// optional .TvWall.Network net = 1;
inline bool Packet_RequireSession_NetRequireAck::has_net() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Packet_RequireSession_NetRequireAck::set_has_net() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Packet_RequireSession_NetRequireAck::clear_has_net() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Packet_RequireSession_NetRequireAck::clear_net() {
  if (net_ != NULL) net_->::TvWall::Network::Clear();
  clear_has_net();
}
inline const ::TvWall::Network& Packet_RequireSession_NetRequireAck::net() const {
  return net_ != NULL ? *net_ : *default_instance_->net_;
}
inline ::TvWall::Network* Packet_RequireSession_NetRequireAck::mutable_net() {
  set_has_net();
  if (net_ == NULL) net_ = new ::TvWall::Network;
  return net_;
}
inline ::TvWall::Network* Packet_RequireSession_NetRequireAck::release_net() {
  clear_has_net();
  ::TvWall::Network* temp = net_;
  net_ = NULL;
  return temp;
}
inline void Packet_RequireSession_NetRequireAck::set_allocated_net(::TvWall::Network* net) {
  delete net_;
  net_ = net;
  if (net) {
    set_has_net();
  } else {
    clear_has_net();
  }
}

// -------------------------------------------------------------------

// Packet_RequireSession

// optional .TvWall.Packet.RequireSession.ClientRequire clientRequire = 1;
inline bool Packet_RequireSession::has_clientrequire() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Packet_RequireSession::set_has_clientrequire() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Packet_RequireSession::clear_has_clientrequire() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Packet_RequireSession::clear_clientrequire() {
  if (clientrequire_ != NULL) clientrequire_->::TvWall::Packet_RequireSession_ClientRequire::Clear();
  clear_has_clientrequire();
}
inline const ::TvWall::Packet_RequireSession_ClientRequire& Packet_RequireSession::clientrequire() const {
  return clientrequire_ != NULL ? *clientrequire_ : *default_instance_->clientrequire_;
}
inline ::TvWall::Packet_RequireSession_ClientRequire* Packet_RequireSession::mutable_clientrequire() {
  set_has_clientrequire();
  if (clientrequire_ == NULL) clientrequire_ = new ::TvWall::Packet_RequireSession_ClientRequire;
  return clientrequire_;
}
inline ::TvWall::Packet_RequireSession_ClientRequire* Packet_RequireSession::release_clientrequire() {
  clear_has_clientrequire();
  ::TvWall::Packet_RequireSession_ClientRequire* temp = clientrequire_;
  clientrequire_ = NULL;
  return temp;
}
inline void Packet_RequireSession::set_allocated_clientrequire(::TvWall::Packet_RequireSession_ClientRequire* clientrequire) {
  delete clientrequire_;
  clientrequire_ = clientrequire;
  if (clientrequire) {
    set_has_clientrequire();
  } else {
    clear_has_clientrequire();
  }
}

// optional .TvWall.Packet.RequireSession.ClientRequireAck clientRequireAck = 2;
inline bool Packet_RequireSession::has_clientrequireack() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Packet_RequireSession::set_has_clientrequireack() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Packet_RequireSession::clear_has_clientrequireack() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Packet_RequireSession::clear_clientrequireack() {
  if (clientrequireack_ != NULL) clientrequireack_->::TvWall::Packet_RequireSession_ClientRequireAck::Clear();
  clear_has_clientrequireack();
}
inline const ::TvWall::Packet_RequireSession_ClientRequireAck& Packet_RequireSession::clientrequireack() const {
  return clientrequireack_ != NULL ? *clientrequireack_ : *default_instance_->clientrequireack_;
}
inline ::TvWall::Packet_RequireSession_ClientRequireAck* Packet_RequireSession::mutable_clientrequireack() {
  set_has_clientrequireack();
  if (clientrequireack_ == NULL) clientrequireack_ = new ::TvWall::Packet_RequireSession_ClientRequireAck;
  return clientrequireack_;
}
inline ::TvWall::Packet_RequireSession_ClientRequireAck* Packet_RequireSession::release_clientrequireack() {
  clear_has_clientrequireack();
  ::TvWall::Packet_RequireSession_ClientRequireAck* temp = clientrequireack_;
  clientrequireack_ = NULL;
  return temp;
}
inline void Packet_RequireSession::set_allocated_clientrequireack(::TvWall::Packet_RequireSession_ClientRequireAck* clientrequireack) {
  delete clientrequireack_;
  clientrequireack_ = clientrequireack;
  if (clientrequireack) {
    set_has_clientrequireack();
  } else {
    clear_has_clientrequireack();
  }
}

// optional .TvWall.Packet.RequireSession.LocalMovieSession lms = 3;
inline bool Packet_RequireSession::has_lms() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Packet_RequireSession::set_has_lms() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Packet_RequireSession::clear_has_lms() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Packet_RequireSession::clear_lms() {
  if (lms_ != NULL) lms_->::TvWall::Packet_RequireSession_LocalMovieSession::Clear();
  clear_has_lms();
}
inline const ::TvWall::Packet_RequireSession_LocalMovieSession& Packet_RequireSession::lms() const {
  return lms_ != NULL ? *lms_ : *default_instance_->lms_;
}
inline ::TvWall::Packet_RequireSession_LocalMovieSession* Packet_RequireSession::mutable_lms() {
  set_has_lms();
  if (lms_ == NULL) lms_ = new ::TvWall::Packet_RequireSession_LocalMovieSession;
  return lms_;
}
inline ::TvWall::Packet_RequireSession_LocalMovieSession* Packet_RequireSession::release_lms() {
  clear_has_lms();
  ::TvWall::Packet_RequireSession_LocalMovieSession* temp = lms_;
  lms_ = NULL;
  return temp;
}
inline void Packet_RequireSession::set_allocated_lms(::TvWall::Packet_RequireSession_LocalMovieSession* lms) {
  delete lms_;
  lms_ = lms;
  if (lms) {
    set_has_lms();
  } else {
    clear_has_lms();
  }
}

// optional .TvWall.Packet.RequireSession.LocalMovieSessionAck lmsAck = 4;
inline bool Packet_RequireSession::has_lmsack() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Packet_RequireSession::set_has_lmsack() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Packet_RequireSession::clear_has_lmsack() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Packet_RequireSession::clear_lmsack() {
  if (lmsack_ != NULL) lmsack_->::TvWall::Packet_RequireSession_LocalMovieSessionAck::Clear();
  clear_has_lmsack();
}
inline const ::TvWall::Packet_RequireSession_LocalMovieSessionAck& Packet_RequireSession::lmsack() const {
  return lmsack_ != NULL ? *lmsack_ : *default_instance_->lmsack_;
}
inline ::TvWall::Packet_RequireSession_LocalMovieSessionAck* Packet_RequireSession::mutable_lmsack() {
  set_has_lmsack();
  if (lmsack_ == NULL) lmsack_ = new ::TvWall::Packet_RequireSession_LocalMovieSessionAck;
  return lmsack_;
}
inline ::TvWall::Packet_RequireSession_LocalMovieSessionAck* Packet_RequireSession::release_lmsack() {
  clear_has_lmsack();
  ::TvWall::Packet_RequireSession_LocalMovieSessionAck* temp = lmsack_;
  lmsack_ = NULL;
  return temp;
}
inline void Packet_RequireSession::set_allocated_lmsack(::TvWall::Packet_RequireSession_LocalMovieSessionAck* lmsack) {
  delete lmsack_;
  lmsack_ = lmsack;
  if (lmsack) {
    set_has_lmsack();
  } else {
    clear_has_lmsack();
  }
}

// optional .TvWall.Packet.RequireSession.RecordRequire recordRequire = 5;
inline bool Packet_RequireSession::has_recordrequire() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Packet_RequireSession::set_has_recordrequire() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Packet_RequireSession::clear_has_recordrequire() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Packet_RequireSession::clear_recordrequire() {
  if (recordrequire_ != NULL) recordrequire_->::TvWall::Packet_RequireSession_RecordRequire::Clear();
  clear_has_recordrequire();
}
inline const ::TvWall::Packet_RequireSession_RecordRequire& Packet_RequireSession::recordrequire() const {
  return recordrequire_ != NULL ? *recordrequire_ : *default_instance_->recordrequire_;
}
inline ::TvWall::Packet_RequireSession_RecordRequire* Packet_RequireSession::mutable_recordrequire() {
  set_has_recordrequire();
  if (recordrequire_ == NULL) recordrequire_ = new ::TvWall::Packet_RequireSession_RecordRequire;
  return recordrequire_;
}
inline ::TvWall::Packet_RequireSession_RecordRequire* Packet_RequireSession::release_recordrequire() {
  clear_has_recordrequire();
  ::TvWall::Packet_RequireSession_RecordRequire* temp = recordrequire_;
  recordrequire_ = NULL;
  return temp;
}
inline void Packet_RequireSession::set_allocated_recordrequire(::TvWall::Packet_RequireSession_RecordRequire* recordrequire) {
  delete recordrequire_;
  recordrequire_ = recordrequire;
  if (recordrequire) {
    set_has_recordrequire();
  } else {
    clear_has_recordrequire();
  }
}

// optional .TvWall.Packet.RequireSession.RecordRequireAck recordRequireAck = 6;
inline bool Packet_RequireSession::has_recordrequireack() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Packet_RequireSession::set_has_recordrequireack() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Packet_RequireSession::clear_has_recordrequireack() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Packet_RequireSession::clear_recordrequireack() {
  if (recordrequireack_ != NULL) recordrequireack_->::TvWall::Packet_RequireSession_RecordRequireAck::Clear();
  clear_has_recordrequireack();
}
inline const ::TvWall::Packet_RequireSession_RecordRequireAck& Packet_RequireSession::recordrequireack() const {
  return recordrequireack_ != NULL ? *recordrequireack_ : *default_instance_->recordrequireack_;
}
inline ::TvWall::Packet_RequireSession_RecordRequireAck* Packet_RequireSession::mutable_recordrequireack() {
  set_has_recordrequireack();
  if (recordrequireack_ == NULL) recordrequireack_ = new ::TvWall::Packet_RequireSession_RecordRequireAck;
  return recordrequireack_;
}
inline ::TvWall::Packet_RequireSession_RecordRequireAck* Packet_RequireSession::release_recordrequireack() {
  clear_has_recordrequireack();
  ::TvWall::Packet_RequireSession_RecordRequireAck* temp = recordrequireack_;
  recordrequireack_ = NULL;
  return temp;
}
inline void Packet_RequireSession::set_allocated_recordrequireack(::TvWall::Packet_RequireSession_RecordRequireAck* recordrequireack) {
  delete recordrequireack_;
  recordrequireack_ = recordrequireack;
  if (recordrequireack) {
    set_has_recordrequireack();
  } else {
    clear_has_recordrequireack();
  }
}

// optional .TvWall.Packet.RequireSession.NetRequire netRequire = 7;
inline bool Packet_RequireSession::has_netrequire() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Packet_RequireSession::set_has_netrequire() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Packet_RequireSession::clear_has_netrequire() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Packet_RequireSession::clear_netrequire() {
  if (netrequire_ != NULL) netrequire_->::TvWall::Packet_RequireSession_NetRequire::Clear();
  clear_has_netrequire();
}
inline const ::TvWall::Packet_RequireSession_NetRequire& Packet_RequireSession::netrequire() const {
  return netrequire_ != NULL ? *netrequire_ : *default_instance_->netrequire_;
}
inline ::TvWall::Packet_RequireSession_NetRequire* Packet_RequireSession::mutable_netrequire() {
  set_has_netrequire();
  if (netrequire_ == NULL) netrequire_ = new ::TvWall::Packet_RequireSession_NetRequire;
  return netrequire_;
}
inline ::TvWall::Packet_RequireSession_NetRequire* Packet_RequireSession::release_netrequire() {
  clear_has_netrequire();
  ::TvWall::Packet_RequireSession_NetRequire* temp = netrequire_;
  netrequire_ = NULL;
  return temp;
}
inline void Packet_RequireSession::set_allocated_netrequire(::TvWall::Packet_RequireSession_NetRequire* netrequire) {
  delete netrequire_;
  netrequire_ = netrequire;
  if (netrequire) {
    set_has_netrequire();
  } else {
    clear_has_netrequire();
  }
}

// optional .TvWall.Packet.RequireSession.NetRequireAck netRequireAck = 8;
inline bool Packet_RequireSession::has_netrequireack() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Packet_RequireSession::set_has_netrequireack() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Packet_RequireSession::clear_has_netrequireack() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Packet_RequireSession::clear_netrequireack() {
  if (netrequireack_ != NULL) netrequireack_->::TvWall::Packet_RequireSession_NetRequireAck::Clear();
  clear_has_netrequireack();
}
inline const ::TvWall::Packet_RequireSession_NetRequireAck& Packet_RequireSession::netrequireack() const {
  return netrequireack_ != NULL ? *netrequireack_ : *default_instance_->netrequireack_;
}
inline ::TvWall::Packet_RequireSession_NetRequireAck* Packet_RequireSession::mutable_netrequireack() {
  set_has_netrequireack();
  if (netrequireack_ == NULL) netrequireack_ = new ::TvWall::Packet_RequireSession_NetRequireAck;
  return netrequireack_;
}
inline ::TvWall::Packet_RequireSession_NetRequireAck* Packet_RequireSession::release_netrequireack() {
  clear_has_netrequireack();
  ::TvWall::Packet_RequireSession_NetRequireAck* temp = netrequireack_;
  netrequireack_ = NULL;
  return temp;
}
inline void Packet_RequireSession::set_allocated_netrequireack(::TvWall::Packet_RequireSession_NetRequireAck* netrequireack) {
  delete netrequireack_;
  netrequireack_ = netrequireack;
  if (netrequireack) {
    set_has_netrequireack();
  } else {
    clear_has_netrequireack();
  }
}

// -------------------------------------------------------------------

// Packet_Notice_Stat_ScreenSpliStat

// required int32 screenIndex = 2;
inline bool Packet_Notice_Stat_ScreenSpliStat::has_screenindex() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Packet_Notice_Stat_ScreenSpliStat::set_has_screenindex() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Packet_Notice_Stat_ScreenSpliStat::clear_has_screenindex() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Packet_Notice_Stat_ScreenSpliStat::clear_screenindex() {
  screenindex_ = 0;
  clear_has_screenindex();
}
inline ::google::protobuf::int32 Packet_Notice_Stat_ScreenSpliStat::screenindex() const {
  return screenindex_;
}
inline void Packet_Notice_Stat_ScreenSpliStat::set_screenindex(::google::protobuf::int32 value) {
  set_has_screenindex();
  screenindex_ = value;
}

// required int32 row = 3;
inline bool Packet_Notice_Stat_ScreenSpliStat::has_row() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Packet_Notice_Stat_ScreenSpliStat::set_has_row() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Packet_Notice_Stat_ScreenSpliStat::clear_has_row() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Packet_Notice_Stat_ScreenSpliStat::clear_row() {
  row_ = 0;
  clear_has_row();
}
inline ::google::protobuf::int32 Packet_Notice_Stat_ScreenSpliStat::row() const {
  return row_;
}
inline void Packet_Notice_Stat_ScreenSpliStat::set_row(::google::protobuf::int32 value) {
  set_has_row();
  row_ = value;
}

// required int32 col = 4;
inline bool Packet_Notice_Stat_ScreenSpliStat::has_col() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Packet_Notice_Stat_ScreenSpliStat::set_has_col() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Packet_Notice_Stat_ScreenSpliStat::clear_has_col() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Packet_Notice_Stat_ScreenSpliStat::clear_col() {
  col_ = 0;
  clear_has_col();
}
inline ::google::protobuf::int32 Packet_Notice_Stat_ScreenSpliStat::col() const {
  return col_;
}
inline void Packet_Notice_Stat_ScreenSpliStat::set_col(::google::protobuf::int32 value) {
  set_has_col();
  col_ = value;
}

// -------------------------------------------------------------------

// Packet_Notice_Stat_ViewStat_ViewGeomotryStat

// required .TvWall.Packet.Notice.Stat.ViewStat.ViewGeomotryStat.ViewGeomotryStatType type = 1;
inline bool Packet_Notice_Stat_ViewStat_ViewGeomotryStat::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Packet_Notice_Stat_ViewStat_ViewGeomotryStat::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Packet_Notice_Stat_ViewStat_ViewGeomotryStat::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Packet_Notice_Stat_ViewStat_ViewGeomotryStat::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::TvWall::Packet_Notice_Stat_ViewStat_ViewGeomotryStat_ViewGeomotryStatType Packet_Notice_Stat_ViewStat_ViewGeomotryStat::type() const {
  return static_cast< ::TvWall::Packet_Notice_Stat_ViewStat_ViewGeomotryStat_ViewGeomotryStatType >(type_);
}
inline void Packet_Notice_Stat_ViewStat_ViewGeomotryStat::set_type(::TvWall::Packet_Notice_Stat_ViewStat_ViewGeomotryStat_ViewGeomotryStatType value) {
  assert(::TvWall::Packet_Notice_Stat_ViewStat_ViewGeomotryStat_ViewGeomotryStatType_IsValid(value));
  set_has_type();
  type_ = value;
}

// required .TvWall.Packet.ElementDat.View view = 2;
inline bool Packet_Notice_Stat_ViewStat_ViewGeomotryStat::has_view() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Packet_Notice_Stat_ViewStat_ViewGeomotryStat::set_has_view() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Packet_Notice_Stat_ViewStat_ViewGeomotryStat::clear_has_view() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Packet_Notice_Stat_ViewStat_ViewGeomotryStat::clear_view() {
  if (view_ != NULL) view_->::TvWall::Packet_ElementDat_View::Clear();
  clear_has_view();
}
inline const ::TvWall::Packet_ElementDat_View& Packet_Notice_Stat_ViewStat_ViewGeomotryStat::view() const {
  return view_ != NULL ? *view_ : *default_instance_->view_;
}
inline ::TvWall::Packet_ElementDat_View* Packet_Notice_Stat_ViewStat_ViewGeomotryStat::mutable_view() {
  set_has_view();
  if (view_ == NULL) view_ = new ::TvWall::Packet_ElementDat_View;
  return view_;
}
inline ::TvWall::Packet_ElementDat_View* Packet_Notice_Stat_ViewStat_ViewGeomotryStat::release_view() {
  clear_has_view();
  ::TvWall::Packet_ElementDat_View* temp = view_;
  view_ = NULL;
  return temp;
}
inline void Packet_Notice_Stat_ViewStat_ViewGeomotryStat::set_allocated_view(::TvWall::Packet_ElementDat_View* view) {
  delete view_;
  view_ = view;
  if (view) {
    set_has_view();
  } else {
    clear_has_view();
  }
}

// optional string url = 3;
inline bool Packet_Notice_Stat_ViewStat_ViewGeomotryStat::has_url() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Packet_Notice_Stat_ViewStat_ViewGeomotryStat::set_has_url() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Packet_Notice_Stat_ViewStat_ViewGeomotryStat::clear_has_url() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Packet_Notice_Stat_ViewStat_ViewGeomotryStat::clear_url() {
  if (url_ != &::google::protobuf::internal::kEmptyString) {
    url_->clear();
  }
  clear_has_url();
}
inline const ::std::string& Packet_Notice_Stat_ViewStat_ViewGeomotryStat::url() const {
  return *url_;
}
inline void Packet_Notice_Stat_ViewStat_ViewGeomotryStat::set_url(const ::std::string& value) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  url_->assign(value);
}
inline void Packet_Notice_Stat_ViewStat_ViewGeomotryStat::set_url(const char* value) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  url_->assign(value);
}
inline void Packet_Notice_Stat_ViewStat_ViewGeomotryStat::set_url(const char* value, size_t size) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  url_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Packet_Notice_Stat_ViewStat_ViewGeomotryStat::mutable_url() {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  return url_;
}
inline ::std::string* Packet_Notice_Stat_ViewStat_ViewGeomotryStat::release_url() {
  clear_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = url_;
    url_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Packet_Notice_Stat_ViewStat_ViewGeomotryStat::set_allocated_url(::std::string* url) {
  if (url_ != &::google::protobuf::internal::kEmptyString) {
    delete url_;
  }
  if (url) {
    set_has_url();
    url_ = url;
  } else {
    clear_has_url();
    url_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// Packet_Notice_Stat_ViewStat_VideoStat

// required .TvWall.Packet.Notice.Stat.ViewStat.VideoStat.VideoStatType type = 1;
inline bool Packet_Notice_Stat_ViewStat_VideoStat::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Packet_Notice_Stat_ViewStat_VideoStat::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Packet_Notice_Stat_ViewStat_VideoStat::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Packet_Notice_Stat_ViewStat_VideoStat::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::TvWall::Packet_Notice_Stat_ViewStat_VideoStat_VideoStatType Packet_Notice_Stat_ViewStat_VideoStat::type() const {
  return static_cast< ::TvWall::Packet_Notice_Stat_ViewStat_VideoStat_VideoStatType >(type_);
}
inline void Packet_Notice_Stat_ViewStat_VideoStat::set_type(::TvWall::Packet_Notice_Stat_ViewStat_VideoStat_VideoStatType value) {
  assert(::TvWall::Packet_Notice_Stat_ViewStat_VideoStat_VideoStatType_IsValid(value));
  set_has_type();
  type_ = value;
}

// required int32 winId = 2;
inline bool Packet_Notice_Stat_ViewStat_VideoStat::has_winid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Packet_Notice_Stat_ViewStat_VideoStat::set_has_winid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Packet_Notice_Stat_ViewStat_VideoStat::clear_has_winid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Packet_Notice_Stat_ViewStat_VideoStat::clear_winid() {
  winid_ = 0;
  clear_has_winid();
}
inline ::google::protobuf::int32 Packet_Notice_Stat_ViewStat_VideoStat::winid() const {
  return winid_;
}
inline void Packet_Notice_Stat_ViewStat_VideoStat::set_winid(::google::protobuf::int32 value) {
  set_has_winid();
  winid_ = value;
}

// repeated .TvWall.Guid cameraId = 3;
inline int Packet_Notice_Stat_ViewStat_VideoStat::cameraid_size() const {
  return cameraid_.size();
}
inline void Packet_Notice_Stat_ViewStat_VideoStat::clear_cameraid() {
  cameraid_.Clear();
}
inline const ::TvWall::Guid& Packet_Notice_Stat_ViewStat_VideoStat::cameraid(int index) const {
  return cameraid_.Get(index);
}
inline ::TvWall::Guid* Packet_Notice_Stat_ViewStat_VideoStat::mutable_cameraid(int index) {
  return cameraid_.Mutable(index);
}
inline ::TvWall::Guid* Packet_Notice_Stat_ViewStat_VideoStat::add_cameraid() {
  return cameraid_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TvWall::Guid >&
Packet_Notice_Stat_ViewStat_VideoStat::cameraid() const {
  return cameraid_;
}
inline ::google::protobuf::RepeatedPtrField< ::TvWall::Guid >*
Packet_Notice_Stat_ViewStat_VideoStat::mutable_cameraid() {
  return &cameraid_;
}

// optional int32 pollInterval = 4;
inline bool Packet_Notice_Stat_ViewStat_VideoStat::has_pollinterval() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Packet_Notice_Stat_ViewStat_VideoStat::set_has_pollinterval() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Packet_Notice_Stat_ViewStat_VideoStat::clear_has_pollinterval() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Packet_Notice_Stat_ViewStat_VideoStat::clear_pollinterval() {
  pollinterval_ = 0;
  clear_has_pollinterval();
}
inline ::google::protobuf::int32 Packet_Notice_Stat_ViewStat_VideoStat::pollinterval() const {
  return pollinterval_;
}
inline void Packet_Notice_Stat_ViewStat_VideoStat::set_pollinterval(::google::protobuf::int32 value) {
  set_has_pollinterval();
  pollinterval_ = value;
}

// optional bool keepStretch = 5;
inline bool Packet_Notice_Stat_ViewStat_VideoStat::has_keepstretch() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Packet_Notice_Stat_ViewStat_VideoStat::set_has_keepstretch() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Packet_Notice_Stat_ViewStat_VideoStat::clear_has_keepstretch() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Packet_Notice_Stat_ViewStat_VideoStat::clear_keepstretch() {
  keepstretch_ = false;
  clear_has_keepstretch();
}
inline bool Packet_Notice_Stat_ViewStat_VideoStat::keepstretch() const {
  return keepstretch_;
}
inline void Packet_Notice_Stat_ViewStat_VideoStat::set_keepstretch(bool value) {
  set_has_keepstretch();
  keepstretch_ = value;
}

// repeated .TvWall.Guid cameraIddy = 6;
inline int Packet_Notice_Stat_ViewStat_VideoStat::cameraiddy_size() const {
  return cameraiddy_.size();
}
inline void Packet_Notice_Stat_ViewStat_VideoStat::clear_cameraiddy() {
  cameraiddy_.Clear();
}
inline const ::TvWall::Guid& Packet_Notice_Stat_ViewStat_VideoStat::cameraiddy(int index) const {
  return cameraiddy_.Get(index);
}
inline ::TvWall::Guid* Packet_Notice_Stat_ViewStat_VideoStat::mutable_cameraiddy(int index) {
  return cameraiddy_.Mutable(index);
}
inline ::TvWall::Guid* Packet_Notice_Stat_ViewStat_VideoStat::add_cameraiddy() {
  return cameraiddy_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TvWall::Guid >&
Packet_Notice_Stat_ViewStat_VideoStat::cameraiddy() const {
  return cameraiddy_;
}
inline ::google::protobuf::RepeatedPtrField< ::TvWall::Guid >*
Packet_Notice_Stat_ViewStat_VideoStat::mutable_cameraiddy() {
  return &cameraiddy_;
}

// -------------------------------------------------------------------

// Packet_Notice_Stat_ViewStat_RecordStat

// required .TvWall.Packet.Notice.Stat.ViewStat.RecordStat.RecordStatType type = 1;
inline bool Packet_Notice_Stat_ViewStat_RecordStat::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Packet_Notice_Stat_ViewStat_RecordStat::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Packet_Notice_Stat_ViewStat_RecordStat::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Packet_Notice_Stat_ViewStat_RecordStat::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::TvWall::Packet_Notice_Stat_ViewStat_RecordStat_RecordStatType Packet_Notice_Stat_ViewStat_RecordStat::type() const {
  return static_cast< ::TvWall::Packet_Notice_Stat_ViewStat_RecordStat_RecordStatType >(type_);
}
inline void Packet_Notice_Stat_ViewStat_RecordStat::set_type(::TvWall::Packet_Notice_Stat_ViewStat_RecordStat_RecordStatType value) {
  assert(::TvWall::Packet_Notice_Stat_ViewStat_RecordStat_RecordStatType_IsValid(value));
  set_has_type();
  type_ = value;
}

// required int32 winId = 2;
inline bool Packet_Notice_Stat_ViewStat_RecordStat::has_winid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Packet_Notice_Stat_ViewStat_RecordStat::set_has_winid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Packet_Notice_Stat_ViewStat_RecordStat::clear_has_winid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Packet_Notice_Stat_ViewStat_RecordStat::clear_winid() {
  winid_ = 0;
  clear_has_winid();
}
inline ::google::protobuf::int32 Packet_Notice_Stat_ViewStat_RecordStat::winid() const {
  return winid_;
}
inline void Packet_Notice_Stat_ViewStat_RecordStat::set_winid(::google::protobuf::int32 value) {
  set_has_winid();
  winid_ = value;
}

// required .TvWall.Guid cameraId = 3;
inline bool Packet_Notice_Stat_ViewStat_RecordStat::has_cameraid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Packet_Notice_Stat_ViewStat_RecordStat::set_has_cameraid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Packet_Notice_Stat_ViewStat_RecordStat::clear_has_cameraid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Packet_Notice_Stat_ViewStat_RecordStat::clear_cameraid() {
  if (cameraid_ != NULL) cameraid_->::TvWall::Guid::Clear();
  clear_has_cameraid();
}
inline const ::TvWall::Guid& Packet_Notice_Stat_ViewStat_RecordStat::cameraid() const {
  return cameraid_ != NULL ? *cameraid_ : *default_instance_->cameraid_;
}
inline ::TvWall::Guid* Packet_Notice_Stat_ViewStat_RecordStat::mutable_cameraid() {
  set_has_cameraid();
  if (cameraid_ == NULL) cameraid_ = new ::TvWall::Guid;
  return cameraid_;
}
inline ::TvWall::Guid* Packet_Notice_Stat_ViewStat_RecordStat::release_cameraid() {
  clear_has_cameraid();
  ::TvWall::Guid* temp = cameraid_;
  cameraid_ = NULL;
  return temp;
}
inline void Packet_Notice_Stat_ViewStat_RecordStat::set_allocated_cameraid(::TvWall::Guid* cameraid) {
  delete cameraid_;
  cameraid_ = cameraid;
  if (cameraid) {
    set_has_cameraid();
  } else {
    clear_has_cameraid();
  }
}

// optional uint64 startTime = 4;
inline bool Packet_Notice_Stat_ViewStat_RecordStat::has_starttime() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Packet_Notice_Stat_ViewStat_RecordStat::set_has_starttime() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Packet_Notice_Stat_ViewStat_RecordStat::clear_has_starttime() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Packet_Notice_Stat_ViewStat_RecordStat::clear_starttime() {
  starttime_ = GOOGLE_ULONGLONG(0);
  clear_has_starttime();
}
inline ::google::protobuf::uint64 Packet_Notice_Stat_ViewStat_RecordStat::starttime() const {
  return starttime_;
}
inline void Packet_Notice_Stat_ViewStat_RecordStat::set_starttime(::google::protobuf::uint64 value) {
  set_has_starttime();
  starttime_ = value;
}

// optional bool keepStretch = 5;
inline bool Packet_Notice_Stat_ViewStat_RecordStat::has_keepstretch() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Packet_Notice_Stat_ViewStat_RecordStat::set_has_keepstretch() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Packet_Notice_Stat_ViewStat_RecordStat::clear_has_keepstretch() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Packet_Notice_Stat_ViewStat_RecordStat::clear_keepstretch() {
  keepstretch_ = false;
  clear_has_keepstretch();
}
inline bool Packet_Notice_Stat_ViewStat_RecordStat::keepstretch() const {
  return keepstretch_;
}
inline void Packet_Notice_Stat_ViewStat_RecordStat::set_keepstretch(bool value) {
  set_has_keepstretch();
  keepstretch_ = value;
}

// optional int32 rate = 6;
inline bool Packet_Notice_Stat_ViewStat_RecordStat::has_rate() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Packet_Notice_Stat_ViewStat_RecordStat::set_has_rate() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Packet_Notice_Stat_ViewStat_RecordStat::clear_has_rate() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Packet_Notice_Stat_ViewStat_RecordStat::clear_rate() {
  rate_ = 0;
  clear_has_rate();
}
inline ::google::protobuf::int32 Packet_Notice_Stat_ViewStat_RecordStat::rate() const {
  return rate_;
}
inline void Packet_Notice_Stat_ViewStat_RecordStat::set_rate(::google::protobuf::int32 value) {
  set_has_rate();
  rate_ = value;
}

// -------------------------------------------------------------------

// Packet_Notice_Stat_ViewStat_LocalMovieStat

// required .TvWall.Packet.Notice.Stat.ViewStat.LocalMovieStat.LocalMovieType type = 1;
inline bool Packet_Notice_Stat_ViewStat_LocalMovieStat::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Packet_Notice_Stat_ViewStat_LocalMovieStat::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Packet_Notice_Stat_ViewStat_LocalMovieStat::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Packet_Notice_Stat_ViewStat_LocalMovieStat::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::TvWall::Packet_Notice_Stat_ViewStat_LocalMovieStat_LocalMovieType Packet_Notice_Stat_ViewStat_LocalMovieStat::type() const {
  return static_cast< ::TvWall::Packet_Notice_Stat_ViewStat_LocalMovieStat_LocalMovieType >(type_);
}
inline void Packet_Notice_Stat_ViewStat_LocalMovieStat::set_type(::TvWall::Packet_Notice_Stat_ViewStat_LocalMovieStat_LocalMovieType value) {
  assert(::TvWall::Packet_Notice_Stat_ViewStat_LocalMovieStat_LocalMovieType_IsValid(value));
  set_has_type();
  type_ = value;
}

// required int32 winId = 2;
inline bool Packet_Notice_Stat_ViewStat_LocalMovieStat::has_winid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Packet_Notice_Stat_ViewStat_LocalMovieStat::set_has_winid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Packet_Notice_Stat_ViewStat_LocalMovieStat::clear_has_winid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Packet_Notice_Stat_ViewStat_LocalMovieStat::clear_winid() {
  winid_ = 0;
  clear_has_winid();
}
inline ::google::protobuf::int32 Packet_Notice_Stat_ViewStat_LocalMovieStat::winid() const {
  return winid_;
}
inline void Packet_Notice_Stat_ViewStat_LocalMovieStat::set_winid(::google::protobuf::int32 value) {
  set_has_winid();
  winid_ = value;
}

// optional string url = 3;
inline bool Packet_Notice_Stat_ViewStat_LocalMovieStat::has_url() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Packet_Notice_Stat_ViewStat_LocalMovieStat::set_has_url() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Packet_Notice_Stat_ViewStat_LocalMovieStat::clear_has_url() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Packet_Notice_Stat_ViewStat_LocalMovieStat::clear_url() {
  if (url_ != &::google::protobuf::internal::kEmptyString) {
    url_->clear();
  }
  clear_has_url();
}
inline const ::std::string& Packet_Notice_Stat_ViewStat_LocalMovieStat::url() const {
  return *url_;
}
inline void Packet_Notice_Stat_ViewStat_LocalMovieStat::set_url(const ::std::string& value) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  url_->assign(value);
}
inline void Packet_Notice_Stat_ViewStat_LocalMovieStat::set_url(const char* value) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  url_->assign(value);
}
inline void Packet_Notice_Stat_ViewStat_LocalMovieStat::set_url(const char* value, size_t size) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  url_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Packet_Notice_Stat_ViewStat_LocalMovieStat::mutable_url() {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  return url_;
}
inline ::std::string* Packet_Notice_Stat_ViewStat_LocalMovieStat::release_url() {
  clear_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = url_;
    url_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Packet_Notice_Stat_ViewStat_LocalMovieStat::set_allocated_url(::std::string* url) {
  if (url_ != &::google::protobuf::internal::kEmptyString) {
    delete url_;
  }
  if (url) {
    set_has_url();
    url_ = url;
  } else {
    clear_has_url();
    url_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 volume = 4;
inline bool Packet_Notice_Stat_ViewStat_LocalMovieStat::has_volume() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Packet_Notice_Stat_ViewStat_LocalMovieStat::set_has_volume() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Packet_Notice_Stat_ViewStat_LocalMovieStat::clear_has_volume() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Packet_Notice_Stat_ViewStat_LocalMovieStat::clear_volume() {
  volume_ = 0;
  clear_has_volume();
}
inline ::google::protobuf::int32 Packet_Notice_Stat_ViewStat_LocalMovieStat::volume() const {
  return volume_;
}
inline void Packet_Notice_Stat_ViewStat_LocalMovieStat::set_volume(::google::protobuf::int32 value) {
  set_has_volume();
  volume_ = value;
}

// optional int64 timeStamp = 5;
inline bool Packet_Notice_Stat_ViewStat_LocalMovieStat::has_timestamp() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Packet_Notice_Stat_ViewStat_LocalMovieStat::set_has_timestamp() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Packet_Notice_Stat_ViewStat_LocalMovieStat::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Packet_Notice_Stat_ViewStat_LocalMovieStat::clear_timestamp() {
  timestamp_ = GOOGLE_LONGLONG(0);
  clear_has_timestamp();
}
inline ::google::protobuf::int64 Packet_Notice_Stat_ViewStat_LocalMovieStat::timestamp() const {
  return timestamp_;
}
inline void Packet_Notice_Stat_ViewStat_LocalMovieStat::set_timestamp(::google::protobuf::int64 value) {
  set_has_timestamp();
  timestamp_ = value;
}

// -------------------------------------------------------------------

// Packet_Notice_Stat_ViewStat_FlashStat

// required .TvWall.Packet.Notice.Stat.ViewStat.FlashStat.FlashStatType type = 1;
inline bool Packet_Notice_Stat_ViewStat_FlashStat::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Packet_Notice_Stat_ViewStat_FlashStat::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Packet_Notice_Stat_ViewStat_FlashStat::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Packet_Notice_Stat_ViewStat_FlashStat::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::TvWall::Packet_Notice_Stat_ViewStat_FlashStat_FlashStatType Packet_Notice_Stat_ViewStat_FlashStat::type() const {
  return static_cast< ::TvWall::Packet_Notice_Stat_ViewStat_FlashStat_FlashStatType >(type_);
}
inline void Packet_Notice_Stat_ViewStat_FlashStat::set_type(::TvWall::Packet_Notice_Stat_ViewStat_FlashStat_FlashStatType value) {
  assert(::TvWall::Packet_Notice_Stat_ViewStat_FlashStat_FlashStatType_IsValid(value));
  set_has_type();
  type_ = value;
}

// required int32 winId = 2;
inline bool Packet_Notice_Stat_ViewStat_FlashStat::has_winid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Packet_Notice_Stat_ViewStat_FlashStat::set_has_winid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Packet_Notice_Stat_ViewStat_FlashStat::clear_has_winid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Packet_Notice_Stat_ViewStat_FlashStat::clear_winid() {
  winid_ = 0;
  clear_has_winid();
}
inline ::google::protobuf::int32 Packet_Notice_Stat_ViewStat_FlashStat::winid() const {
  return winid_;
}
inline void Packet_Notice_Stat_ViewStat_FlashStat::set_winid(::google::protobuf::int32 value) {
  set_has_winid();
  winid_ = value;
}

// required string url = 3;
inline bool Packet_Notice_Stat_ViewStat_FlashStat::has_url() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Packet_Notice_Stat_ViewStat_FlashStat::set_has_url() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Packet_Notice_Stat_ViewStat_FlashStat::clear_has_url() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Packet_Notice_Stat_ViewStat_FlashStat::clear_url() {
  if (url_ != &::google::protobuf::internal::kEmptyString) {
    url_->clear();
  }
  clear_has_url();
}
inline const ::std::string& Packet_Notice_Stat_ViewStat_FlashStat::url() const {
  return *url_;
}
inline void Packet_Notice_Stat_ViewStat_FlashStat::set_url(const ::std::string& value) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  url_->assign(value);
}
inline void Packet_Notice_Stat_ViewStat_FlashStat::set_url(const char* value) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  url_->assign(value);
}
inline void Packet_Notice_Stat_ViewStat_FlashStat::set_url(const char* value, size_t size) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  url_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Packet_Notice_Stat_ViewStat_FlashStat::mutable_url() {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  return url_;
}
inline ::std::string* Packet_Notice_Stat_ViewStat_FlashStat::release_url() {
  clear_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = url_;
    url_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Packet_Notice_Stat_ViewStat_FlashStat::set_allocated_url(::std::string* url) {
  if (url_ != &::google::protobuf::internal::kEmptyString) {
    delete url_;
  }
  if (url) {
    set_has_url();
    url_ = url;
  } else {
    clear_has_url();
    url_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// Packet_Notice_Stat_ViewStat_HTMLStat

// required .TvWall.Packet.Notice.Stat.ViewStat.HTMLStat.HTMLStatType type = 1;
inline bool Packet_Notice_Stat_ViewStat_HTMLStat::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Packet_Notice_Stat_ViewStat_HTMLStat::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Packet_Notice_Stat_ViewStat_HTMLStat::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Packet_Notice_Stat_ViewStat_HTMLStat::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::TvWall::Packet_Notice_Stat_ViewStat_HTMLStat_HTMLStatType Packet_Notice_Stat_ViewStat_HTMLStat::type() const {
  return static_cast< ::TvWall::Packet_Notice_Stat_ViewStat_HTMLStat_HTMLStatType >(type_);
}
inline void Packet_Notice_Stat_ViewStat_HTMLStat::set_type(::TvWall::Packet_Notice_Stat_ViewStat_HTMLStat_HTMLStatType value) {
  assert(::TvWall::Packet_Notice_Stat_ViewStat_HTMLStat_HTMLStatType_IsValid(value));
  set_has_type();
  type_ = value;
}

// required int32 winId = 2;
inline bool Packet_Notice_Stat_ViewStat_HTMLStat::has_winid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Packet_Notice_Stat_ViewStat_HTMLStat::set_has_winid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Packet_Notice_Stat_ViewStat_HTMLStat::clear_has_winid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Packet_Notice_Stat_ViewStat_HTMLStat::clear_winid() {
  winid_ = 0;
  clear_has_winid();
}
inline ::google::protobuf::int32 Packet_Notice_Stat_ViewStat_HTMLStat::winid() const {
  return winid_;
}
inline void Packet_Notice_Stat_ViewStat_HTMLStat::set_winid(::google::protobuf::int32 value) {
  set_has_winid();
  winid_ = value;
}

// required string url = 3;
inline bool Packet_Notice_Stat_ViewStat_HTMLStat::has_url() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Packet_Notice_Stat_ViewStat_HTMLStat::set_has_url() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Packet_Notice_Stat_ViewStat_HTMLStat::clear_has_url() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Packet_Notice_Stat_ViewStat_HTMLStat::clear_url() {
  if (url_ != &::google::protobuf::internal::kEmptyString) {
    url_->clear();
  }
  clear_has_url();
}
inline const ::std::string& Packet_Notice_Stat_ViewStat_HTMLStat::url() const {
  return *url_;
}
inline void Packet_Notice_Stat_ViewStat_HTMLStat::set_url(const ::std::string& value) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  url_->assign(value);
}
inline void Packet_Notice_Stat_ViewStat_HTMLStat::set_url(const char* value) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  url_->assign(value);
}
inline void Packet_Notice_Stat_ViewStat_HTMLStat::set_url(const char* value, size_t size) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  url_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Packet_Notice_Stat_ViewStat_HTMLStat::mutable_url() {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  return url_;
}
inline ::std::string* Packet_Notice_Stat_ViewStat_HTMLStat::release_url() {
  clear_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = url_;
    url_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Packet_Notice_Stat_ViewStat_HTMLStat::set_allocated_url(::std::string* url) {
  if (url_ != &::google::protobuf::internal::kEmptyString) {
    delete url_;
  }
  if (url) {
    set_has_url();
    url_ = url;
  } else {
    clear_has_url();
    url_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// Packet_Notice_Stat_ViewStat_TextStat

// required .TvWall.Packet.Notice.Stat.ViewStat.TextStat.TextStatType type = 1;
inline bool Packet_Notice_Stat_ViewStat_TextStat::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Packet_Notice_Stat_ViewStat_TextStat::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Packet_Notice_Stat_ViewStat_TextStat::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Packet_Notice_Stat_ViewStat_TextStat::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::TvWall::Packet_Notice_Stat_ViewStat_TextStat_TextStatType Packet_Notice_Stat_ViewStat_TextStat::type() const {
  return static_cast< ::TvWall::Packet_Notice_Stat_ViewStat_TextStat_TextStatType >(type_);
}
inline void Packet_Notice_Stat_ViewStat_TextStat::set_type(::TvWall::Packet_Notice_Stat_ViewStat_TextStat_TextStatType value) {
  assert(::TvWall::Packet_Notice_Stat_ViewStat_TextStat_TextStatType_IsValid(value));
  set_has_type();
  type_ = value;
}

// required int32 winId = 2;
inline bool Packet_Notice_Stat_ViewStat_TextStat::has_winid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Packet_Notice_Stat_ViewStat_TextStat::set_has_winid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Packet_Notice_Stat_ViewStat_TextStat::clear_has_winid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Packet_Notice_Stat_ViewStat_TextStat::clear_winid() {
  winid_ = 0;
  clear_has_winid();
}
inline ::google::protobuf::int32 Packet_Notice_Stat_ViewStat_TextStat::winid() const {
  return winid_;
}
inline void Packet_Notice_Stat_ViewStat_TextStat::set_winid(::google::protobuf::int32 value) {
  set_has_winid();
  winid_ = value;
}

// optional string text = 3;
inline bool Packet_Notice_Stat_ViewStat_TextStat::has_text() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Packet_Notice_Stat_ViewStat_TextStat::set_has_text() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Packet_Notice_Stat_ViewStat_TextStat::clear_has_text() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Packet_Notice_Stat_ViewStat_TextStat::clear_text() {
  if (text_ != &::google::protobuf::internal::kEmptyString) {
    text_->clear();
  }
  clear_has_text();
}
inline const ::std::string& Packet_Notice_Stat_ViewStat_TextStat::text() const {
  return *text_;
}
inline void Packet_Notice_Stat_ViewStat_TextStat::set_text(const ::std::string& value) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(value);
}
inline void Packet_Notice_Stat_ViewStat_TextStat::set_text(const char* value) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(value);
}
inline void Packet_Notice_Stat_ViewStat_TextStat::set_text(const char* value, size_t size) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Packet_Notice_Stat_ViewStat_TextStat::mutable_text() {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  return text_;
}
inline ::std::string* Packet_Notice_Stat_ViewStat_TextStat::release_text() {
  clear_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = text_;
    text_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Packet_Notice_Stat_ViewStat_TextStat::set_allocated_text(::std::string* text) {
  if (text_ != &::google::protobuf::internal::kEmptyString) {
    delete text_;
  }
  if (text) {
    set_has_text();
    text_ = text;
  } else {
    clear_has_text();
    text_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// Packet_Notice_Stat_ViewStat_MapStat

// required .TvWall.Packet.Notice.Stat.ViewStat.MapStat.MapCtrlType type = 1;
inline bool Packet_Notice_Stat_ViewStat_MapStat::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Packet_Notice_Stat_ViewStat_MapStat::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Packet_Notice_Stat_ViewStat_MapStat::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Packet_Notice_Stat_ViewStat_MapStat::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::TvWall::Packet_Notice_Stat_ViewStat_MapStat_MapCtrlType Packet_Notice_Stat_ViewStat_MapStat::type() const {
  return static_cast< ::TvWall::Packet_Notice_Stat_ViewStat_MapStat_MapCtrlType >(type_);
}
inline void Packet_Notice_Stat_ViewStat_MapStat::set_type(::TvWall::Packet_Notice_Stat_ViewStat_MapStat_MapCtrlType value) {
  assert(::TvWall::Packet_Notice_Stat_ViewStat_MapStat_MapCtrlType_IsValid(value));
  set_has_type();
  type_ = value;
}

// required int32 winId = 2;
inline bool Packet_Notice_Stat_ViewStat_MapStat::has_winid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Packet_Notice_Stat_ViewStat_MapStat::set_has_winid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Packet_Notice_Stat_ViewStat_MapStat::clear_has_winid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Packet_Notice_Stat_ViewStat_MapStat::clear_winid() {
  winid_ = 0;
  clear_has_winid();
}
inline ::google::protobuf::int32 Packet_Notice_Stat_ViewStat_MapStat::winid() const {
  return winid_;
}
inline void Packet_Notice_Stat_ViewStat_MapStat::set_winid(::google::protobuf::int32 value) {
  set_has_winid();
  winid_ = value;
}

// optional string url = 3;
inline bool Packet_Notice_Stat_ViewStat_MapStat::has_url() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Packet_Notice_Stat_ViewStat_MapStat::set_has_url() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Packet_Notice_Stat_ViewStat_MapStat::clear_has_url() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Packet_Notice_Stat_ViewStat_MapStat::clear_url() {
  if (url_ != &::google::protobuf::internal::kEmptyString) {
    url_->clear();
  }
  clear_has_url();
}
inline const ::std::string& Packet_Notice_Stat_ViewStat_MapStat::url() const {
  return *url_;
}
inline void Packet_Notice_Stat_ViewStat_MapStat::set_url(const ::std::string& value) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  url_->assign(value);
}
inline void Packet_Notice_Stat_ViewStat_MapStat::set_url(const char* value) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  url_->assign(value);
}
inline void Packet_Notice_Stat_ViewStat_MapStat::set_url(const char* value, size_t size) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  url_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Packet_Notice_Stat_ViewStat_MapStat::mutable_url() {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  return url_;
}
inline ::std::string* Packet_Notice_Stat_ViewStat_MapStat::release_url() {
  clear_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = url_;
    url_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Packet_Notice_Stat_ViewStat_MapStat::set_allocated_url(::std::string* url) {
  if (url_ != &::google::protobuf::internal::kEmptyString) {
    delete url_;
  }
  if (url) {
    set_has_url();
    url_ = url;
  } else {
    clear_has_url();
    url_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// Packet_Notice_Stat_ViewStat_OthersStat

// required .TvWall.Packet.Notice.Stat.ViewStat.OthersStat.OthersStatType type = 1;
inline bool Packet_Notice_Stat_ViewStat_OthersStat::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Packet_Notice_Stat_ViewStat_OthersStat::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Packet_Notice_Stat_ViewStat_OthersStat::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Packet_Notice_Stat_ViewStat_OthersStat::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::TvWall::Packet_Notice_Stat_ViewStat_OthersStat_OthersStatType Packet_Notice_Stat_ViewStat_OthersStat::type() const {
  return static_cast< ::TvWall::Packet_Notice_Stat_ViewStat_OthersStat_OthersStatType >(type_);
}
inline void Packet_Notice_Stat_ViewStat_OthersStat::set_type(::TvWall::Packet_Notice_Stat_ViewStat_OthersStat_OthersStatType value) {
  assert(::TvWall::Packet_Notice_Stat_ViewStat_OthersStat_OthersStatType_IsValid(value));
  set_has_type();
  type_ = value;
}

// required int32 winId = 2;
inline bool Packet_Notice_Stat_ViewStat_OthersStat::has_winid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Packet_Notice_Stat_ViewStat_OthersStat::set_has_winid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Packet_Notice_Stat_ViewStat_OthersStat::clear_has_winid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Packet_Notice_Stat_ViewStat_OthersStat::clear_winid() {
  winid_ = 0;
  clear_has_winid();
}
inline ::google::protobuf::int32 Packet_Notice_Stat_ViewStat_OthersStat::winid() const {
  return winid_;
}
inline void Packet_Notice_Stat_ViewStat_OthersStat::set_winid(::google::protobuf::int32 value) {
  set_has_winid();
  winid_ = value;
}

// optional string serName = 3;
inline bool Packet_Notice_Stat_ViewStat_OthersStat::has_sername() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Packet_Notice_Stat_ViewStat_OthersStat::set_has_sername() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Packet_Notice_Stat_ViewStat_OthersStat::clear_has_sername() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Packet_Notice_Stat_ViewStat_OthersStat::clear_sername() {
  if (sername_ != &::google::protobuf::internal::kEmptyString) {
    sername_->clear();
  }
  clear_has_sername();
}
inline const ::std::string& Packet_Notice_Stat_ViewStat_OthersStat::sername() const {
  return *sername_;
}
inline void Packet_Notice_Stat_ViewStat_OthersStat::set_sername(const ::std::string& value) {
  set_has_sername();
  if (sername_ == &::google::protobuf::internal::kEmptyString) {
    sername_ = new ::std::string;
  }
  sername_->assign(value);
}
inline void Packet_Notice_Stat_ViewStat_OthersStat::set_sername(const char* value) {
  set_has_sername();
  if (sername_ == &::google::protobuf::internal::kEmptyString) {
    sername_ = new ::std::string;
  }
  sername_->assign(value);
}
inline void Packet_Notice_Stat_ViewStat_OthersStat::set_sername(const char* value, size_t size) {
  set_has_sername();
  if (sername_ == &::google::protobuf::internal::kEmptyString) {
    sername_ = new ::std::string;
  }
  sername_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Packet_Notice_Stat_ViewStat_OthersStat::mutable_sername() {
  set_has_sername();
  if (sername_ == &::google::protobuf::internal::kEmptyString) {
    sername_ = new ::std::string;
  }
  return sername_;
}
inline ::std::string* Packet_Notice_Stat_ViewStat_OthersStat::release_sername() {
  clear_has_sername();
  if (sername_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sername_;
    sername_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Packet_Notice_Stat_ViewStat_OthersStat::set_allocated_sername(::std::string* sername) {
  if (sername_ != &::google::protobuf::internal::kEmptyString) {
    delete sername_;
  }
  if (sername) {
    set_has_sername();
    sername_ = sername;
  } else {
    clear_has_sername();
    sername_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// Packet_Notice_Stat_ViewStat

// optional .TvWall.Packet.Notice.Stat.ViewStat.VideoStat videoStat = 1;
inline bool Packet_Notice_Stat_ViewStat::has_videostat() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Packet_Notice_Stat_ViewStat::set_has_videostat() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Packet_Notice_Stat_ViewStat::clear_has_videostat() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Packet_Notice_Stat_ViewStat::clear_videostat() {
  if (videostat_ != NULL) videostat_->::TvWall::Packet_Notice_Stat_ViewStat_VideoStat::Clear();
  clear_has_videostat();
}
inline const ::TvWall::Packet_Notice_Stat_ViewStat_VideoStat& Packet_Notice_Stat_ViewStat::videostat() const {
  return videostat_ != NULL ? *videostat_ : *default_instance_->videostat_;
}
inline ::TvWall::Packet_Notice_Stat_ViewStat_VideoStat* Packet_Notice_Stat_ViewStat::mutable_videostat() {
  set_has_videostat();
  if (videostat_ == NULL) videostat_ = new ::TvWall::Packet_Notice_Stat_ViewStat_VideoStat;
  return videostat_;
}
inline ::TvWall::Packet_Notice_Stat_ViewStat_VideoStat* Packet_Notice_Stat_ViewStat::release_videostat() {
  clear_has_videostat();
  ::TvWall::Packet_Notice_Stat_ViewStat_VideoStat* temp = videostat_;
  videostat_ = NULL;
  return temp;
}
inline void Packet_Notice_Stat_ViewStat::set_allocated_videostat(::TvWall::Packet_Notice_Stat_ViewStat_VideoStat* videostat) {
  delete videostat_;
  videostat_ = videostat;
  if (videostat) {
    set_has_videostat();
  } else {
    clear_has_videostat();
  }
}

// optional .TvWall.Packet.Notice.Stat.ViewStat.FlashStat flashStat = 2;
inline bool Packet_Notice_Stat_ViewStat::has_flashstat() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Packet_Notice_Stat_ViewStat::set_has_flashstat() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Packet_Notice_Stat_ViewStat::clear_has_flashstat() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Packet_Notice_Stat_ViewStat::clear_flashstat() {
  if (flashstat_ != NULL) flashstat_->::TvWall::Packet_Notice_Stat_ViewStat_FlashStat::Clear();
  clear_has_flashstat();
}
inline const ::TvWall::Packet_Notice_Stat_ViewStat_FlashStat& Packet_Notice_Stat_ViewStat::flashstat() const {
  return flashstat_ != NULL ? *flashstat_ : *default_instance_->flashstat_;
}
inline ::TvWall::Packet_Notice_Stat_ViewStat_FlashStat* Packet_Notice_Stat_ViewStat::mutable_flashstat() {
  set_has_flashstat();
  if (flashstat_ == NULL) flashstat_ = new ::TvWall::Packet_Notice_Stat_ViewStat_FlashStat;
  return flashstat_;
}
inline ::TvWall::Packet_Notice_Stat_ViewStat_FlashStat* Packet_Notice_Stat_ViewStat::release_flashstat() {
  clear_has_flashstat();
  ::TvWall::Packet_Notice_Stat_ViewStat_FlashStat* temp = flashstat_;
  flashstat_ = NULL;
  return temp;
}
inline void Packet_Notice_Stat_ViewStat::set_allocated_flashstat(::TvWall::Packet_Notice_Stat_ViewStat_FlashStat* flashstat) {
  delete flashstat_;
  flashstat_ = flashstat;
  if (flashstat) {
    set_has_flashstat();
  } else {
    clear_has_flashstat();
  }
}

// optional .TvWall.Packet.Notice.Stat.ViewStat.HTMLStat htmlStat = 3;
inline bool Packet_Notice_Stat_ViewStat::has_htmlstat() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Packet_Notice_Stat_ViewStat::set_has_htmlstat() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Packet_Notice_Stat_ViewStat::clear_has_htmlstat() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Packet_Notice_Stat_ViewStat::clear_htmlstat() {
  if (htmlstat_ != NULL) htmlstat_->::TvWall::Packet_Notice_Stat_ViewStat_HTMLStat::Clear();
  clear_has_htmlstat();
}
inline const ::TvWall::Packet_Notice_Stat_ViewStat_HTMLStat& Packet_Notice_Stat_ViewStat::htmlstat() const {
  return htmlstat_ != NULL ? *htmlstat_ : *default_instance_->htmlstat_;
}
inline ::TvWall::Packet_Notice_Stat_ViewStat_HTMLStat* Packet_Notice_Stat_ViewStat::mutable_htmlstat() {
  set_has_htmlstat();
  if (htmlstat_ == NULL) htmlstat_ = new ::TvWall::Packet_Notice_Stat_ViewStat_HTMLStat;
  return htmlstat_;
}
inline ::TvWall::Packet_Notice_Stat_ViewStat_HTMLStat* Packet_Notice_Stat_ViewStat::release_htmlstat() {
  clear_has_htmlstat();
  ::TvWall::Packet_Notice_Stat_ViewStat_HTMLStat* temp = htmlstat_;
  htmlstat_ = NULL;
  return temp;
}
inline void Packet_Notice_Stat_ViewStat::set_allocated_htmlstat(::TvWall::Packet_Notice_Stat_ViewStat_HTMLStat* htmlstat) {
  delete htmlstat_;
  htmlstat_ = htmlstat;
  if (htmlstat) {
    set_has_htmlstat();
  } else {
    clear_has_htmlstat();
  }
}

// optional .TvWall.Packet.Notice.Stat.ViewStat.TextStat textStat = 4;
inline bool Packet_Notice_Stat_ViewStat::has_textstat() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Packet_Notice_Stat_ViewStat::set_has_textstat() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Packet_Notice_Stat_ViewStat::clear_has_textstat() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Packet_Notice_Stat_ViewStat::clear_textstat() {
  if (textstat_ != NULL) textstat_->::TvWall::Packet_Notice_Stat_ViewStat_TextStat::Clear();
  clear_has_textstat();
}
inline const ::TvWall::Packet_Notice_Stat_ViewStat_TextStat& Packet_Notice_Stat_ViewStat::textstat() const {
  return textstat_ != NULL ? *textstat_ : *default_instance_->textstat_;
}
inline ::TvWall::Packet_Notice_Stat_ViewStat_TextStat* Packet_Notice_Stat_ViewStat::mutable_textstat() {
  set_has_textstat();
  if (textstat_ == NULL) textstat_ = new ::TvWall::Packet_Notice_Stat_ViewStat_TextStat;
  return textstat_;
}
inline ::TvWall::Packet_Notice_Stat_ViewStat_TextStat* Packet_Notice_Stat_ViewStat::release_textstat() {
  clear_has_textstat();
  ::TvWall::Packet_Notice_Stat_ViewStat_TextStat* temp = textstat_;
  textstat_ = NULL;
  return temp;
}
inline void Packet_Notice_Stat_ViewStat::set_allocated_textstat(::TvWall::Packet_Notice_Stat_ViewStat_TextStat* textstat) {
  delete textstat_;
  textstat_ = textstat;
  if (textstat) {
    set_has_textstat();
  } else {
    clear_has_textstat();
  }
}

// optional .TvWall.Packet.Notice.Stat.ViewStat.OthersStat othersStat = 5;
inline bool Packet_Notice_Stat_ViewStat::has_othersstat() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Packet_Notice_Stat_ViewStat::set_has_othersstat() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Packet_Notice_Stat_ViewStat::clear_has_othersstat() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Packet_Notice_Stat_ViewStat::clear_othersstat() {
  if (othersstat_ != NULL) othersstat_->::TvWall::Packet_Notice_Stat_ViewStat_OthersStat::Clear();
  clear_has_othersstat();
}
inline const ::TvWall::Packet_Notice_Stat_ViewStat_OthersStat& Packet_Notice_Stat_ViewStat::othersstat() const {
  return othersstat_ != NULL ? *othersstat_ : *default_instance_->othersstat_;
}
inline ::TvWall::Packet_Notice_Stat_ViewStat_OthersStat* Packet_Notice_Stat_ViewStat::mutable_othersstat() {
  set_has_othersstat();
  if (othersstat_ == NULL) othersstat_ = new ::TvWall::Packet_Notice_Stat_ViewStat_OthersStat;
  return othersstat_;
}
inline ::TvWall::Packet_Notice_Stat_ViewStat_OthersStat* Packet_Notice_Stat_ViewStat::release_othersstat() {
  clear_has_othersstat();
  ::TvWall::Packet_Notice_Stat_ViewStat_OthersStat* temp = othersstat_;
  othersstat_ = NULL;
  return temp;
}
inline void Packet_Notice_Stat_ViewStat::set_allocated_othersstat(::TvWall::Packet_Notice_Stat_ViewStat_OthersStat* othersstat) {
  delete othersstat_;
  othersstat_ = othersstat;
  if (othersstat) {
    set_has_othersstat();
  } else {
    clear_has_othersstat();
  }
}

// optional .TvWall.Packet.Notice.Stat.ViewStat.LocalMovieStat localMovieStat = 6;
inline bool Packet_Notice_Stat_ViewStat::has_localmoviestat() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Packet_Notice_Stat_ViewStat::set_has_localmoviestat() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Packet_Notice_Stat_ViewStat::clear_has_localmoviestat() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Packet_Notice_Stat_ViewStat::clear_localmoviestat() {
  if (localmoviestat_ != NULL) localmoviestat_->::TvWall::Packet_Notice_Stat_ViewStat_LocalMovieStat::Clear();
  clear_has_localmoviestat();
}
inline const ::TvWall::Packet_Notice_Stat_ViewStat_LocalMovieStat& Packet_Notice_Stat_ViewStat::localmoviestat() const {
  return localmoviestat_ != NULL ? *localmoviestat_ : *default_instance_->localmoviestat_;
}
inline ::TvWall::Packet_Notice_Stat_ViewStat_LocalMovieStat* Packet_Notice_Stat_ViewStat::mutable_localmoviestat() {
  set_has_localmoviestat();
  if (localmoviestat_ == NULL) localmoviestat_ = new ::TvWall::Packet_Notice_Stat_ViewStat_LocalMovieStat;
  return localmoviestat_;
}
inline ::TvWall::Packet_Notice_Stat_ViewStat_LocalMovieStat* Packet_Notice_Stat_ViewStat::release_localmoviestat() {
  clear_has_localmoviestat();
  ::TvWall::Packet_Notice_Stat_ViewStat_LocalMovieStat* temp = localmoviestat_;
  localmoviestat_ = NULL;
  return temp;
}
inline void Packet_Notice_Stat_ViewStat::set_allocated_localmoviestat(::TvWall::Packet_Notice_Stat_ViewStat_LocalMovieStat* localmoviestat) {
  delete localmoviestat_;
  localmoviestat_ = localmoviestat;
  if (localmoviestat) {
    set_has_localmoviestat();
  } else {
    clear_has_localmoviestat();
  }
}

// optional .TvWall.Packet.Notice.Stat.ViewStat.ViewGeomotryStat viewGeomotryStat = 7;
inline bool Packet_Notice_Stat_ViewStat::has_viewgeomotrystat() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Packet_Notice_Stat_ViewStat::set_has_viewgeomotrystat() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Packet_Notice_Stat_ViewStat::clear_has_viewgeomotrystat() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Packet_Notice_Stat_ViewStat::clear_viewgeomotrystat() {
  if (viewgeomotrystat_ != NULL) viewgeomotrystat_->::TvWall::Packet_Notice_Stat_ViewStat_ViewGeomotryStat::Clear();
  clear_has_viewgeomotrystat();
}
inline const ::TvWall::Packet_Notice_Stat_ViewStat_ViewGeomotryStat& Packet_Notice_Stat_ViewStat::viewgeomotrystat() const {
  return viewgeomotrystat_ != NULL ? *viewgeomotrystat_ : *default_instance_->viewgeomotrystat_;
}
inline ::TvWall::Packet_Notice_Stat_ViewStat_ViewGeomotryStat* Packet_Notice_Stat_ViewStat::mutable_viewgeomotrystat() {
  set_has_viewgeomotrystat();
  if (viewgeomotrystat_ == NULL) viewgeomotrystat_ = new ::TvWall::Packet_Notice_Stat_ViewStat_ViewGeomotryStat;
  return viewgeomotrystat_;
}
inline ::TvWall::Packet_Notice_Stat_ViewStat_ViewGeomotryStat* Packet_Notice_Stat_ViewStat::release_viewgeomotrystat() {
  clear_has_viewgeomotrystat();
  ::TvWall::Packet_Notice_Stat_ViewStat_ViewGeomotryStat* temp = viewgeomotrystat_;
  viewgeomotrystat_ = NULL;
  return temp;
}
inline void Packet_Notice_Stat_ViewStat::set_allocated_viewgeomotrystat(::TvWall::Packet_Notice_Stat_ViewStat_ViewGeomotryStat* viewgeomotrystat) {
  delete viewgeomotrystat_;
  viewgeomotrystat_ = viewgeomotrystat;
  if (viewgeomotrystat) {
    set_has_viewgeomotrystat();
  } else {
    clear_has_viewgeomotrystat();
  }
}

// optional .TvWall.Packet.Notice.Stat.ViewStat.RecordStat recordStat = 8;
inline bool Packet_Notice_Stat_ViewStat::has_recordstat() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Packet_Notice_Stat_ViewStat::set_has_recordstat() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Packet_Notice_Stat_ViewStat::clear_has_recordstat() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Packet_Notice_Stat_ViewStat::clear_recordstat() {
  if (recordstat_ != NULL) recordstat_->::TvWall::Packet_Notice_Stat_ViewStat_RecordStat::Clear();
  clear_has_recordstat();
}
inline const ::TvWall::Packet_Notice_Stat_ViewStat_RecordStat& Packet_Notice_Stat_ViewStat::recordstat() const {
  return recordstat_ != NULL ? *recordstat_ : *default_instance_->recordstat_;
}
inline ::TvWall::Packet_Notice_Stat_ViewStat_RecordStat* Packet_Notice_Stat_ViewStat::mutable_recordstat() {
  set_has_recordstat();
  if (recordstat_ == NULL) recordstat_ = new ::TvWall::Packet_Notice_Stat_ViewStat_RecordStat;
  return recordstat_;
}
inline ::TvWall::Packet_Notice_Stat_ViewStat_RecordStat* Packet_Notice_Stat_ViewStat::release_recordstat() {
  clear_has_recordstat();
  ::TvWall::Packet_Notice_Stat_ViewStat_RecordStat* temp = recordstat_;
  recordstat_ = NULL;
  return temp;
}
inline void Packet_Notice_Stat_ViewStat::set_allocated_recordstat(::TvWall::Packet_Notice_Stat_ViewStat_RecordStat* recordstat) {
  delete recordstat_;
  recordstat_ = recordstat;
  if (recordstat) {
    set_has_recordstat();
  } else {
    clear_has_recordstat();
  }
}

// optional .TvWall.Packet.Notice.Stat.ViewStat.MapStat mapStat = 9;
inline bool Packet_Notice_Stat_ViewStat::has_mapstat() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Packet_Notice_Stat_ViewStat::set_has_mapstat() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Packet_Notice_Stat_ViewStat::clear_has_mapstat() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Packet_Notice_Stat_ViewStat::clear_mapstat() {
  if (mapstat_ != NULL) mapstat_->::TvWall::Packet_Notice_Stat_ViewStat_MapStat::Clear();
  clear_has_mapstat();
}
inline const ::TvWall::Packet_Notice_Stat_ViewStat_MapStat& Packet_Notice_Stat_ViewStat::mapstat() const {
  return mapstat_ != NULL ? *mapstat_ : *default_instance_->mapstat_;
}
inline ::TvWall::Packet_Notice_Stat_ViewStat_MapStat* Packet_Notice_Stat_ViewStat::mutable_mapstat() {
  set_has_mapstat();
  if (mapstat_ == NULL) mapstat_ = new ::TvWall::Packet_Notice_Stat_ViewStat_MapStat;
  return mapstat_;
}
inline ::TvWall::Packet_Notice_Stat_ViewStat_MapStat* Packet_Notice_Stat_ViewStat::release_mapstat() {
  clear_has_mapstat();
  ::TvWall::Packet_Notice_Stat_ViewStat_MapStat* temp = mapstat_;
  mapstat_ = NULL;
  return temp;
}
inline void Packet_Notice_Stat_ViewStat::set_allocated_mapstat(::TvWall::Packet_Notice_Stat_ViewStat_MapStat* mapstat) {
  delete mapstat_;
  mapstat_ = mapstat;
  if (mapstat) {
    set_has_mapstat();
  } else {
    clear_has_mapstat();
  }
}

// -------------------------------------------------------------------

// Packet_Notice_Stat_CameraStat

// required .TvWall.Packet.Notice.Stat.CameraStat.PTZ_TYPE type = 1;
inline bool Packet_Notice_Stat_CameraStat::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Packet_Notice_Stat_CameraStat::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Packet_Notice_Stat_CameraStat::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Packet_Notice_Stat_CameraStat::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::TvWall::Packet_Notice_Stat_CameraStat_PTZ_TYPE Packet_Notice_Stat_CameraStat::type() const {
  return static_cast< ::TvWall::Packet_Notice_Stat_CameraStat_PTZ_TYPE >(type_);
}
inline void Packet_Notice_Stat_CameraStat::set_type(::TvWall::Packet_Notice_Stat_CameraStat_PTZ_TYPE value) {
  assert(::TvWall::Packet_Notice_Stat_CameraStat_PTZ_TYPE_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional .TvWall.Guid cameraId = 2;
inline bool Packet_Notice_Stat_CameraStat::has_cameraid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Packet_Notice_Stat_CameraStat::set_has_cameraid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Packet_Notice_Stat_CameraStat::clear_has_cameraid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Packet_Notice_Stat_CameraStat::clear_cameraid() {
  if (cameraid_ != NULL) cameraid_->::TvWall::Guid::Clear();
  clear_has_cameraid();
}
inline const ::TvWall::Guid& Packet_Notice_Stat_CameraStat::cameraid() const {
  return cameraid_ != NULL ? *cameraid_ : *default_instance_->cameraid_;
}
inline ::TvWall::Guid* Packet_Notice_Stat_CameraStat::mutable_cameraid() {
  set_has_cameraid();
  if (cameraid_ == NULL) cameraid_ = new ::TvWall::Guid;
  return cameraid_;
}
inline ::TvWall::Guid* Packet_Notice_Stat_CameraStat::release_cameraid() {
  clear_has_cameraid();
  ::TvWall::Guid* temp = cameraid_;
  cameraid_ = NULL;
  return temp;
}
inline void Packet_Notice_Stat_CameraStat::set_allocated_cameraid(::TvWall::Guid* cameraid) {
  delete cameraid_;
  cameraid_ = cameraid;
  if (cameraid) {
    set_has_cameraid();
  } else {
    clear_has_cameraid();
  }
}

// repeated .TvWall.Packet.ElementDat.CameraGrp camGrp = 3;
inline int Packet_Notice_Stat_CameraStat::camgrp_size() const {
  return camgrp_.size();
}
inline void Packet_Notice_Stat_CameraStat::clear_camgrp() {
  camgrp_.Clear();
}
inline const ::TvWall::Packet_ElementDat_CameraGrp& Packet_Notice_Stat_CameraStat::camgrp(int index) const {
  return camgrp_.Get(index);
}
inline ::TvWall::Packet_ElementDat_CameraGrp* Packet_Notice_Stat_CameraStat::mutable_camgrp(int index) {
  return camgrp_.Mutable(index);
}
inline ::TvWall::Packet_ElementDat_CameraGrp* Packet_Notice_Stat_CameraStat::add_camgrp() {
  return camgrp_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TvWall::Packet_ElementDat_CameraGrp >&
Packet_Notice_Stat_CameraStat::camgrp() const {
  return camgrp_;
}
inline ::google::protobuf::RepeatedPtrField< ::TvWall::Packet_ElementDat_CameraGrp >*
Packet_Notice_Stat_CameraStat::mutable_camgrp() {
  return &camgrp_;
}

// optional .TvWall.Packet.ElementDat.Camera cam = 4;
inline bool Packet_Notice_Stat_CameraStat::has_cam() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Packet_Notice_Stat_CameraStat::set_has_cam() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Packet_Notice_Stat_CameraStat::clear_has_cam() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Packet_Notice_Stat_CameraStat::clear_cam() {
  if (cam_ != NULL) cam_->::TvWall::Packet_ElementDat_Camera::Clear();
  clear_has_cam();
}
inline const ::TvWall::Packet_ElementDat_Camera& Packet_Notice_Stat_CameraStat::cam() const {
  return cam_ != NULL ? *cam_ : *default_instance_->cam_;
}
inline ::TvWall::Packet_ElementDat_Camera* Packet_Notice_Stat_CameraStat::mutable_cam() {
  set_has_cam();
  if (cam_ == NULL) cam_ = new ::TvWall::Packet_ElementDat_Camera;
  return cam_;
}
inline ::TvWall::Packet_ElementDat_Camera* Packet_Notice_Stat_CameraStat::release_cam() {
  clear_has_cam();
  ::TvWall::Packet_ElementDat_Camera* temp = cam_;
  cam_ = NULL;
  return temp;
}
inline void Packet_Notice_Stat_CameraStat::set_allocated_cam(::TvWall::Packet_ElementDat_Camera* cam) {
  delete cam_;
  cam_ = cam;
  if (cam) {
    set_has_cam();
  } else {
    clear_has_cam();
  }
}

// optional .TvWall.Packet.ElementDat.CameraGrp grp = 5;
inline bool Packet_Notice_Stat_CameraStat::has_grp() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Packet_Notice_Stat_CameraStat::set_has_grp() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Packet_Notice_Stat_CameraStat::clear_has_grp() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Packet_Notice_Stat_CameraStat::clear_grp() {
  if (grp_ != NULL) grp_->::TvWall::Packet_ElementDat_CameraGrp::Clear();
  clear_has_grp();
}
inline const ::TvWall::Packet_ElementDat_CameraGrp& Packet_Notice_Stat_CameraStat::grp() const {
  return grp_ != NULL ? *grp_ : *default_instance_->grp_;
}
inline ::TvWall::Packet_ElementDat_CameraGrp* Packet_Notice_Stat_CameraStat::mutable_grp() {
  set_has_grp();
  if (grp_ == NULL) grp_ = new ::TvWall::Packet_ElementDat_CameraGrp;
  return grp_;
}
inline ::TvWall::Packet_ElementDat_CameraGrp* Packet_Notice_Stat_CameraStat::release_grp() {
  clear_has_grp();
  ::TvWall::Packet_ElementDat_CameraGrp* temp = grp_;
  grp_ = NULL;
  return temp;
}
inline void Packet_Notice_Stat_CameraStat::set_allocated_grp(::TvWall::Packet_ElementDat_CameraGrp* grp) {
  delete grp_;
  grp_ = grp;
  if (grp) {
    set_has_grp();
  } else {
    clear_has_grp();
  }
}

// -------------------------------------------------------------------

// Packet_Notice_Stat_HotPointStat

// required .TvWall.Packet.Notice.Stat.HotPointStat.HotPointStatType type = 1;
inline bool Packet_Notice_Stat_HotPointStat::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Packet_Notice_Stat_HotPointStat::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Packet_Notice_Stat_HotPointStat::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Packet_Notice_Stat_HotPointStat::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::TvWall::Packet_Notice_Stat_HotPointStat_HotPointStatType Packet_Notice_Stat_HotPointStat::type() const {
  return static_cast< ::TvWall::Packet_Notice_Stat_HotPointStat_HotPointStatType >(type_);
}
inline void Packet_Notice_Stat_HotPointStat::set_type(::TvWall::Packet_Notice_Stat_HotPointStat_HotPointStatType value) {
  assert(::TvWall::Packet_Notice_Stat_HotPointStat_HotPointStatType_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional .TvWall.Packet.ElementDat.HotPoint hotPoint = 2;
inline bool Packet_Notice_Stat_HotPointStat::has_hotpoint() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Packet_Notice_Stat_HotPointStat::set_has_hotpoint() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Packet_Notice_Stat_HotPointStat::clear_has_hotpoint() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Packet_Notice_Stat_HotPointStat::clear_hotpoint() {
  if (hotpoint_ != NULL) hotpoint_->::TvWall::Packet_ElementDat_HotPoint::Clear();
  clear_has_hotpoint();
}
inline const ::TvWall::Packet_ElementDat_HotPoint& Packet_Notice_Stat_HotPointStat::hotpoint() const {
  return hotpoint_ != NULL ? *hotpoint_ : *default_instance_->hotpoint_;
}
inline ::TvWall::Packet_ElementDat_HotPoint* Packet_Notice_Stat_HotPointStat::mutable_hotpoint() {
  set_has_hotpoint();
  if (hotpoint_ == NULL) hotpoint_ = new ::TvWall::Packet_ElementDat_HotPoint;
  return hotpoint_;
}
inline ::TvWall::Packet_ElementDat_HotPoint* Packet_Notice_Stat_HotPointStat::release_hotpoint() {
  clear_has_hotpoint();
  ::TvWall::Packet_ElementDat_HotPoint* temp = hotpoint_;
  hotpoint_ = NULL;
  return temp;
}
inline void Packet_Notice_Stat_HotPointStat::set_allocated_hotpoint(::TvWall::Packet_ElementDat_HotPoint* hotpoint) {
  delete hotpoint_;
  hotpoint_ = hotpoint;
  if (hotpoint) {
    set_has_hotpoint();
  } else {
    clear_has_hotpoint();
  }
}

// -------------------------------------------------------------------

// Packet_Notice_Stat_LayoutStat

// required .TvWall.Packet.Notice.Stat.LayoutStat.LayoutStatType type = 1;
inline bool Packet_Notice_Stat_LayoutStat::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Packet_Notice_Stat_LayoutStat::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Packet_Notice_Stat_LayoutStat::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Packet_Notice_Stat_LayoutStat::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::TvWall::Packet_Notice_Stat_LayoutStat_LayoutStatType Packet_Notice_Stat_LayoutStat::type() const {
  return static_cast< ::TvWall::Packet_Notice_Stat_LayoutStat_LayoutStatType >(type_);
}
inline void Packet_Notice_Stat_LayoutStat::set_type(::TvWall::Packet_Notice_Stat_LayoutStat_LayoutStatType value) {
  assert(::TvWall::Packet_Notice_Stat_LayoutStat_LayoutStatType_IsValid(value));
  set_has_type();
  type_ = value;
}

// repeated .TvWall.Packet.ElementDat.ServerLayout servLayout = 2;
inline int Packet_Notice_Stat_LayoutStat::servlayout_size() const {
  return servlayout_.size();
}
inline void Packet_Notice_Stat_LayoutStat::clear_servlayout() {
  servlayout_.Clear();
}
inline const ::TvWall::Packet_ElementDat_ServerLayout& Packet_Notice_Stat_LayoutStat::servlayout(int index) const {
  return servlayout_.Get(index);
}
inline ::TvWall::Packet_ElementDat_ServerLayout* Packet_Notice_Stat_LayoutStat::mutable_servlayout(int index) {
  return servlayout_.Mutable(index);
}
inline ::TvWall::Packet_ElementDat_ServerLayout* Packet_Notice_Stat_LayoutStat::add_servlayout() {
  return servlayout_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TvWall::Packet_ElementDat_ServerLayout >&
Packet_Notice_Stat_LayoutStat::servlayout() const {
  return servlayout_;
}
inline ::google::protobuf::RepeatedPtrField< ::TvWall::Packet_ElementDat_ServerLayout >*
Packet_Notice_Stat_LayoutStat::mutable_servlayout() {
  return &servlayout_;
}

// optional string currentLayout = 3;
inline bool Packet_Notice_Stat_LayoutStat::has_currentlayout() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Packet_Notice_Stat_LayoutStat::set_has_currentlayout() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Packet_Notice_Stat_LayoutStat::clear_has_currentlayout() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Packet_Notice_Stat_LayoutStat::clear_currentlayout() {
  if (currentlayout_ != &::google::protobuf::internal::kEmptyString) {
    currentlayout_->clear();
  }
  clear_has_currentlayout();
}
inline const ::std::string& Packet_Notice_Stat_LayoutStat::currentlayout() const {
  return *currentlayout_;
}
inline void Packet_Notice_Stat_LayoutStat::set_currentlayout(const ::std::string& value) {
  set_has_currentlayout();
  if (currentlayout_ == &::google::protobuf::internal::kEmptyString) {
    currentlayout_ = new ::std::string;
  }
  currentlayout_->assign(value);
}
inline void Packet_Notice_Stat_LayoutStat::set_currentlayout(const char* value) {
  set_has_currentlayout();
  if (currentlayout_ == &::google::protobuf::internal::kEmptyString) {
    currentlayout_ = new ::std::string;
  }
  currentlayout_->assign(value);
}
inline void Packet_Notice_Stat_LayoutStat::set_currentlayout(const char* value, size_t size) {
  set_has_currentlayout();
  if (currentlayout_ == &::google::protobuf::internal::kEmptyString) {
    currentlayout_ = new ::std::string;
  }
  currentlayout_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Packet_Notice_Stat_LayoutStat::mutable_currentlayout() {
  set_has_currentlayout();
  if (currentlayout_ == &::google::protobuf::internal::kEmptyString) {
    currentlayout_ = new ::std::string;
  }
  return currentlayout_;
}
inline ::std::string* Packet_Notice_Stat_LayoutStat::release_currentlayout() {
  clear_has_currentlayout();
  if (currentlayout_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = currentlayout_;
    currentlayout_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Packet_Notice_Stat_LayoutStat::set_allocated_currentlayout(::std::string* currentlayout) {
  if (currentlayout_ != &::google::protobuf::internal::kEmptyString) {
    delete currentlayout_;
  }
  if (currentlayout) {
    set_has_currentlayout();
    currentlayout_ = currentlayout;
  } else {
    clear_has_currentlayout();
    currentlayout_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .TvWall.Packet.ElementDat.ServerLayout dy = 4;
inline bool Packet_Notice_Stat_LayoutStat::has_dy() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Packet_Notice_Stat_LayoutStat::set_has_dy() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Packet_Notice_Stat_LayoutStat::clear_has_dy() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Packet_Notice_Stat_LayoutStat::clear_dy() {
  if (dy_ != NULL) dy_->::TvWall::Packet_ElementDat_ServerLayout::Clear();
  clear_has_dy();
}
inline const ::TvWall::Packet_ElementDat_ServerLayout& Packet_Notice_Stat_LayoutStat::dy() const {
  return dy_ != NULL ? *dy_ : *default_instance_->dy_;
}
inline ::TvWall::Packet_ElementDat_ServerLayout* Packet_Notice_Stat_LayoutStat::mutable_dy() {
  set_has_dy();
  if (dy_ == NULL) dy_ = new ::TvWall::Packet_ElementDat_ServerLayout;
  return dy_;
}
inline ::TvWall::Packet_ElementDat_ServerLayout* Packet_Notice_Stat_LayoutStat::release_dy() {
  clear_has_dy();
  ::TvWall::Packet_ElementDat_ServerLayout* temp = dy_;
  dy_ = NULL;
  return temp;
}
inline void Packet_Notice_Stat_LayoutStat::set_allocated_dy(::TvWall::Packet_ElementDat_ServerLayout* dy) {
  delete dy_;
  dy_ = dy;
  if (dy) {
    set_has_dy();
  } else {
    clear_has_dy();
  }
}

// -------------------------------------------------------------------

// Packet_Notice_Stat_LayoutLoopStat

// required .TvWall.Packet.Notice.Stat.LayoutLoopStat.LayoutLoopStatType type = 1;
inline bool Packet_Notice_Stat_LayoutLoopStat::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Packet_Notice_Stat_LayoutLoopStat::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Packet_Notice_Stat_LayoutLoopStat::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Packet_Notice_Stat_LayoutLoopStat::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::TvWall::Packet_Notice_Stat_LayoutLoopStat_LayoutLoopStatType Packet_Notice_Stat_LayoutLoopStat::type() const {
  return static_cast< ::TvWall::Packet_Notice_Stat_LayoutLoopStat_LayoutLoopStatType >(type_);
}
inline void Packet_Notice_Stat_LayoutLoopStat::set_type(::TvWall::Packet_Notice_Stat_LayoutLoopStat_LayoutLoopStatType value) {
  assert(::TvWall::Packet_Notice_Stat_LayoutLoopStat_LayoutLoopStatType_IsValid(value));
  set_has_type();
  type_ = value;
}

// repeated .TvWall.Packet.ElementDat.ServerLayoutLoop servLayoutLoop = 2;
inline int Packet_Notice_Stat_LayoutLoopStat::servlayoutloop_size() const {
  return servlayoutloop_.size();
}
inline void Packet_Notice_Stat_LayoutLoopStat::clear_servlayoutloop() {
  servlayoutloop_.Clear();
}
inline const ::TvWall::Packet_ElementDat_ServerLayoutLoop& Packet_Notice_Stat_LayoutLoopStat::servlayoutloop(int index) const {
  return servlayoutloop_.Get(index);
}
inline ::TvWall::Packet_ElementDat_ServerLayoutLoop* Packet_Notice_Stat_LayoutLoopStat::mutable_servlayoutloop(int index) {
  return servlayoutloop_.Mutable(index);
}
inline ::TvWall::Packet_ElementDat_ServerLayoutLoop* Packet_Notice_Stat_LayoutLoopStat::add_servlayoutloop() {
  return servlayoutloop_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TvWall::Packet_ElementDat_ServerLayoutLoop >&
Packet_Notice_Stat_LayoutLoopStat::servlayoutloop() const {
  return servlayoutloop_;
}
inline ::google::protobuf::RepeatedPtrField< ::TvWall::Packet_ElementDat_ServerLayoutLoop >*
Packet_Notice_Stat_LayoutLoopStat::mutable_servlayoutloop() {
  return &servlayoutloop_;
}

// optional string currentLayoutLoop = 4;
inline bool Packet_Notice_Stat_LayoutLoopStat::has_currentlayoutloop() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Packet_Notice_Stat_LayoutLoopStat::set_has_currentlayoutloop() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Packet_Notice_Stat_LayoutLoopStat::clear_has_currentlayoutloop() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Packet_Notice_Stat_LayoutLoopStat::clear_currentlayoutloop() {
  if (currentlayoutloop_ != &::google::protobuf::internal::kEmptyString) {
    currentlayoutloop_->clear();
  }
  clear_has_currentlayoutloop();
}
inline const ::std::string& Packet_Notice_Stat_LayoutLoopStat::currentlayoutloop() const {
  return *currentlayoutloop_;
}
inline void Packet_Notice_Stat_LayoutLoopStat::set_currentlayoutloop(const ::std::string& value) {
  set_has_currentlayoutloop();
  if (currentlayoutloop_ == &::google::protobuf::internal::kEmptyString) {
    currentlayoutloop_ = new ::std::string;
  }
  currentlayoutloop_->assign(value);
}
inline void Packet_Notice_Stat_LayoutLoopStat::set_currentlayoutloop(const char* value) {
  set_has_currentlayoutloop();
  if (currentlayoutloop_ == &::google::protobuf::internal::kEmptyString) {
    currentlayoutloop_ = new ::std::string;
  }
  currentlayoutloop_->assign(value);
}
inline void Packet_Notice_Stat_LayoutLoopStat::set_currentlayoutloop(const char* value, size_t size) {
  set_has_currentlayoutloop();
  if (currentlayoutloop_ == &::google::protobuf::internal::kEmptyString) {
    currentlayoutloop_ = new ::std::string;
  }
  currentlayoutloop_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Packet_Notice_Stat_LayoutLoopStat::mutable_currentlayoutloop() {
  set_has_currentlayoutloop();
  if (currentlayoutloop_ == &::google::protobuf::internal::kEmptyString) {
    currentlayoutloop_ = new ::std::string;
  }
  return currentlayoutloop_;
}
inline ::std::string* Packet_Notice_Stat_LayoutLoopStat::release_currentlayoutloop() {
  clear_has_currentlayoutloop();
  if (currentlayoutloop_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = currentlayoutloop_;
    currentlayoutloop_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Packet_Notice_Stat_LayoutLoopStat::set_allocated_currentlayoutloop(::std::string* currentlayoutloop) {
  if (currentlayoutloop_ != &::google::protobuf::internal::kEmptyString) {
    delete currentlayoutloop_;
  }
  if (currentlayoutloop) {
    set_has_currentlayoutloop();
    currentlayoutloop_ = currentlayoutloop;
  } else {
    clear_has_currentlayoutloop();
    currentlayoutloop_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 loop = 5;
inline bool Packet_Notice_Stat_LayoutLoopStat::has_loop() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Packet_Notice_Stat_LayoutLoopStat::set_has_loop() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Packet_Notice_Stat_LayoutLoopStat::clear_has_loop() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Packet_Notice_Stat_LayoutLoopStat::clear_loop() {
  loop_ = 0u;
  clear_has_loop();
}
inline ::google::protobuf::uint32 Packet_Notice_Stat_LayoutLoopStat::loop() const {
  return loop_;
}
inline void Packet_Notice_Stat_LayoutLoopStat::set_loop(::google::protobuf::uint32 value) {
  set_has_loop();
  loop_ = value;
}

// optional .TvWall.Packet.ElementDat.ServerLayoutLoop dy = 6;
inline bool Packet_Notice_Stat_LayoutLoopStat::has_dy() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Packet_Notice_Stat_LayoutLoopStat::set_has_dy() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Packet_Notice_Stat_LayoutLoopStat::clear_has_dy() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Packet_Notice_Stat_LayoutLoopStat::clear_dy() {
  if (dy_ != NULL) dy_->::TvWall::Packet_ElementDat_ServerLayoutLoop::Clear();
  clear_has_dy();
}
inline const ::TvWall::Packet_ElementDat_ServerLayoutLoop& Packet_Notice_Stat_LayoutLoopStat::dy() const {
  return dy_ != NULL ? *dy_ : *default_instance_->dy_;
}
inline ::TvWall::Packet_ElementDat_ServerLayoutLoop* Packet_Notice_Stat_LayoutLoopStat::mutable_dy() {
  set_has_dy();
  if (dy_ == NULL) dy_ = new ::TvWall::Packet_ElementDat_ServerLayoutLoop;
  return dy_;
}
inline ::TvWall::Packet_ElementDat_ServerLayoutLoop* Packet_Notice_Stat_LayoutLoopStat::release_dy() {
  clear_has_dy();
  ::TvWall::Packet_ElementDat_ServerLayoutLoop* temp = dy_;
  dy_ = NULL;
  return temp;
}
inline void Packet_Notice_Stat_LayoutLoopStat::set_allocated_dy(::TvWall::Packet_ElementDat_ServerLayoutLoop* dy) {
  delete dy_;
  dy_ = dy;
  if (dy) {
    set_has_dy();
  } else {
    clear_has_dy();
  }
}

// -------------------------------------------------------------------

// Packet_Notice_Stat_MapGrpStat

// required .TvWall.Packet.Notice.Stat.MapGrpStat.MapGrpStatType type = 1;
inline bool Packet_Notice_Stat_MapGrpStat::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Packet_Notice_Stat_MapGrpStat::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Packet_Notice_Stat_MapGrpStat::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Packet_Notice_Stat_MapGrpStat::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::TvWall::Packet_Notice_Stat_MapGrpStat_MapGrpStatType Packet_Notice_Stat_MapGrpStat::type() const {
  return static_cast< ::TvWall::Packet_Notice_Stat_MapGrpStat_MapGrpStatType >(type_);
}
inline void Packet_Notice_Stat_MapGrpStat::set_type(::TvWall::Packet_Notice_Stat_MapGrpStat_MapGrpStatType value) {
  assert(::TvWall::Packet_Notice_Stat_MapGrpStat_MapGrpStatType_IsValid(value));
  set_has_type();
  type_ = value;
}

// repeated .TvWall.Packet.ElementDat.Map mapGrp = 2;
inline int Packet_Notice_Stat_MapGrpStat::mapgrp_size() const {
  return mapgrp_.size();
}
inline void Packet_Notice_Stat_MapGrpStat::clear_mapgrp() {
  mapgrp_.Clear();
}
inline const ::TvWall::Packet_ElementDat_Map& Packet_Notice_Stat_MapGrpStat::mapgrp(int index) const {
  return mapgrp_.Get(index);
}
inline ::TvWall::Packet_ElementDat_Map* Packet_Notice_Stat_MapGrpStat::mutable_mapgrp(int index) {
  return mapgrp_.Mutable(index);
}
inline ::TvWall::Packet_ElementDat_Map* Packet_Notice_Stat_MapGrpStat::add_mapgrp() {
  return mapgrp_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TvWall::Packet_ElementDat_Map >&
Packet_Notice_Stat_MapGrpStat::mapgrp() const {
  return mapgrp_;
}
inline ::google::protobuf::RepeatedPtrField< ::TvWall::Packet_ElementDat_Map >*
Packet_Notice_Stat_MapGrpStat::mutable_mapgrp() {
  return &mapgrp_;
}

// -------------------------------------------------------------------

// Packet_Notice_Stat_ErrorStat

// required string error = 1;
inline bool Packet_Notice_Stat_ErrorStat::has_error() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Packet_Notice_Stat_ErrorStat::set_has_error() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Packet_Notice_Stat_ErrorStat::clear_has_error() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Packet_Notice_Stat_ErrorStat::clear_error() {
  if (error_ != &::google::protobuf::internal::kEmptyString) {
    error_->clear();
  }
  clear_has_error();
}
inline const ::std::string& Packet_Notice_Stat_ErrorStat::error() const {
  return *error_;
}
inline void Packet_Notice_Stat_ErrorStat::set_error(const ::std::string& value) {
  set_has_error();
  if (error_ == &::google::protobuf::internal::kEmptyString) {
    error_ = new ::std::string;
  }
  error_->assign(value);
}
inline void Packet_Notice_Stat_ErrorStat::set_error(const char* value) {
  set_has_error();
  if (error_ == &::google::protobuf::internal::kEmptyString) {
    error_ = new ::std::string;
  }
  error_->assign(value);
}
inline void Packet_Notice_Stat_ErrorStat::set_error(const char* value, size_t size) {
  set_has_error();
  if (error_ == &::google::protobuf::internal::kEmptyString) {
    error_ = new ::std::string;
  }
  error_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Packet_Notice_Stat_ErrorStat::mutable_error() {
  set_has_error();
  if (error_ == &::google::protobuf::internal::kEmptyString) {
    error_ = new ::std::string;
  }
  return error_;
}
inline ::std::string* Packet_Notice_Stat_ErrorStat::release_error() {
  clear_has_error();
  if (error_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = error_;
    error_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Packet_Notice_Stat_ErrorStat::set_allocated_error(::std::string* error) {
  if (error_ != &::google::protobuf::internal::kEmptyString) {
    delete error_;
  }
  if (error) {
    set_has_error();
    error_ = error;
  } else {
    clear_has_error();
    error_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// Packet_Notice_Stat_KeyboardSelectedStat

// required int32 screenId = 1;
inline bool Packet_Notice_Stat_KeyboardSelectedStat::has_screenid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Packet_Notice_Stat_KeyboardSelectedStat::set_has_screenid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Packet_Notice_Stat_KeyboardSelectedStat::clear_has_screenid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Packet_Notice_Stat_KeyboardSelectedStat::clear_screenid() {
  screenid_ = 0;
  clear_has_screenid();
}
inline ::google::protobuf::int32 Packet_Notice_Stat_KeyboardSelectedStat::screenid() const {
  return screenid_;
}
inline void Packet_Notice_Stat_KeyboardSelectedStat::set_screenid(::google::protobuf::int32 value) {
  set_has_screenid();
  screenid_ = value;
}

// required .TvWall.Guid cameraId = 2;
inline bool Packet_Notice_Stat_KeyboardSelectedStat::has_cameraid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Packet_Notice_Stat_KeyboardSelectedStat::set_has_cameraid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Packet_Notice_Stat_KeyboardSelectedStat::clear_has_cameraid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Packet_Notice_Stat_KeyboardSelectedStat::clear_cameraid() {
  if (cameraid_ != NULL) cameraid_->::TvWall::Guid::Clear();
  clear_has_cameraid();
}
inline const ::TvWall::Guid& Packet_Notice_Stat_KeyboardSelectedStat::cameraid() const {
  return cameraid_ != NULL ? *cameraid_ : *default_instance_->cameraid_;
}
inline ::TvWall::Guid* Packet_Notice_Stat_KeyboardSelectedStat::mutable_cameraid() {
  set_has_cameraid();
  if (cameraid_ == NULL) cameraid_ = new ::TvWall::Guid;
  return cameraid_;
}
inline ::TvWall::Guid* Packet_Notice_Stat_KeyboardSelectedStat::release_cameraid() {
  clear_has_cameraid();
  ::TvWall::Guid* temp = cameraid_;
  cameraid_ = NULL;
  return temp;
}
inline void Packet_Notice_Stat_KeyboardSelectedStat::set_allocated_cameraid(::TvWall::Guid* cameraid) {
  delete cameraid_;
  cameraid_ = cameraid;
  if (cameraid) {
    set_has_cameraid();
  } else {
    clear_has_cameraid();
  }
}

// required int32 cellid = 3;
inline bool Packet_Notice_Stat_KeyboardSelectedStat::has_cellid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Packet_Notice_Stat_KeyboardSelectedStat::set_has_cellid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Packet_Notice_Stat_KeyboardSelectedStat::clear_has_cellid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Packet_Notice_Stat_KeyboardSelectedStat::clear_cellid() {
  cellid_ = 0;
  clear_has_cellid();
}
inline ::google::protobuf::int32 Packet_Notice_Stat_KeyboardSelectedStat::cellid() const {
  return cellid_;
}
inline void Packet_Notice_Stat_KeyboardSelectedStat::set_cellid(::google::protobuf::int32 value) {
  set_has_cellid();
  cellid_ = value;
}

// -------------------------------------------------------------------

// Packet_Notice_Stat_AlarmStat

// required string alarmSource = 1;
inline bool Packet_Notice_Stat_AlarmStat::has_alarmsource() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Packet_Notice_Stat_AlarmStat::set_has_alarmsource() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Packet_Notice_Stat_AlarmStat::clear_has_alarmsource() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Packet_Notice_Stat_AlarmStat::clear_alarmsource() {
  if (alarmsource_ != &::google::protobuf::internal::kEmptyString) {
    alarmsource_->clear();
  }
  clear_has_alarmsource();
}
inline const ::std::string& Packet_Notice_Stat_AlarmStat::alarmsource() const {
  return *alarmsource_;
}
inline void Packet_Notice_Stat_AlarmStat::set_alarmsource(const ::std::string& value) {
  set_has_alarmsource();
  if (alarmsource_ == &::google::protobuf::internal::kEmptyString) {
    alarmsource_ = new ::std::string;
  }
  alarmsource_->assign(value);
}
inline void Packet_Notice_Stat_AlarmStat::set_alarmsource(const char* value) {
  set_has_alarmsource();
  if (alarmsource_ == &::google::protobuf::internal::kEmptyString) {
    alarmsource_ = new ::std::string;
  }
  alarmsource_->assign(value);
}
inline void Packet_Notice_Stat_AlarmStat::set_alarmsource(const char* value, size_t size) {
  set_has_alarmsource();
  if (alarmsource_ == &::google::protobuf::internal::kEmptyString) {
    alarmsource_ = new ::std::string;
  }
  alarmsource_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Packet_Notice_Stat_AlarmStat::mutable_alarmsource() {
  set_has_alarmsource();
  if (alarmsource_ == &::google::protobuf::internal::kEmptyString) {
    alarmsource_ = new ::std::string;
  }
  return alarmsource_;
}
inline ::std::string* Packet_Notice_Stat_AlarmStat::release_alarmsource() {
  clear_has_alarmsource();
  if (alarmsource_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = alarmsource_;
    alarmsource_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Packet_Notice_Stat_AlarmStat::set_allocated_alarmsource(::std::string* alarmsource) {
  if (alarmsource_ != &::google::protobuf::internal::kEmptyString) {
    delete alarmsource_;
  }
  if (alarmsource) {
    set_has_alarmsource();
    alarmsource_ = alarmsource;
  } else {
    clear_has_alarmsource();
    alarmsource_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required bool alarmClear = 2;
inline bool Packet_Notice_Stat_AlarmStat::has_alarmclear() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Packet_Notice_Stat_AlarmStat::set_has_alarmclear() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Packet_Notice_Stat_AlarmStat::clear_has_alarmclear() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Packet_Notice_Stat_AlarmStat::clear_alarmclear() {
  alarmclear_ = false;
  clear_has_alarmclear();
}
inline bool Packet_Notice_Stat_AlarmStat::alarmclear() const {
  return alarmclear_;
}
inline void Packet_Notice_Stat_AlarmStat::set_alarmclear(bool value) {
  set_has_alarmclear();
  alarmclear_ = value;
}

// -------------------------------------------------------------------

// Packet_Notice_Stat_GroupLoopStat

// required .TvWall.Packet.Notice.Stat.GroupLoopStat.GroupLoopStatType type = 1;
inline bool Packet_Notice_Stat_GroupLoopStat::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Packet_Notice_Stat_GroupLoopStat::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Packet_Notice_Stat_GroupLoopStat::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Packet_Notice_Stat_GroupLoopStat::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::TvWall::Packet_Notice_Stat_GroupLoopStat_GroupLoopStatType Packet_Notice_Stat_GroupLoopStat::type() const {
  return static_cast< ::TvWall::Packet_Notice_Stat_GroupLoopStat_GroupLoopStatType >(type_);
}
inline void Packet_Notice_Stat_GroupLoopStat::set_type(::TvWall::Packet_Notice_Stat_GroupLoopStat_GroupLoopStatType value) {
  assert(::TvWall::Packet_Notice_Stat_GroupLoopStat_GroupLoopStatType_IsValid(value));
  set_has_type();
  type_ = value;
}

// required .TvWall.Packet.ElementDat.GroupLoop groupLoop = 2;
inline bool Packet_Notice_Stat_GroupLoopStat::has_grouploop() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Packet_Notice_Stat_GroupLoopStat::set_has_grouploop() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Packet_Notice_Stat_GroupLoopStat::clear_has_grouploop() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Packet_Notice_Stat_GroupLoopStat::clear_grouploop() {
  if (grouploop_ != NULL) grouploop_->::TvWall::Packet_ElementDat_GroupLoop::Clear();
  clear_has_grouploop();
}
inline const ::TvWall::Packet_ElementDat_GroupLoop& Packet_Notice_Stat_GroupLoopStat::grouploop() const {
  return grouploop_ != NULL ? *grouploop_ : *default_instance_->grouploop_;
}
inline ::TvWall::Packet_ElementDat_GroupLoop* Packet_Notice_Stat_GroupLoopStat::mutable_grouploop() {
  set_has_grouploop();
  if (grouploop_ == NULL) grouploop_ = new ::TvWall::Packet_ElementDat_GroupLoop;
  return grouploop_;
}
inline ::TvWall::Packet_ElementDat_GroupLoop* Packet_Notice_Stat_GroupLoopStat::release_grouploop() {
  clear_has_grouploop();
  ::TvWall::Packet_ElementDat_GroupLoop* temp = grouploop_;
  grouploop_ = NULL;
  return temp;
}
inline void Packet_Notice_Stat_GroupLoopStat::set_allocated_grouploop(::TvWall::Packet_ElementDat_GroupLoop* grouploop) {
  delete grouploop_;
  grouploop_ = grouploop;
  if (grouploop) {
    set_has_grouploop();
  } else {
    clear_has_grouploop();
  }
}

// -------------------------------------------------------------------

// Packet_Notice_Stat

// optional .TvWall.Packet.Notice.Stat.ViewStat viewStat = 1;
inline bool Packet_Notice_Stat::has_viewstat() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Packet_Notice_Stat::set_has_viewstat() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Packet_Notice_Stat::clear_has_viewstat() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Packet_Notice_Stat::clear_viewstat() {
  if (viewstat_ != NULL) viewstat_->::TvWall::Packet_Notice_Stat_ViewStat::Clear();
  clear_has_viewstat();
}
inline const ::TvWall::Packet_Notice_Stat_ViewStat& Packet_Notice_Stat::viewstat() const {
  return viewstat_ != NULL ? *viewstat_ : *default_instance_->viewstat_;
}
inline ::TvWall::Packet_Notice_Stat_ViewStat* Packet_Notice_Stat::mutable_viewstat() {
  set_has_viewstat();
  if (viewstat_ == NULL) viewstat_ = new ::TvWall::Packet_Notice_Stat_ViewStat;
  return viewstat_;
}
inline ::TvWall::Packet_Notice_Stat_ViewStat* Packet_Notice_Stat::release_viewstat() {
  clear_has_viewstat();
  ::TvWall::Packet_Notice_Stat_ViewStat* temp = viewstat_;
  viewstat_ = NULL;
  return temp;
}
inline void Packet_Notice_Stat::set_allocated_viewstat(::TvWall::Packet_Notice_Stat_ViewStat* viewstat) {
  delete viewstat_;
  viewstat_ = viewstat;
  if (viewstat) {
    set_has_viewstat();
  } else {
    clear_has_viewstat();
  }
}

// optional .TvWall.Packet.Notice.Stat.CameraStat cameraStat = 2;
inline bool Packet_Notice_Stat::has_camerastat() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Packet_Notice_Stat::set_has_camerastat() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Packet_Notice_Stat::clear_has_camerastat() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Packet_Notice_Stat::clear_camerastat() {
  if (camerastat_ != NULL) camerastat_->::TvWall::Packet_Notice_Stat_CameraStat::Clear();
  clear_has_camerastat();
}
inline const ::TvWall::Packet_Notice_Stat_CameraStat& Packet_Notice_Stat::camerastat() const {
  return camerastat_ != NULL ? *camerastat_ : *default_instance_->camerastat_;
}
inline ::TvWall::Packet_Notice_Stat_CameraStat* Packet_Notice_Stat::mutable_camerastat() {
  set_has_camerastat();
  if (camerastat_ == NULL) camerastat_ = new ::TvWall::Packet_Notice_Stat_CameraStat;
  return camerastat_;
}
inline ::TvWall::Packet_Notice_Stat_CameraStat* Packet_Notice_Stat::release_camerastat() {
  clear_has_camerastat();
  ::TvWall::Packet_Notice_Stat_CameraStat* temp = camerastat_;
  camerastat_ = NULL;
  return temp;
}
inline void Packet_Notice_Stat::set_allocated_camerastat(::TvWall::Packet_Notice_Stat_CameraStat* camerastat) {
  delete camerastat_;
  camerastat_ = camerastat;
  if (camerastat) {
    set_has_camerastat();
  } else {
    clear_has_camerastat();
  }
}

// optional .TvWall.Packet.Notice.Stat.HotPointStat hotPointStat = 3;
inline bool Packet_Notice_Stat::has_hotpointstat() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Packet_Notice_Stat::set_has_hotpointstat() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Packet_Notice_Stat::clear_has_hotpointstat() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Packet_Notice_Stat::clear_hotpointstat() {
  if (hotpointstat_ != NULL) hotpointstat_->::TvWall::Packet_Notice_Stat_HotPointStat::Clear();
  clear_has_hotpointstat();
}
inline const ::TvWall::Packet_Notice_Stat_HotPointStat& Packet_Notice_Stat::hotpointstat() const {
  return hotpointstat_ != NULL ? *hotpointstat_ : *default_instance_->hotpointstat_;
}
inline ::TvWall::Packet_Notice_Stat_HotPointStat* Packet_Notice_Stat::mutable_hotpointstat() {
  set_has_hotpointstat();
  if (hotpointstat_ == NULL) hotpointstat_ = new ::TvWall::Packet_Notice_Stat_HotPointStat;
  return hotpointstat_;
}
inline ::TvWall::Packet_Notice_Stat_HotPointStat* Packet_Notice_Stat::release_hotpointstat() {
  clear_has_hotpointstat();
  ::TvWall::Packet_Notice_Stat_HotPointStat* temp = hotpointstat_;
  hotpointstat_ = NULL;
  return temp;
}
inline void Packet_Notice_Stat::set_allocated_hotpointstat(::TvWall::Packet_Notice_Stat_HotPointStat* hotpointstat) {
  delete hotpointstat_;
  hotpointstat_ = hotpointstat;
  if (hotpointstat) {
    set_has_hotpointstat();
  } else {
    clear_has_hotpointstat();
  }
}

// optional .TvWall.Packet.Notice.Stat.LayoutStat lyoutStat = 4;
inline bool Packet_Notice_Stat::has_lyoutstat() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Packet_Notice_Stat::set_has_lyoutstat() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Packet_Notice_Stat::clear_has_lyoutstat() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Packet_Notice_Stat::clear_lyoutstat() {
  if (lyoutstat_ != NULL) lyoutstat_->::TvWall::Packet_Notice_Stat_LayoutStat::Clear();
  clear_has_lyoutstat();
}
inline const ::TvWall::Packet_Notice_Stat_LayoutStat& Packet_Notice_Stat::lyoutstat() const {
  return lyoutstat_ != NULL ? *lyoutstat_ : *default_instance_->lyoutstat_;
}
inline ::TvWall::Packet_Notice_Stat_LayoutStat* Packet_Notice_Stat::mutable_lyoutstat() {
  set_has_lyoutstat();
  if (lyoutstat_ == NULL) lyoutstat_ = new ::TvWall::Packet_Notice_Stat_LayoutStat;
  return lyoutstat_;
}
inline ::TvWall::Packet_Notice_Stat_LayoutStat* Packet_Notice_Stat::release_lyoutstat() {
  clear_has_lyoutstat();
  ::TvWall::Packet_Notice_Stat_LayoutStat* temp = lyoutstat_;
  lyoutstat_ = NULL;
  return temp;
}
inline void Packet_Notice_Stat::set_allocated_lyoutstat(::TvWall::Packet_Notice_Stat_LayoutStat* lyoutstat) {
  delete lyoutstat_;
  lyoutstat_ = lyoutstat;
  if (lyoutstat) {
    set_has_lyoutstat();
  } else {
    clear_has_lyoutstat();
  }
}

// optional .TvWall.Packet.Notice.Stat.ScreenSpliStat screenStat = 5;
inline bool Packet_Notice_Stat::has_screenstat() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Packet_Notice_Stat::set_has_screenstat() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Packet_Notice_Stat::clear_has_screenstat() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Packet_Notice_Stat::clear_screenstat() {
  if (screenstat_ != NULL) screenstat_->::TvWall::Packet_Notice_Stat_ScreenSpliStat::Clear();
  clear_has_screenstat();
}
inline const ::TvWall::Packet_Notice_Stat_ScreenSpliStat& Packet_Notice_Stat::screenstat() const {
  return screenstat_ != NULL ? *screenstat_ : *default_instance_->screenstat_;
}
inline ::TvWall::Packet_Notice_Stat_ScreenSpliStat* Packet_Notice_Stat::mutable_screenstat() {
  set_has_screenstat();
  if (screenstat_ == NULL) screenstat_ = new ::TvWall::Packet_Notice_Stat_ScreenSpliStat;
  return screenstat_;
}
inline ::TvWall::Packet_Notice_Stat_ScreenSpliStat* Packet_Notice_Stat::release_screenstat() {
  clear_has_screenstat();
  ::TvWall::Packet_Notice_Stat_ScreenSpliStat* temp = screenstat_;
  screenstat_ = NULL;
  return temp;
}
inline void Packet_Notice_Stat::set_allocated_screenstat(::TvWall::Packet_Notice_Stat_ScreenSpliStat* screenstat) {
  delete screenstat_;
  screenstat_ = screenstat;
  if (screenstat) {
    set_has_screenstat();
  } else {
    clear_has_screenstat();
  }
}

// optional .TvWall.Packet.Notice.Stat.MapGrpStat mapGrpStat = 6;
inline bool Packet_Notice_Stat::has_mapgrpstat() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Packet_Notice_Stat::set_has_mapgrpstat() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Packet_Notice_Stat::clear_has_mapgrpstat() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Packet_Notice_Stat::clear_mapgrpstat() {
  if (mapgrpstat_ != NULL) mapgrpstat_->::TvWall::Packet_Notice_Stat_MapGrpStat::Clear();
  clear_has_mapgrpstat();
}
inline const ::TvWall::Packet_Notice_Stat_MapGrpStat& Packet_Notice_Stat::mapgrpstat() const {
  return mapgrpstat_ != NULL ? *mapgrpstat_ : *default_instance_->mapgrpstat_;
}
inline ::TvWall::Packet_Notice_Stat_MapGrpStat* Packet_Notice_Stat::mutable_mapgrpstat() {
  set_has_mapgrpstat();
  if (mapgrpstat_ == NULL) mapgrpstat_ = new ::TvWall::Packet_Notice_Stat_MapGrpStat;
  return mapgrpstat_;
}
inline ::TvWall::Packet_Notice_Stat_MapGrpStat* Packet_Notice_Stat::release_mapgrpstat() {
  clear_has_mapgrpstat();
  ::TvWall::Packet_Notice_Stat_MapGrpStat* temp = mapgrpstat_;
  mapgrpstat_ = NULL;
  return temp;
}
inline void Packet_Notice_Stat::set_allocated_mapgrpstat(::TvWall::Packet_Notice_Stat_MapGrpStat* mapgrpstat) {
  delete mapgrpstat_;
  mapgrpstat_ = mapgrpstat;
  if (mapgrpstat) {
    set_has_mapgrpstat();
  } else {
    clear_has_mapgrpstat();
  }
}

// optional .TvWall.Packet.Notice.Stat.LayoutLoopStat lyoutLoopStat = 7;
inline bool Packet_Notice_Stat::has_lyoutloopstat() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Packet_Notice_Stat::set_has_lyoutloopstat() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Packet_Notice_Stat::clear_has_lyoutloopstat() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Packet_Notice_Stat::clear_lyoutloopstat() {
  if (lyoutloopstat_ != NULL) lyoutloopstat_->::TvWall::Packet_Notice_Stat_LayoutLoopStat::Clear();
  clear_has_lyoutloopstat();
}
inline const ::TvWall::Packet_Notice_Stat_LayoutLoopStat& Packet_Notice_Stat::lyoutloopstat() const {
  return lyoutloopstat_ != NULL ? *lyoutloopstat_ : *default_instance_->lyoutloopstat_;
}
inline ::TvWall::Packet_Notice_Stat_LayoutLoopStat* Packet_Notice_Stat::mutable_lyoutloopstat() {
  set_has_lyoutloopstat();
  if (lyoutloopstat_ == NULL) lyoutloopstat_ = new ::TvWall::Packet_Notice_Stat_LayoutLoopStat;
  return lyoutloopstat_;
}
inline ::TvWall::Packet_Notice_Stat_LayoutLoopStat* Packet_Notice_Stat::release_lyoutloopstat() {
  clear_has_lyoutloopstat();
  ::TvWall::Packet_Notice_Stat_LayoutLoopStat* temp = lyoutloopstat_;
  lyoutloopstat_ = NULL;
  return temp;
}
inline void Packet_Notice_Stat::set_allocated_lyoutloopstat(::TvWall::Packet_Notice_Stat_LayoutLoopStat* lyoutloopstat) {
  delete lyoutloopstat_;
  lyoutloopstat_ = lyoutloopstat;
  if (lyoutloopstat) {
    set_has_lyoutloopstat();
  } else {
    clear_has_lyoutloopstat();
  }
}

// optional .TvWall.Packet.Notice.Stat.ErrorStat errStat = 8;
inline bool Packet_Notice_Stat::has_errstat() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Packet_Notice_Stat::set_has_errstat() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Packet_Notice_Stat::clear_has_errstat() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Packet_Notice_Stat::clear_errstat() {
  if (errstat_ != NULL) errstat_->::TvWall::Packet_Notice_Stat_ErrorStat::Clear();
  clear_has_errstat();
}
inline const ::TvWall::Packet_Notice_Stat_ErrorStat& Packet_Notice_Stat::errstat() const {
  return errstat_ != NULL ? *errstat_ : *default_instance_->errstat_;
}
inline ::TvWall::Packet_Notice_Stat_ErrorStat* Packet_Notice_Stat::mutable_errstat() {
  set_has_errstat();
  if (errstat_ == NULL) errstat_ = new ::TvWall::Packet_Notice_Stat_ErrorStat;
  return errstat_;
}
inline ::TvWall::Packet_Notice_Stat_ErrorStat* Packet_Notice_Stat::release_errstat() {
  clear_has_errstat();
  ::TvWall::Packet_Notice_Stat_ErrorStat* temp = errstat_;
  errstat_ = NULL;
  return temp;
}
inline void Packet_Notice_Stat::set_allocated_errstat(::TvWall::Packet_Notice_Stat_ErrorStat* errstat) {
  delete errstat_;
  errstat_ = errstat;
  if (errstat) {
    set_has_errstat();
  } else {
    clear_has_errstat();
  }
}

// optional .TvWall.Packet.Notice.Stat.KeyboardSelectedStat keyboardSelectedStat = 9;
inline bool Packet_Notice_Stat::has_keyboardselectedstat() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Packet_Notice_Stat::set_has_keyboardselectedstat() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Packet_Notice_Stat::clear_has_keyboardselectedstat() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Packet_Notice_Stat::clear_keyboardselectedstat() {
  if (keyboardselectedstat_ != NULL) keyboardselectedstat_->::TvWall::Packet_Notice_Stat_KeyboardSelectedStat::Clear();
  clear_has_keyboardselectedstat();
}
inline const ::TvWall::Packet_Notice_Stat_KeyboardSelectedStat& Packet_Notice_Stat::keyboardselectedstat() const {
  return keyboardselectedstat_ != NULL ? *keyboardselectedstat_ : *default_instance_->keyboardselectedstat_;
}
inline ::TvWall::Packet_Notice_Stat_KeyboardSelectedStat* Packet_Notice_Stat::mutable_keyboardselectedstat() {
  set_has_keyboardselectedstat();
  if (keyboardselectedstat_ == NULL) keyboardselectedstat_ = new ::TvWall::Packet_Notice_Stat_KeyboardSelectedStat;
  return keyboardselectedstat_;
}
inline ::TvWall::Packet_Notice_Stat_KeyboardSelectedStat* Packet_Notice_Stat::release_keyboardselectedstat() {
  clear_has_keyboardselectedstat();
  ::TvWall::Packet_Notice_Stat_KeyboardSelectedStat* temp = keyboardselectedstat_;
  keyboardselectedstat_ = NULL;
  return temp;
}
inline void Packet_Notice_Stat::set_allocated_keyboardselectedstat(::TvWall::Packet_Notice_Stat_KeyboardSelectedStat* keyboardselectedstat) {
  delete keyboardselectedstat_;
  keyboardselectedstat_ = keyboardselectedstat;
  if (keyboardselectedstat) {
    set_has_keyboardselectedstat();
  } else {
    clear_has_keyboardselectedstat();
  }
}

// optional .TvWall.Packet.Notice.Stat.AlarmStat alarmStat = 10;
inline bool Packet_Notice_Stat::has_alarmstat() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Packet_Notice_Stat::set_has_alarmstat() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Packet_Notice_Stat::clear_has_alarmstat() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Packet_Notice_Stat::clear_alarmstat() {
  if (alarmstat_ != NULL) alarmstat_->::TvWall::Packet_Notice_Stat_AlarmStat::Clear();
  clear_has_alarmstat();
}
inline const ::TvWall::Packet_Notice_Stat_AlarmStat& Packet_Notice_Stat::alarmstat() const {
  return alarmstat_ != NULL ? *alarmstat_ : *default_instance_->alarmstat_;
}
inline ::TvWall::Packet_Notice_Stat_AlarmStat* Packet_Notice_Stat::mutable_alarmstat() {
  set_has_alarmstat();
  if (alarmstat_ == NULL) alarmstat_ = new ::TvWall::Packet_Notice_Stat_AlarmStat;
  return alarmstat_;
}
inline ::TvWall::Packet_Notice_Stat_AlarmStat* Packet_Notice_Stat::release_alarmstat() {
  clear_has_alarmstat();
  ::TvWall::Packet_Notice_Stat_AlarmStat* temp = alarmstat_;
  alarmstat_ = NULL;
  return temp;
}
inline void Packet_Notice_Stat::set_allocated_alarmstat(::TvWall::Packet_Notice_Stat_AlarmStat* alarmstat) {
  delete alarmstat_;
  alarmstat_ = alarmstat;
  if (alarmstat) {
    set_has_alarmstat();
  } else {
    clear_has_alarmstat();
  }
}

// optional .TvWall.Packet.Notice.Stat.GroupLoopStat groupLoopStat = 11;
inline bool Packet_Notice_Stat::has_grouploopstat() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Packet_Notice_Stat::set_has_grouploopstat() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Packet_Notice_Stat::clear_has_grouploopstat() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Packet_Notice_Stat::clear_grouploopstat() {
  if (grouploopstat_ != NULL) grouploopstat_->::TvWall::Packet_Notice_Stat_GroupLoopStat::Clear();
  clear_has_grouploopstat();
}
inline const ::TvWall::Packet_Notice_Stat_GroupLoopStat& Packet_Notice_Stat::grouploopstat() const {
  return grouploopstat_ != NULL ? *grouploopstat_ : *default_instance_->grouploopstat_;
}
inline ::TvWall::Packet_Notice_Stat_GroupLoopStat* Packet_Notice_Stat::mutable_grouploopstat() {
  set_has_grouploopstat();
  if (grouploopstat_ == NULL) grouploopstat_ = new ::TvWall::Packet_Notice_Stat_GroupLoopStat;
  return grouploopstat_;
}
inline ::TvWall::Packet_Notice_Stat_GroupLoopStat* Packet_Notice_Stat::release_grouploopstat() {
  clear_has_grouploopstat();
  ::TvWall::Packet_Notice_Stat_GroupLoopStat* temp = grouploopstat_;
  grouploopstat_ = NULL;
  return temp;
}
inline void Packet_Notice_Stat::set_allocated_grouploopstat(::TvWall::Packet_Notice_Stat_GroupLoopStat* grouploopstat) {
  delete grouploopstat_;
  grouploopstat_ = grouploopstat;
  if (grouploopstat) {
    set_has_grouploopstat();
  } else {
    clear_has_grouploopstat();
  }
}

// -------------------------------------------------------------------

// Packet_Notice_NoticeMaster_NoticeMasterLyout

// required .TvWall.Packet.ElementMaster.MasterLayout masterLayout = 1;
inline bool Packet_Notice_NoticeMaster_NoticeMasterLyout::has_masterlayout() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Packet_Notice_NoticeMaster_NoticeMasterLyout::set_has_masterlayout() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Packet_Notice_NoticeMaster_NoticeMasterLyout::clear_has_masterlayout() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Packet_Notice_NoticeMaster_NoticeMasterLyout::clear_masterlayout() {
  if (masterlayout_ != NULL) masterlayout_->::TvWall::Packet_ElementMaster_MasterLayout::Clear();
  clear_has_masterlayout();
}
inline const ::TvWall::Packet_ElementMaster_MasterLayout& Packet_Notice_NoticeMaster_NoticeMasterLyout::masterlayout() const {
  return masterlayout_ != NULL ? *masterlayout_ : *default_instance_->masterlayout_;
}
inline ::TvWall::Packet_ElementMaster_MasterLayout* Packet_Notice_NoticeMaster_NoticeMasterLyout::mutable_masterlayout() {
  set_has_masterlayout();
  if (masterlayout_ == NULL) masterlayout_ = new ::TvWall::Packet_ElementMaster_MasterLayout;
  return masterlayout_;
}
inline ::TvWall::Packet_ElementMaster_MasterLayout* Packet_Notice_NoticeMaster_NoticeMasterLyout::release_masterlayout() {
  clear_has_masterlayout();
  ::TvWall::Packet_ElementMaster_MasterLayout* temp = masterlayout_;
  masterlayout_ = NULL;
  return temp;
}
inline void Packet_Notice_NoticeMaster_NoticeMasterLyout::set_allocated_masterlayout(::TvWall::Packet_ElementMaster_MasterLayout* masterlayout) {
  delete masterlayout_;
  masterlayout_ = masterlayout;
  if (masterlayout) {
    set_has_masterlayout();
  } else {
    clear_has_masterlayout();
  }
}

// -------------------------------------------------------------------

// Packet_Notice_NoticeMaster

// required .TvWall.Packet.Notice.NoticeMaster.NoticeMasterLyout nmlyout = 1;
inline bool Packet_Notice_NoticeMaster::has_nmlyout() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Packet_Notice_NoticeMaster::set_has_nmlyout() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Packet_Notice_NoticeMaster::clear_has_nmlyout() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Packet_Notice_NoticeMaster::clear_nmlyout() {
  if (nmlyout_ != NULL) nmlyout_->::TvWall::Packet_Notice_NoticeMaster_NoticeMasterLyout::Clear();
  clear_has_nmlyout();
}
inline const ::TvWall::Packet_Notice_NoticeMaster_NoticeMasterLyout& Packet_Notice_NoticeMaster::nmlyout() const {
  return nmlyout_ != NULL ? *nmlyout_ : *default_instance_->nmlyout_;
}
inline ::TvWall::Packet_Notice_NoticeMaster_NoticeMasterLyout* Packet_Notice_NoticeMaster::mutable_nmlyout() {
  set_has_nmlyout();
  if (nmlyout_ == NULL) nmlyout_ = new ::TvWall::Packet_Notice_NoticeMaster_NoticeMasterLyout;
  return nmlyout_;
}
inline ::TvWall::Packet_Notice_NoticeMaster_NoticeMasterLyout* Packet_Notice_NoticeMaster::release_nmlyout() {
  clear_has_nmlyout();
  ::TvWall::Packet_Notice_NoticeMaster_NoticeMasterLyout* temp = nmlyout_;
  nmlyout_ = NULL;
  return temp;
}
inline void Packet_Notice_NoticeMaster::set_allocated_nmlyout(::TvWall::Packet_Notice_NoticeMaster_NoticeMasterLyout* nmlyout) {
  delete nmlyout_;
  nmlyout_ = nmlyout;
  if (nmlyout) {
    set_has_nmlyout();
  } else {
    clear_has_nmlyout();
  }
}

// -------------------------------------------------------------------

// Packet_Notice

// repeated .TvWall.Packet.ElementDat.Screen screenInfo = 1;
inline int Packet_Notice::screeninfo_size() const {
  return screeninfo_.size();
}
inline void Packet_Notice::clear_screeninfo() {
  screeninfo_.Clear();
}
inline const ::TvWall::Packet_ElementDat_Screen& Packet_Notice::screeninfo(int index) const {
  return screeninfo_.Get(index);
}
inline ::TvWall::Packet_ElementDat_Screen* Packet_Notice::mutable_screeninfo(int index) {
  return screeninfo_.Mutable(index);
}
inline ::TvWall::Packet_ElementDat_Screen* Packet_Notice::add_screeninfo() {
  return screeninfo_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TvWall::Packet_ElementDat_Screen >&
Packet_Notice::screeninfo() const {
  return screeninfo_;
}
inline ::google::protobuf::RepeatedPtrField< ::TvWall::Packet_ElementDat_Screen >*
Packet_Notice::mutable_screeninfo() {
  return &screeninfo_;
}

// optional .TvWall.Packet.Notice.Stat statInfo = 2;
inline bool Packet_Notice::has_statinfo() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Packet_Notice::set_has_statinfo() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Packet_Notice::clear_has_statinfo() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Packet_Notice::clear_statinfo() {
  if (statinfo_ != NULL) statinfo_->::TvWall::Packet_Notice_Stat::Clear();
  clear_has_statinfo();
}
inline const ::TvWall::Packet_Notice_Stat& Packet_Notice::statinfo() const {
  return statinfo_ != NULL ? *statinfo_ : *default_instance_->statinfo_;
}
inline ::TvWall::Packet_Notice_Stat* Packet_Notice::mutable_statinfo() {
  set_has_statinfo();
  if (statinfo_ == NULL) statinfo_ = new ::TvWall::Packet_Notice_Stat;
  return statinfo_;
}
inline ::TvWall::Packet_Notice_Stat* Packet_Notice::release_statinfo() {
  clear_has_statinfo();
  ::TvWall::Packet_Notice_Stat* temp = statinfo_;
  statinfo_ = NULL;
  return temp;
}
inline void Packet_Notice::set_allocated_statinfo(::TvWall::Packet_Notice_Stat* statinfo) {
  delete statinfo_;
  statinfo_ = statinfo;
  if (statinfo) {
    set_has_statinfo();
  } else {
    clear_has_statinfo();
  }
}

// repeated .TvWall.Packet.ElementDat.CameraGrp cameraGrpInfo = 3;
inline int Packet_Notice::cameragrpinfo_size() const {
  return cameragrpinfo_.size();
}
inline void Packet_Notice::clear_cameragrpinfo() {
  cameragrpinfo_.Clear();
}
inline const ::TvWall::Packet_ElementDat_CameraGrp& Packet_Notice::cameragrpinfo(int index) const {
  return cameragrpinfo_.Get(index);
}
inline ::TvWall::Packet_ElementDat_CameraGrp* Packet_Notice::mutable_cameragrpinfo(int index) {
  return cameragrpinfo_.Mutable(index);
}
inline ::TvWall::Packet_ElementDat_CameraGrp* Packet_Notice::add_cameragrpinfo() {
  return cameragrpinfo_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TvWall::Packet_ElementDat_CameraGrp >&
Packet_Notice::cameragrpinfo() const {
  return cameragrpinfo_;
}
inline ::google::protobuf::RepeatedPtrField< ::TvWall::Packet_ElementDat_CameraGrp >*
Packet_Notice::mutable_cameragrpinfo() {
  return &cameragrpinfo_;
}

// optional .TvWall.Packet.Notice.NoticeMaster masterStat = 4;
inline bool Packet_Notice::has_masterstat() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Packet_Notice::set_has_masterstat() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Packet_Notice::clear_has_masterstat() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Packet_Notice::clear_masterstat() {
  if (masterstat_ != NULL) masterstat_->::TvWall::Packet_Notice_NoticeMaster::Clear();
  clear_has_masterstat();
}
inline const ::TvWall::Packet_Notice_NoticeMaster& Packet_Notice::masterstat() const {
  return masterstat_ != NULL ? *masterstat_ : *default_instance_->masterstat_;
}
inline ::TvWall::Packet_Notice_NoticeMaster* Packet_Notice::mutable_masterstat() {
  set_has_masterstat();
  if (masterstat_ == NULL) masterstat_ = new ::TvWall::Packet_Notice_NoticeMaster;
  return masterstat_;
}
inline ::TvWall::Packet_Notice_NoticeMaster* Packet_Notice::release_masterstat() {
  clear_has_masterstat();
  ::TvWall::Packet_Notice_NoticeMaster* temp = masterstat_;
  masterstat_ = NULL;
  return temp;
}
inline void Packet_Notice::set_allocated_masterstat(::TvWall::Packet_Notice_NoticeMaster* masterstat) {
  delete masterstat_;
  masterstat_ = masterstat;
  if (masterstat) {
    set_has_masterstat();
  } else {
    clear_has_masterstat();
  }
}

// -------------------------------------------------------------------

// Packet

// optional .TvWall.Packet.Session session = 2;
inline bool Packet::has_session() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Packet::set_has_session() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Packet::clear_has_session() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Packet::clear_session() {
  if (session_ != NULL) session_->::TvWall::Packet_Session::Clear();
  clear_has_session();
}
inline const ::TvWall::Packet_Session& Packet::session() const {
  return session_ != NULL ? *session_ : *default_instance_->session_;
}
inline ::TvWall::Packet_Session* Packet::mutable_session() {
  set_has_session();
  if (session_ == NULL) session_ = new ::TvWall::Packet_Session;
  return session_;
}
inline ::TvWall::Packet_Session* Packet::release_session() {
  clear_has_session();
  ::TvWall::Packet_Session* temp = session_;
  session_ = NULL;
  return temp;
}
inline void Packet::set_allocated_session(::TvWall::Packet_Session* session) {
  delete session_;
  session_ = session;
  if (session) {
    set_has_session();
  } else {
    clear_has_session();
  }
}

// optional .TvWall.Packet.Ctrl ctrl = 3;
inline bool Packet::has_ctrl() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Packet::set_has_ctrl() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Packet::clear_has_ctrl() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Packet::clear_ctrl() {
  if (ctrl_ != NULL) ctrl_->::TvWall::Packet_Ctrl::Clear();
  clear_has_ctrl();
}
inline const ::TvWall::Packet_Ctrl& Packet::ctrl() const {
  return ctrl_ != NULL ? *ctrl_ : *default_instance_->ctrl_;
}
inline ::TvWall::Packet_Ctrl* Packet::mutable_ctrl() {
  set_has_ctrl();
  if (ctrl_ == NULL) ctrl_ = new ::TvWall::Packet_Ctrl;
  return ctrl_;
}
inline ::TvWall::Packet_Ctrl* Packet::release_ctrl() {
  clear_has_ctrl();
  ::TvWall::Packet_Ctrl* temp = ctrl_;
  ctrl_ = NULL;
  return temp;
}
inline void Packet::set_allocated_ctrl(::TvWall::Packet_Ctrl* ctrl) {
  delete ctrl_;
  ctrl_ = ctrl;
  if (ctrl) {
    set_has_ctrl();
  } else {
    clear_has_ctrl();
  }
}

// optional .TvWall.Packet.RequireSession requireSession = 4;
inline bool Packet::has_requiresession() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Packet::set_has_requiresession() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Packet::clear_has_requiresession() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Packet::clear_requiresession() {
  if (requiresession_ != NULL) requiresession_->::TvWall::Packet_RequireSession::Clear();
  clear_has_requiresession();
}
inline const ::TvWall::Packet_RequireSession& Packet::requiresession() const {
  return requiresession_ != NULL ? *requiresession_ : *default_instance_->requiresession_;
}
inline ::TvWall::Packet_RequireSession* Packet::mutable_requiresession() {
  set_has_requiresession();
  if (requiresession_ == NULL) requiresession_ = new ::TvWall::Packet_RequireSession;
  return requiresession_;
}
inline ::TvWall::Packet_RequireSession* Packet::release_requiresession() {
  clear_has_requiresession();
  ::TvWall::Packet_RequireSession* temp = requiresession_;
  requiresession_ = NULL;
  return temp;
}
inline void Packet::set_allocated_requiresession(::TvWall::Packet_RequireSession* requiresession) {
  delete requiresession_;
  requiresession_ = requiresession;
  if (requiresession) {
    set_has_requiresession();
  } else {
    clear_has_requiresession();
  }
}

// optional .TvWall.Packet.Notice notice = 5;
inline bool Packet::has_notice() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Packet::set_has_notice() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Packet::clear_has_notice() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Packet::clear_notice() {
  if (notice_ != NULL) notice_->::TvWall::Packet_Notice::Clear();
  clear_has_notice();
}
inline const ::TvWall::Packet_Notice& Packet::notice() const {
  return notice_ != NULL ? *notice_ : *default_instance_->notice_;
}
inline ::TvWall::Packet_Notice* Packet::mutable_notice() {
  set_has_notice();
  if (notice_ == NULL) notice_ = new ::TvWall::Packet_Notice;
  return notice_;
}
inline ::TvWall::Packet_Notice* Packet::release_notice() {
  clear_has_notice();
  ::TvWall::Packet_Notice* temp = notice_;
  notice_ = NULL;
  return temp;
}
inline void Packet::set_allocated_notice(::TvWall::Packet_Notice* notice) {
  delete notice_;
  notice_ = notice;
  if (notice) {
    set_has_notice();
  } else {
    clear_has_notice();
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace TvWall

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TvWall::Packet_Session_LogoutReasonType>() {
  return ::TvWall::Packet_Session_LogoutReasonType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TvWall::Packet_ElementDat_View_ViewType>() {
  return ::TvWall::Packet_ElementDat_View_ViewType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TvWall::Packet_Ctrl_ViewCtrl_ViewGeomotryCtrl_ViewGeomotryCtrlType>() {
  return ::TvWall::Packet_Ctrl_ViewCtrl_ViewGeomotryCtrl_ViewGeomotryCtrlType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TvWall::Packet_Ctrl_ViewCtrl_VideoCtrl_VideoCtrlType>() {
  return ::TvWall::Packet_Ctrl_ViewCtrl_VideoCtrl_VideoCtrlType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TvWall::Packet_Ctrl_ViewCtrl_RecordCtrl_RecordCtrlType>() {
  return ::TvWall::Packet_Ctrl_ViewCtrl_RecordCtrl_RecordCtrlType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TvWall::Packet_Ctrl_ViewCtrl_FlashCtrl_FlashCtrlType>() {
  return ::TvWall::Packet_Ctrl_ViewCtrl_FlashCtrl_FlashCtrlType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TvWall::Packet_Ctrl_ViewCtrl_HTMLCtrl_HTMLCtrlType>() {
  return ::TvWall::Packet_Ctrl_ViewCtrl_HTMLCtrl_HTMLCtrlType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TvWall::Packet_Ctrl_ViewCtrl_LocalMovieCtrl_LocalMovieType>() {
  return ::TvWall::Packet_Ctrl_ViewCtrl_LocalMovieCtrl_LocalMovieType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TvWall::Packet_Ctrl_ViewCtrl_TextCtrl_TextCtrlType>() {
  return ::TvWall::Packet_Ctrl_ViewCtrl_TextCtrl_TextCtrlType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TvWall::Packet_Ctrl_ViewCtrl_MapCtrl_MapCtrlType>() {
  return ::TvWall::Packet_Ctrl_ViewCtrl_MapCtrl_MapCtrlType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TvWall::Packet_Ctrl_ViewCtrl_OthersCtrl_OthersCtrlType>() {
  return ::TvWall::Packet_Ctrl_ViewCtrl_OthersCtrl_OthersCtrlType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TvWall::Packet_Ctrl_CameraCtrl_PTZ_TYPE>() {
  return ::TvWall::Packet_Ctrl_CameraCtrl_PTZ_TYPE_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TvWall::Packet_Ctrl_HotPointCtrl_HotPointCtrlType>() {
  return ::TvWall::Packet_Ctrl_HotPointCtrl_HotPointCtrlType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TvWall::Packet_Ctrl_LayoutCtrl_LayoutCtrlType>() {
  return ::TvWall::Packet_Ctrl_LayoutCtrl_LayoutCtrlType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TvWall::Packet_Ctrl_LayoutLoopCtrl_LayoutLoopCtrlType>() {
  return ::TvWall::Packet_Ctrl_LayoutLoopCtrl_LayoutLoopCtrlType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TvWall::Packet_Ctrl_CtrlMaster_CtrlMasterLyout_CMLType>() {
  return ::TvWall::Packet_Ctrl_CtrlMaster_CtrlMasterLyout_CMLType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TvWall::Packet_Ctrl_MachineCtrl_MachineCtrlType>() {
  return ::TvWall::Packet_Ctrl_MachineCtrl_MachineCtrlType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TvWall::Packet_Ctrl_KeyCtrl_KeyType>() {
  return ::TvWall::Packet_Ctrl_KeyCtrl_KeyType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TvWall::Packet_Ctrl_KeyCmdCtrl_KeyCmdType>() {
  return ::TvWall::Packet_Ctrl_KeyCmdCtrl_KeyCmdType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TvWall::Packet_Ctrl_KeyCmdCtrl_KeyType>() {
  return ::TvWall::Packet_Ctrl_KeyCmdCtrl_KeyType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TvWall::Packet_Ctrl_SyncClockCtrl_SyncType>() {
  return ::TvWall::Packet_Ctrl_SyncClockCtrl_SyncType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TvWall::Packet_Ctrl_TextContextCtrl_TextContextType>() {
  return ::TvWall::Packet_Ctrl_TextContextCtrl_TextContextType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TvWall::Packet_Ctrl_GroupLoopCtrl_GroupLoopCtrlType>() {
  return ::TvWall::Packet_Ctrl_GroupLoopCtrl_GroupLoopCtrlType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TvWall::Packet_RequireSession_LocalMovieSessionAck_MovieStat>() {
  return ::TvWall::Packet_RequireSession_LocalMovieSessionAck_MovieStat_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TvWall::Packet_RequireSession_RecordRequire_RecordRequireType>() {
  return ::TvWall::Packet_RequireSession_RecordRequire_RecordRequireType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TvWall::Packet_RequireSession_ClientRequireType>() {
  return ::TvWall::Packet_RequireSession_ClientRequireType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TvWall::Packet_Notice_Stat_ViewStat_ViewGeomotryStat_ViewGeomotryStatType>() {
  return ::TvWall::Packet_Notice_Stat_ViewStat_ViewGeomotryStat_ViewGeomotryStatType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TvWall::Packet_Notice_Stat_ViewStat_VideoStat_VideoStatType>() {
  return ::TvWall::Packet_Notice_Stat_ViewStat_VideoStat_VideoStatType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TvWall::Packet_Notice_Stat_ViewStat_RecordStat_RecordStatType>() {
  return ::TvWall::Packet_Notice_Stat_ViewStat_RecordStat_RecordStatType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TvWall::Packet_Notice_Stat_ViewStat_LocalMovieStat_LocalMovieType>() {
  return ::TvWall::Packet_Notice_Stat_ViewStat_LocalMovieStat_LocalMovieType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TvWall::Packet_Notice_Stat_ViewStat_FlashStat_FlashStatType>() {
  return ::TvWall::Packet_Notice_Stat_ViewStat_FlashStat_FlashStatType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TvWall::Packet_Notice_Stat_ViewStat_HTMLStat_HTMLStatType>() {
  return ::TvWall::Packet_Notice_Stat_ViewStat_HTMLStat_HTMLStatType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TvWall::Packet_Notice_Stat_ViewStat_TextStat_TextStatType>() {
  return ::TvWall::Packet_Notice_Stat_ViewStat_TextStat_TextStatType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TvWall::Packet_Notice_Stat_ViewStat_MapStat_MapCtrlType>() {
  return ::TvWall::Packet_Notice_Stat_ViewStat_MapStat_MapCtrlType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TvWall::Packet_Notice_Stat_ViewStat_OthersStat_OthersStatType>() {
  return ::TvWall::Packet_Notice_Stat_ViewStat_OthersStat_OthersStatType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TvWall::Packet_Notice_Stat_CameraStat_PTZ_TYPE>() {
  return ::TvWall::Packet_Notice_Stat_CameraStat_PTZ_TYPE_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TvWall::Packet_Notice_Stat_HotPointStat_HotPointStatType>() {
  return ::TvWall::Packet_Notice_Stat_HotPointStat_HotPointStatType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TvWall::Packet_Notice_Stat_LayoutStat_LayoutStatType>() {
  return ::TvWall::Packet_Notice_Stat_LayoutStat_LayoutStatType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TvWall::Packet_Notice_Stat_LayoutLoopStat_LayoutLoopStatType>() {
  return ::TvWall::Packet_Notice_Stat_LayoutLoopStat_LayoutLoopStatType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TvWall::Packet_Notice_Stat_MapGrpStat_MapGrpStatType>() {
  return ::TvWall::Packet_Notice_Stat_MapGrpStat_MapGrpStatType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TvWall::Packet_Notice_Stat_GroupLoopStat_GroupLoopStatType>() {
  return ::TvWall::Packet_Notice_Stat_GroupLoopStat_GroupLoopStatType_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_protobuf_2ftvWall_2eproto__INCLUDED
